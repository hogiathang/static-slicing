addMember(user, options) {
    user = this.client.users.resolveID(user);
    if (!user) return Promise.reject(new TypeError('INVALID_TYPE', 'user', 'UserResolvable'));
    if (this.members.has(user)) return Promise.resolve(this.members.get(user));
    options.access_token = options.accessToken;
    if (options.roles) {
      const roles = [];
      for (let role of options.roles instanceof Collection ? options.roles.values() : options.roles) {
        role = this.roles.resolve(role);
        if (!role) {
          return Promise.reject(new TypeError('INVALID_TYPE', 'options.roles',
            'Array or Collection of Roles or Snowflakes', true));
        }
        roles.push(role.id);
      }
    }
    return this.client.api.guilds(this.id).members(user).put({ data: options })
      .then(data => this.members.add(data));
  }
user = this.client.users.resolveID(user)
Promise.reject(new TypeError('INVALID_TYPE', 'user', 'UserResolvable'))
Promise.resolve(this.members.get(user))
options.access_token = options.accessToken
options.roles
__ecma.Array.factory()
_iterator_9 = <operator>.iterator(options.roles instanceof Collection ? options.roles.values() : options.roles)
role = this.roles.resolve(role)
!role
roles.push(role.id)
this.client.api.guilds(this.id).members(user).put({ data: options })
      .then(data => this.members.add(data))
