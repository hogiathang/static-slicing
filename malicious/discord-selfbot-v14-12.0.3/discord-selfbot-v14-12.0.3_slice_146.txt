item.request.gen().end((err, res) => {
        if (res && res.headers) {
          this.requestLimit = Number(res.headers["x-ratelimit-limit"]);
          this.requestResetTime =
            Number(res.headers["x-ratelimit-reset"]) * 1000;
          this.requestRemaining = Number(res.headers["x-ratelimit-remaining"]);
          this.timeDifference =
            Date.now() - new Date(res.headers.date).getTime();
        }
        if (err) {
          if (err.status === 429) {
            this.queue.unshift(item);
            this.client.setTimeout(() => {
              this.globalLimit = false;
              resolve();
            }, Number(res.headers["retry-after"]) + this.client.options.restTimeOffset);
            if (res.headers["x-ratelimit-global"]) this.globalLimit = true;
          } else if (err.status >= 500 && err.status < 600) {
            if (item.retries === this.client.options.retryLimit) {
              item.reject(err);
              resolve();
            } else {...
res && res.headers
this.requestLimit = Number(res.headers["x-ratelimit-limit"])
this.requestResetTime =
            Number(res.headers["x-ratelimit-reset"]) * 1000
Number(res.headers["x-ratelimit-reset"]) * 1000
this.requestRemaining = Number(res.headers["x-ratelimit-remaining"])
this.timeDifference =
            Date.now() - new Date(res.headers.date).getTime()
Date.now() - new Date(res.headers.date).getTime()
err.status === 429
err.status >= 500 && err.status < 600
item.retries === this.client.options.retryLimit
item.retries++
(_tmp_10 = this.queue).unshift
this.client.setTimeout(
                resolve,
                1e3 + this.client.options.restTimeOffset
              )
1e3 + this.client.options.restTimeOffset
