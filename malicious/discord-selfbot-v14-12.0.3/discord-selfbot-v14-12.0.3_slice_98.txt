item.request.gen().end((err, res) => {
        if (res && res.headers) {
          this.requestLimit = Number(res.headers["x-ratelimit-limit"]);
          this.requestResetTime =
            Number(res.headers["x-ratelimit-reset"]) * 1000;
          this.requestRemaining = Number(res.headers["x-ratelimit-remaining"]);
          this.timeDifference =
            Date.now() - new Date(res.headers.date).getTime();
        }
        if (err) {
          if (err.status === 429) {
            this.queue.unshift(item);
            this.client.setTimeout(() => {
              this.globalLimit = false;
              resolve();
            }, Number(res.headers["retry-after"]) + this.client.options.restTimeOffset);
            if (res.headers["x-ratelimit-global"]) this.globalLimit = true;
          } else if (err.status >= 500 && err.status < 600) {
            if (item.retries === this.client.options.retryLimit) {
              item.reject(err);
              resolve();
            } else {...
res && res.headers
this.requestLimit = Number(res.headers["x-ratelimit-limit"])
this.requestResetTime =
            Number(res.headers["x-ratelimit-reset"]) * 1000
Number(res.headers["x-ratelimit-reset"]) * 1000
this.requestRemaining = Number(res.headers["x-ratelimit-remaining"])
this.timeDifference =
            Date.now() - new Date(res.headers.date).getTime()
Date.now() - new Date(res.headers.date).getTime()
this.globalLimit = false
const data = res && res.body ? res.body : {}
item.resolve(data)
this.requestRemaining === 0
this.client.listenerCount(RATE_LIMIT)
this.client.emit(RATE_LIMIT, {
                limit: this.requestLimit,
                timeDifference: this.timeDifference,
                path: item.request.path,
                method: item.request.method
              })
