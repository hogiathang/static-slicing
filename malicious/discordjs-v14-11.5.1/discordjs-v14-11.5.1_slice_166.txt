async execute(item) {
    // Insert item back to the beginning if currently busy
    if (this.busy) {
      this.queue.unshift(item);
      return null;
    }

    this.busy = true;
    const { reject, request, resolve } = item;

    // After calculations and requests have been done, pre-emptively stop further requests
    if (this.limited) {
      const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();

      if (this.manager.client.listenerCount(RATE_LIMIT)) {
        /**
         * Emitted when the client hits a rate limit while making a request
         * @event Client#rateLimit
         * @param {Object} rateLimitInfo Object containing the rate limit info
         * @param {number} rateLimitInfo.timeout Timeout in ms
         * @param {number} rateLimitInfo.limit Number of requests that can be made to this endpoint
         * @param {string} rateLimitInfo.method HTTP method used for request that triggered this event
         * @param {string} rateL...
this.busy
this.busy = true
request = _tmp_11.request
this.limited
const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now()
this.manager.client.listenerCount(RATE_LIMIT)
this.manager.client.emit(RATE_LIMIT, {
          timeout,
          limit: this.limit,
          method: request.method,
          path: request.path,
          route: request.route,
        })
_tmp_14.timeout = timeout
_tmp_14.limit = this.limit
_tmp_14.method = request.method
_tmp_14.path = request.path
_tmp_14.route = request.route
this.manager.globalTimeout
await this.manager.globalTimeout
await Util.delayFor(timeout)
res = await request.make()
res && res.headers
const serverDate = res.headers.get('date')
const limit = res.headers.get('x-ratelimit-limit')
const remaining = res.headers.get('x-ratelimit-remaining')
const reset = res.headers.get('x-ratelimit-reset')
const retryAfter = res.headers.get('retry-after')
this.limit = limit ? Number(limit) : Infinity
this.remaining = remaining ? Number(remaining) : 1
this.reset = reset ? calculateReset(reset, serverDate) : Date.now()
this.retryAfter = retryAfter ? Number(retryAfter) : -1
item.request.route.includes('reactions')
this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250
res.headers.get('x-ratelimit-global')
this.manager.globalTimeout = Util.delayFor(this.retryAfter)
await this.manager.globalTimeout
this.manager.globalTimeout = null
this.busy = false
res.ok
res.status === 429
res.status >= 500 && res.status < 600
item.retries === this.manager.client.options.retryLimit
item.retries++
(_tmp_28 = this.queue).unshift
this.run()
