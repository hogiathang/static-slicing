new Promise((resolve, reject) => {
      if (this.guild.memberCount === this.cache.size && !query && !limit && !presences && !user_ids) {
        resolve(this.cache);
        return;
      }
      if (!query && !user_ids) query = '';
      this.guild.shard.send({
        op: OPCodes.REQUEST_GUILD_MEMBERS,
        d: {
          guild_id: this.guild.id,
          presences,
          user_ids,
          query,
          limit,
        },
      });
      const fetchedMembers = new Collection();
      const option = query || limit || presences || user_ids;
      const handler = (members, guild) => {
        if (guild.id !== this.guild.id) return;
        timeout.refresh();
        for (const member of members.values()) {
          if (option) fetchedMembers.set(member.id, member);
        }
        if (
          this.guild.memberCount <= this.cache.size ||
          (option && members.size < 1000) ||
          (limit && fetchedMembers.size >= limit)
        ) {
          this.guild.cl...
this.guild.memberCount === this.cache.size && !query && !limit && !presences && !user_ids
!query && !user_ids
this.guild.shard.send({
        op: OPCodes.REQUEST_GUILD_MEMBERS,
        d: {
          guild_id: this.guild.id,
          presences,
          user_ids,
          query,
          limit,
        },
      })
_tmp_48.op = OPCodes.REQUEST_GUILD_MEMBERS
_tmp_48.d = {
          guild_id: this.guild.id,
          presences,
          user_ids,
          query,
          limit,
        }
_tmp_49.guild_id = this.guild.id
_tmp_49.presences = presences
_tmp_49.user_ids = user_ids
_tmp_49.query = query
_tmp_49.limit = limit
const fetchedMembers = new Collection()
const option = query || limit || presences || user_ids
const handler = (members, guild) => {
        if (guild.id !== this.guild.id) return;
        timeout.refresh();
        for (const member of members.values()) {
          if (option) fetchedMembers.set(member.id, member);
        }
        if (
          this.guild.memberCount <= this.cache.size ||
          (option && members.size < 1000) ||
          (limit && fetchedMembers.size >= limit)
        ) {
          this.guild.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);
          let fetched = option ? fetchedMembers : this.cache;
          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();
          resolve(fetched);
        }
      }
const timeout = this.guild.client.setTimeout(() => {
        this.guild.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);
        reject(new Error('GUILD_MEMBERS_TIMEOUT'));
      }, 120e3)
