async execute(item) {
    // Insert item back to the beginning if currently busy
    if (this.busy) {
      this.queue.unshift(item);
      return null;
    }

    this.busy = true;
    const { reject, request, resolve } = item;

    // After calculations and requests have been done, pre-emptively stop further requests
    if (this.limited) {
      const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();

      if (this.manager.client.listenerCount(RATE_LIMIT)) {
        /**
         * Emitted when the client hits a rate limit while making a request
         * @event Client#rateLimit
         * @param {Object} rateLimitInfo Object containing the rate limit info
         * @param {number} rateLimitInfo.timeout Timeout in ms
         * @param {number} rateLimitInfo.limit Number of requests that can be made to this endpoint
         * @param {string} rateLimitInfo.method HTTP method used for request that triggered this event
         * @param {string} rateL...
this.busy
this.busy = true
request = _tmp_11.request
this.limited
const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now()
this.manager.client.listenerCount(RATE_LIMIT)
this.manager.client.emit(RATE_LIMIT, {
          timeout,
          limit: this.limit,
          method: request.method,
          path: request.path,
          route: request.route,
        })
_tmp_14.timeout = timeout
_tmp_14.limit = this.limit
_tmp_14.method = request.method
_tmp_14.path = request.path
_tmp_14.route = request.route
this.manager.globalTimeout
await this.manager.globalTimeout
await Util.delayFor(timeout)
res = await request.make()
res && res.headers
const serverDate = res.headers.get('date')
const limit = res.headers.get('x-ratelimit-limit')
