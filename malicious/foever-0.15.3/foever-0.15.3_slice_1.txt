socket.data(['stop'], function () {
      function onStop(err) {
        var args = [];
        if (err && err instanceof Error) {
          args.push(['stop', 'error'], { message: err.message, stack: err.stack });
          self.monitor.removeListener('stop', onStop);
        }
        else {
          args.push(['stop', 'ok']);
          self.monitor.removeListener('error', onStop);
        }

        socket.send.apply(socket, args);
        if (self.exitOnStop) {
          process.exit();
        }
      }

      self.monitor.once('stop', onStop);
      self.monitor.once('error', onStop);

      if (process.platform === 'win32') {
        //
        // On Windows, delete the 'symbolic' sock file. This
        // file is used for exploration during `forever list`
        // as a mapping to the `\\.pipe\\*` "files" that can't
        // be enumerated because ... Windows.
        //
        fs.unlink(self._sockFile);
      }

      self.monitor.stop();
    })
function onStop = function onStop(err) {
        var args = [];
        if (err && err instanceof Error) {
          args.push(['stop', 'error'], { message: err.message, stack: err.stack });
          self.monitor.removeListener('stop', onStop);
        }
        else {
          args.push(['stop', 'ok']);
          self.monitor.removeListener('error', onStop);
        }

        socket.send.apply(socket, args);
        if (self.exitOnStop) {
          process.exit();
        }
      }
self.monitor.once('stop', onStop)
self.monitor.once('error', onStop)
process.platform === 'win32'
fs.unlink(self._sockFile)
