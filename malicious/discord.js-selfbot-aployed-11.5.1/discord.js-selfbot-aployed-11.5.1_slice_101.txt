handlePacket(msg, user) {
    msg.copy(nonce, 0, 0, 12);
    let data = secretbox.methods.open(msg.slice(12), nonce, this.voiceConnection.authentication.secretKey.key);
    if (!data) {
      /**
       * Emitted whenever a voice packet experiences a problem.
       * @event VoiceReceiver#warn
       * @param {string} reason The reason for the warning. If it happened because the voice packet could not be
       * decrypted, this would be `decrypt`. If it happened because the voice packet could not be decoded into
       * PCM, this would be `decode`
       * @param {string} message The warning message
       */
      this.emit('warn', 'decrypt', 'Failed to decrypt voice packet');
      return;
    }
    data = Buffer.from(data);

    // Strip RTP Header Extensions (one-byte only)
    if (data[0] === 0xBE && data[1] === 0xDE && data.length > 4) {
      const headerExtensionLength = data.readUInt16BE(2);
      let offset = 4;
      for (let i = 0; i < headerExtensionLength; i++) {
   ...
msg.copy(nonce, 0, 0, 12)
let data = secretbox.methods.open(msg.slice(12), nonce, this.voiceConnection.authentication.secretKey.key)
!data
data = Buffer.from(data)
data[0] === 0xBE && data[1] === 0xDE && data.length > 4
const headerExtensionLength = data.readUInt16BE(2)
let offset = 4
i < headerExtensionLength
const byte = data[offset]
offset++
byte === 0
continue;
offset += 1 + (0b1111 & (byte >> 4))
data[offset] === 0
offset++
data = data.slice(offset)
(_tmp_41 = this.opusStreams.get(user.id))._push
this.emit('opus', user, data)
