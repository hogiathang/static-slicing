handlePacket(msg, user) {
    msg.copy(nonce, 0, 0, 12);
    let data = secretbox.open(msg.slice(12), nonce, this.voiceConnection.authentication.secretKey.key);
    if (!data) {
      /**
       * Emitted whenever a voice packet experiences a problem.
       * @event VoiceReceiver#warn
       * @param {string} reason The reason for the warning. If it happened because the voice packet could not be
       * decrypted, this would be `decrypt`. If it happened because the voice packet could not be decoded into
       * PCM, this would be `decode`
       * @param {string} message The warning message
       */
      this.emit('warn', 'decrypt', 'Failed to decrypt voice packet');
      return;
    }
    data = Buffer.from(data);
    if (this.opusStreams.get(user.id)) this.opusStreams.get(user.id)._push(data);
    /**
     * Emitted whenever voice data is received from the voice connection. This is _always_ emitted (unlike PCM).
     * @event VoiceReceiver#opus
     * @param {User} user The ...
msg.copy(nonce, 0, 0, 12)
let data = secretbox.open(msg.slice(12), nonce, this.voiceConnection.authentication.secretKey.key)
!data
data = Buffer.from(data)
(_tmp_40 = this.opusStreams.get(user.id))._push
