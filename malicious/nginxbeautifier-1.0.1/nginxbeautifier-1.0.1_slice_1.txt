!String.prototype.trim
String.prototype.trim = function () {
        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    }
!String.prototype.startsWith
String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.substr(position, searchString.length) === searchString;
    }
!String.prototype.endsWith
String.prototype.endsWith = function (searchString, position) {
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    }
!String.prototype.includes
String.prototype.includes = function (search, start) {
        'use strict';
        if (typeof start !== 'number') {
            start = 0;
        }

        if (start + search.length > this.length) {
            return false;
        } else {
            return this.indexOf(search, start) !== -1;
        }
    }
!String.prototype.repeat
String.prototype.repeat = function (count) {
        'use strict';
        if (this == null) {
            throw new TypeError('can\'t convert ' + this + ' to object');
        }
        var str = '' + this;
        count = +count;
        if (count != count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length == 0 || count == 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (August 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        v...
!String.prototype.contains
String.prototype.contains = String.prototype.includes
!Array.prototype.insert
Array.prototype.insert = function (index, item) {
        this.splice(index, 0, item);
    }
function extractTextBySeperator = function extractTextBySeperator(input, seperator1, seperator2) {
    if (seperator2 == undefined)
        seperator2 = seperator1;
    var ret = "";
    var seperator1Regex = new RegExp(seperator1);
    var seperator2Regex = new RegExp(seperator2);
    var catchRegex = new RegExp(seperator1 + "(.*?)" + seperator2);
    if (seperator1Regex.test(input) && seperator2Regex.test(input)) {
        return input.match(catchRegex)[1];
    } else {
        return "";
    }
}
function extractAllPossibleText = function extractAllPossibleText(input, seperator1, seperator2) {
    if (seperator2 == undefined)
        seperator2 = seperator1;
    var extracted = {};
    var textInBetween = "";
    var cnt = 0;
    while ((textInBetween = extractTextBySeperator(input, seperator1, seperator2)) != "") {
        var placeHolder = "#$#%#$#placeholder" + cnt + "#$#%#$#";
        extracted[placeHolder] = seperator1 + textInBetween + seperator2;
        input = input.replace(extracted[placeHolder], placeHolder);
    }
    return {
        inputHidden: input,
        extracted: extracted,
        getRestored: function () {
            var textToFix = this.inputHidden;
            for (var key in extracted) {
                textToFix = textToFix.replace(key, extracted[key]);
            }
            return textToFix;
        }
    };


}
function strip_line = function strip_line(single_line) {
    //"""Strips the line and replaces neighbouring whitespaces with single space (except when within quotation marks)."""
    //trim the line before and after
    var trimmed = single_line.trim();
    //get text without any quatation marks(text foudn with quatation marks is replaced with a placeholder)
    var removedQuatations = extractAllPossibleText(trimmed, '"', '"');
    //replace multi spaces with single spaces
    removedQuatations.inputHidden = removedQuatations.inputHidden.replace(/\s\s+/g, ' ');
    //restore anything of quatation marks
    return removedQuatations.getRestored();
}
function clean_lines = function clean_lines(configContents) {
    var splittedByLines = configContents.split(/\r\n|\r|\n/g);
    //put {  } on their own seperate lines
    //trim the spaces before and after each line
    //trim multi spaces into single spaces
    //trim multi lines into two

    for (var index = 0, newline = 0; index < splittedByLines.length; index++) {
        if (!splittedByLines[index].trim().startsWith("#") && splittedByLines[index].trim() != "") {
            newline = 0;
            var line = splittedByLines[index] = strip_line(splittedByLines[index]);
            if (line != "}" && line != "{") {
                var i = line.indexOf("}")
                if (i >= 0) {
                    splittedByLines[index] = strip_line(line.slice(0, i - 1));
                    splittedByLines.insert(index + 1, "}");
                    var l2 = strip_line(line.slice(i + 1));
                    if (l2 != "")
                        splittedByLines.insert(index + 2, strip_line(line.slice(i + 1)...
function join_opening_bracket = function join_opening_bracket(lines) {
    var modified_lines, i;
    "When opening curly bracket is in it's own line (K&R convention), it's joined with precluding line (Java).";
    modified_lines = [];
    for (var i = 0, length = lines.length; i < length; i++) {
        if (i > 0 && lines[i] === "{") {
            modified_lines[modified_lines.length - 1] += " {";
            modified_lines.push("");
        } else if(modified_lines.length<=2||!(modified_lines[modified_lines.length - 2].endsWith(" {")&&lines[i]=="")){
            modified_lines.push(lines[i]);
        }
    }
    return modified_lines;
}
var INDENTATION = ' '.repeat(4)
function perform_indentation = function perform_indentation(lines) {
    var indented_lines, current_indent, line;
    "Indents the lines according to their nesting level determined by curly brackets.";
    indented_lines = [];
    current_indent = 0;
    var iterator1 = lines;
    for (var index1 = 0; index1 < iterator1.length; index1++) {
        line = iterator1[index1];
        if (!line.startsWith("#") && line.endsWith("}") && current_indent > 0) {
            current_indent -= 1;
        }
        if (line !== "") {
            indented_lines.push(INDENTATION.repeat(current_indent) + line);
        } else {
            indented_lines.push("");
        }
        if (!line.startsWith("#") && line.endsWith("{")) {
            current_indent += 1;
        }
    }
    return indented_lines;
}
function walkSync = function walkSync(dir, ext, filelist) {
    var fs = fs || require('fs'),
        files = fs.readdirSync(dir);
    filelist = filelist || [];
    ext = ext || "";
    files.forEach(function (file) {
        if (fs.statSync(dir + '/' + file).isDirectory()) {
            filelist = walkSync(dir + '/' + file, ext, filelist);
        }
        else if (file.endsWith(ext)) {
            filelist.push(dir + '/' + file);
        }
    });
    return filelist;
}
var fs = require('fs')
var path = require('path')
var options = {
        name: "nginxbeautify",
        spaces: 0,
        tabs: 0,
        dontJoinCurlyBracet: false,
        recursive: false,
        inputPath: ".",
        outputPath: ".",
        extension: "conf"

    }
_tmp_16.name = "nginxbeautify"
_tmp_16.spaces = 0
_tmp_16.tabs = 0
_tmp_16.dontJoinCurlyBracet = false
_tmp_16.recursive = false
_tmp_16.inputPath = "."
_tmp_16.outputPath = "."
_tmp_16.extension = "conf"
var knownArguments = {
        "--help": function (input) {
            if (input == "desc")
                return "Show this help text.";

            console.log("Usage: " + options.name + " [OPTION]... [FILE]...");
            console.log("Description: Formats nginx conf files into a more readable format by re-indenting the lines.");
            console.log("");
            console.log("Mandatory arguments to long options are mandatory for short options too, Arguments are case insensitive.");
            var argPrint = {};
            for (var key in knownArguments) {
                var desc = knownArguments[key]("desc");
                if (argPrint[desc] == null)
                    argPrint[desc] = '';
                argPrint[desc] = key + ", " + argPrint[desc];
            }
            for (var desc in argPrint) {
                console.log(argPrint[desc], desc);
            }
            console.log("");
            console.log("Usage examples:");
            console.log("(...
_tmp_17.--help = <lambda>8
_tmp_17.--space = <lambda>9
_tmp_17.--tabs = <lambda>10
_tmp_17.--dont-join = <lambda>11
_tmp_17.--recursive = <lambda>12
_tmp_17.--input = <lambda>13
_tmp_17.--output = <lambda>14
_tmp_17.--extension = <lambda>15
knownArguments["-h"] = knownArguments["--help"]
knownArguments["-s"] = knownArguments["--space"]
knownArguments["-t"] = knownArguments["--tabs"]
knownArguments["-r"] = knownArguments["--recursive"]
knownArguments["-i"] = knownArguments["--input"]
knownArguments["-o"] = knownArguments["--output"]
knownArguments["--dontjoin"] = knownArguments["--dont-join"]
knownArguments["-dj"] = knownArguments["--dont-join"]
knownArguments["-ext"] = knownArguments["--extension"]
knownArguments["-e"] = knownArguments["--extension"]
var wasFunc = null
process.argv.length >= 2
console.log("Error! no arguments were provided. I don't know what to do!")
knownArguments["--help"]()
process.exit()
