module.exports = function(appPath = '') {
  // Check that we're in a valid Zenapi project.
  if (!cli.isZenapiApp()) {
    return console.log(`⛔️ ${cyan('zenapi start')} can only be used inside a Zenapi project.`);
  }

  appPath = path.join(process.cwd(), appPath);

  try {
    const zenapi = (function() {
      try {
        return require(path.resolve(appPath, 'node_modules', 'zenapi'));
      } catch (e) {
        return require('../lib'); // zenapi // eslint-disable-line import/no-unresolved
      }
    })();

    // Set NODE_ENV
    if (_.isEmpty(process.env.NODE_ENV)) {
      process.env.NODE_ENV = 'development';
    }

    // Require server configurations
    const server = require(path.resolve(
      appPath,
      'config',
      'environments',
      'development',
      'server.json'
    ));

    if (process.env.NODE_ENV === 'development' && _.get(server, 'autoReload.enabled') === true) {
      if (cluster.isMaster) {
        cluster.on('message', (worker, message) => {
...
!cli.isZenapiApp()
appPath = path.join(process.cwd(), appPath)
const zenapi = (function() {
      try {
        return require(path.resolve(appPath, 'node_modules', 'zenapi'));
      } catch (e) {
        return require('../lib'); // zenapi // eslint-disable-line import/no-unresolved
      }
    })()
_.isEmpty(process.env.NODE_ENV)
process.env.NODE_ENV = 'development'
const server = require(path.resolve(
      appPath,
      'config',
      'environments',
      'development',
      'server.json'
    ))
"config"
"environments"
"development"
"server.json"
process.env.NODE_ENV === 'development' && _.get(server, 'autoReload.enabled') === true
cluster.isMaster
cluster.on('message', (worker, message) => {
          switch (message) {
            case 'reload':
              zenapi.log.info('The server is restarting\n');
              worker.send('isKilled');
              break;
            case 'kill':
              worker.kill();
              cluster.fork();
              break;
            case 'stop':
              worker.kill();
              process.exit(1);
              break;
            default:
              return;
          }
        })
cluster.fork()
