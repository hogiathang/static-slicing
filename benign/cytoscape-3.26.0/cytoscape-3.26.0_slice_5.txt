BRp.findEdgeControlPoints = function( edges ){
  if( !edges || edges.length === 0 ){ return; }

  let r = this;
  let cy = r.cy;
  let hasCompounds = cy.hasCompoundNodes();

  let hashTable = {
    map: new Map(),
    get: function(pairId){
      let map2 = this.map.get(pairId[0]);

      if( map2 != null ){
        return map2.get(pairId[1]);
      } else {
        return null;
      }
    },
    set: function(pairId, val){
      let map2 = this.map.get(pairId[0]);

      if( map2 == null ){
        map2 = new Map();
        this.map.set(pairId[0], map2);
      }

      map2.set(pairId[1], val);
    }
  };

  let pairIds = [];
  let haystackEdges = [];

  // create a table of edge (src, tgt) => list of edges between them
  for( let i = 0; i < edges.length; i++ ){
    let edge = edges[i];
    let _p = edge._private;
    let curveStyle = edge.pstyle('curve-style').value;

    // ignore edges who are not to be displayed
    // they shouldn't take up space
    if( edge.removed() || !ed...
!edges || edges.length === 0
let r = this
let cy = r.cy
let hasCompounds = cy.hasCompoundNodes()
let hashTable = {
    map: new Map(),
    get: function(pairId){
      let map2 = this.map.get(pairId[0]);

      if( map2 != null ){
        return map2.get(pairId[1]);
      } else {
        return null;
      }
    },
    set: function(pairId, val){
      let map2 = this.map.get(pairId[0]);

      if( map2 == null ){
        map2 = new Map();
        this.map.set(pairId[0], map2);
      }

      map2.set(pairId[1], val);
    }
  }
_tmp_52.map = new Map()
_tmp_52.get = <lambda>13
_tmp_52.set = <lambda>14
__ecma.Array.factory()
let haystackEdges = []
i < edges.length
let edge = edges[i]
let _p = edge._private
let curveStyle = edge.pstyle('curve-style').value
edge.removed() || !edge.takesUpSpace()
continue;
curveStyle === 'haystack'
haystackEdges.push( edge )
continue;
let edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'straight' || curveStyle === 'straight-triangle' || curveStyle === 'taxi'
let edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier'
let src = _p.source
let tgt = _p.target
let srcIndex = src.poolIndex()
let tgtIndex = tgt.poolIndex()
let pairId = [ srcIndex, tgtIndex ].sort()
let tableEntry = hashTable.get( pairId )
tableEntry == null
_tmp_60.eles = __ecma.Array.factory()
hashTable.set( pairId, tableEntry )
pairIds.push( pairId )
(_tmp_61 = tableEntry.eles).push
tableEntry.hasUnbundled = true
tableEntry.hasBezier = true
