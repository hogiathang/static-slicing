ETCp.getElement = function( ele, bb, pxRatio, lvl, reason ){
  let self = this;
  let r = this.renderer;
  let zoom = r.cy.zoom();
  let lookup = this.lookup;

  if( !bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed() ){ return null; }

  if(
    ( !self.allowEdgeTxrCaching && ele.isEdge() )
    || ( !self.allowParentTxrCaching && ele.isParent() )
  ){
    return null;
  }

  if( lvl == null ){
    lvl = Math.ceil( math.log2( zoom * pxRatio ) );
  }

  if( lvl < minLvl ){
    lvl = minLvl;
  } else if( zoom >= maxZoom || lvl > maxLvl ){
    return null;
  }

  let scale = Math.pow( 2, lvl );
  let eleScaledH = bb.h * scale;
  let eleScaledW = bb.w * scale;
  let scaledLabelShown = r.eleTextBiggerThanMin( ele, scale );

  if( !this.isVisible(ele, scaledLabelShown) ){ return null; }

  let eleCache = lookup.get( ele, lvl );

  // if this get was on an unused/invalidated cache, then restore the texture usage metric
  if( eleCache && eleCache...
let self = this
let r = this.renderer
let zoom = r.cy.zoom()
let lookup = this.lookup
!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()
( !self.allowEdgeTxrCaching && ele.isEdge() )
    || ( !self.allowParentTxrCaching && ele.isParent() )
!self.allowParentTxrCaching && ele.isParent()
lvl == null
lvl = Math.ceil( math.log2( zoom * pxRatio ) )
lvl < minLvl
lvl = minLvl
zoom >= maxZoom || lvl > maxLvl
let scale = Math.pow( 2, lvl )
let eleScaledH = bb.h * scale
let eleScaledW = bb.w * scale
let scaledLabelShown = r.eleTextBiggerThanMin( ele, scale )
!this.isVisible(ele, scaledLabelShown)
let eleCache = lookup.get( ele, lvl )
