_tmp_20.exit = exit
this.ranCommonJS = true
var strict = !!this.opts.strict
var noInterop = !!this.opts.noInterop
var scope = path.scope
scope.rename("module")
scope.rename("exports")
scope.rename("require")
var hasExports = false
var hasImports = false
var body = path.get("body")
var imports = (0, _create2.default)(null)
var exports = (0, _create2.default)(null)
var nonHoistedExportNames = (0, _create2.default)(null)
__ecma.Array.factory()
var remaps = (0, _create2.default)(null)
var requires = (0, _create2.default)(null)
function addRequire = function addRequire(source, blockHoist) {
            var cached = requires[source];
            if (cached) return cached;

            var ref = path.scope.generateUidIdentifier((0, _path2.basename)(source, (0, _path2.extname)(source)));

            var varDecl = t.variableDeclaration("var", [t.variableDeclarator(ref, buildRequire(t.stringLiteral(source)).expression)]);

            if (imports[source]) {
              varDecl.loc = imports[source].loc;
            }

            if (typeof blockHoist === "number" && blockHoist > 0) {
              varDecl._blockHoist = blockHoist;
            }

            topNodes.push(varDecl);

            return requires[source] = ref;
          }
function addTo = function addTo(obj, key, arr) {
            var existing = obj[key] || [];
            obj[key] = existing.concat(arr);
          }
var _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4)
_i4 >= _iterator4.length
_ref4 = _iterator4[_i4++]
_i4 = _iterator4.next()
_i4.done
_ref4 = _i4.value
var _path = _ref4
_path.isExportDeclaration()
hasExports = true
var specifiers = [].concat(_path.get("declaration"), _path.get("specifiers"))
var _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6)
_i6 >= _iterator6.length
_ref6 = _iterator6[_i6++]
_i6 = _iterator6.next()
_i6.done
_ref6 = _i6.value
var _specifier2 = _ref6
var ids = _specifier2.getBindingIdentifiers()
ids.__esModule
throw _specifier2.buildCodeFrameError("Illegal export \"__esModule\"");
_path.isImportDeclaration()
hasImports = true
var key = _path.node.source.value
var importsEntry = imports[key] || {
                specifiers: [],
                maxBlockHoist: 0,
                loc: _path.node.loc
              }
_tmp_24.specifiers = __ecma.Array.factory()
_tmp_24.maxBlockHoist = 0
_tmp_24.loc = _path.node.loc
(_importsEntry$specifi = importsEntry.specifiers).push.apply(_importsEntry$specifi, _path.node.specifiers)
typeof _path.node._blockHoist === "number"
importsEntry.maxBlockHoist = Math.max(_path.node._blockHoist, importsEntry.maxBlockHoist)
imports[key] = importsEntry
_path.remove()
_path.isExportDefaultDeclaration()
var declaration = _path.get("declaration")
declaration.isFunctionDeclaration()
var id = declaration.node.id
var defNode = t.identifier("default")
addTo(exports, id.name, defNode)
topNodes.push(buildExportsAssignment(defNode, id))
_path.replaceWith(declaration.node)
topNodes.push(buildExportsAssignment(defNode, t.toExpression(declaration.node)))
_path.remove()
declaration.isClassDeclaration()
var _id = declaration.node.id
var _defNode = t.identifier("default")
addTo(exports, _id.name, _defNode)
_path.replaceWithMultiple([declaration.node, buildExportsAssignment(_defNode, _id)])
_path.replaceWith(buildExportsAssignment(_defNode, t.toExpression(declaration.node)))
_path.parentPath.requeue(_path.get("expression.left"))
_path.replaceWith(buildExportsAssignment(t.identifier("default"), declaration.node))
_path.parentPath.requeue(_path.get("expression.left"))
_path.isExportNamedDeclaration()
var _declaration = _path.get("declaration")
_declaration.node
_declaration.isFunctionDeclaration()
var _id2 = _declaration.node.id
addTo(exports, _id2.name, _id2)
topNodes.push(buildExportsAssignment(_id2, _id2))
_path.replaceWith(_declaration.node)
_declaration.isClassDeclaration()
var _id3 = _declaration.node.id
addTo(exports, _id3.name, _id3)
_path.replaceWithMultiple([_declaration.node, buildExportsAssignment(_id3, _id3)])
nonHoistedExportNames[_id3.name] = true
_declaration.isVariableDeclaration()
var declarators = _declaration.get("declarations")
var _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7)
_i7 >= _iterator7.length
_ref7 = _iterator7[_i7++]
_i7 = _iterator7.next()
_i7.done
_ref7 = _i7.value
var decl = _ref7
var _id4 = decl.get("id")
var init = decl.get("init")
var exportsToInsert = []
init.replaceWith(t.identifier("undefined"))
_id4.isIdentifier()
addTo(exports, _id4.node.name, _id4.node)
init.replaceWith(buildExportsAssignment(_id4.node, init.node).expression)
nonHoistedExportNames[_id4.node.name] = true
_id4.isObjectPattern()
_i8 < _id4.node.properties.length
var prop = _id4.node.properties[_i8]
var propValue = prop.value
t.isAssignmentPattern(propValue)
propValue = propValue.left
t.isRestProperty(prop)
propValue = prop.argument
addTo(exports, propValue.name, propValue)
exportsToInsert.push(buildExportsAssignment(propValue, propValue))
nonHoistedExportNames[propValue.name] = true
_id4.isArrayPattern() && _id4.node.elements
_i9 < _id4.node.elements.length
var elem = _id4.node.elements[_i9]
!elem
t.isAssignmentPattern(elem)
elem = elem.left
t.isRestElement(elem)
elem = elem.argument
var name = elem.name
addTo(exports, name, elem)
exportsToInsert.push(buildExportsAssignment(elem, elem))
nonHoistedExportNames[name] = true
_path.insertAfter(exportsToInsert)
_path.replaceWith(_declaration.node)
continue;
var _specifiers = _path.get("specifiers")
__ecma.Array.factory()
var _source = _path.node.source
var ref = addRequire(_source.value, _path.node._blockHoist)
var _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8)
_i10 >= _iterator8.length
_ref8 = _iterator8[_i10++]
_i10 = _iterator8.next()
_i10.done
_ref8 = _i10.value
var _specifier3 = _ref8
_specifier3.isExportNamespaceSpecifier()
!noInterop && _specifier3.node.local.name === "default"
topNodes.push(buildExportsFrom(t.stringLiteral(_specifier3.node.exported.name), t.memberExpression(t.callExpression(this.addHelper("interopRequireDefault"), [ref]), _specifier3.node.local)))
topNodes.push(buildExportsFrom(t.stringLiteral(_specifier3.node.exported.name), t.memberExpression(ref, _specifier3.node.local)))
nonHoistedExportNames[_specifier3.node.exported.name] = true
var _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9)
_i11 >= _iterator9.length
_ref9 = _iterator9[_i11++]
_i11 = _iterator9.next()
_i11.done
_ref9 = _i11.value
var _specifier4 = _ref9
_specifier4.isExportSpecifier()
addTo(exports, _specifier4.node.local.name, _specifier4.node.exported)
nonHoistedExportNames[_specifier4.node.exported.name] = true
nodes.push(buildExportsAssignment(_specifier4.node.exported, _specifier4.node.local))
_path.replaceWithMultiple(nodes)
_path.isExportAllDeclaration()
var exportNode = buildExportAll({
                OBJECT: addRequire(_path.node.source.value, _path.node._blockHoist)
              })
_tmp_31.OBJECT = addRequire(_path.node.source.value, _path.node._blockHoist)
exportNode.loc = _path.node.loc
topNodes.push(exportNode)
_path.remove()
