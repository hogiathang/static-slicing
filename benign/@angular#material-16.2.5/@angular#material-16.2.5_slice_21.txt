function optimizeVariablesInOpList = function optimizeVariablesInOpList(ops, options) {
  const varDecls = /* @__PURE__ */ new Map();
  const varUsages = /* @__PURE__ */ new Map();
  const varRemoteUsages = /* @__PURE__ */ new Set();
  const opMap = /* @__PURE__ */ new Map();
  for (const op of ops) {
    if (op.kind === OpKind.Variable) {
      if (varDecls.has(op.xref) || varUsages.has(op.xref)) {
        throw new Error(`Should not see two declarations of the same variable: ${op.xref}`);
      }
      varDecls.set(op.xref, op);
      varUsages.set(op.xref, 0);
    }
    opMap.set(op, collectOpInfo(op));
    countVariableUsages(op, varUsages, varRemoteUsages);
  }
  let contextIsUsed = false;
  for (const op of ops.reversed()) {
    const opInfo = opMap.get(op);
    if (op.kind === OpKind.Variable && varUsages.get(op.xref) === 0) {
      if (contextIsUsed && opInfo.fences & Fence.ViewContextWrite || opInfo.fences & Fence.SideEffectful) {
        const stmtOp = createStatementOp(op.initializer.toStmt());
        opMap...
const varDecls = /* @__PURE__ */ new Map()
const varUsages = /* @__PURE__ */ new Map()
const varRemoteUsages = /* @__PURE__ */ new Set()
const opMap = /* @__PURE__ */ new Map()
!(_result_44 = _iterator_44.next()).done
op.kind === OpKind.Variable
varDecls.has(op.xref) || varUsages.has(op.xref)
<operator>.formatString("Should not see two declarations of the same variable: ", op.xref, "")
varDecls.set(op.xref, op)
varUsages.set(op.xref, 0)
opMap.set(op, collectOpInfo(op))
countVariableUsages(op, varUsages, varRemoteUsages)
let contextIsUsed = false
_iterator_45 = <operator>.iterator(ops.reversed())
const opInfo = opMap.get(op)
op.kind === OpKind.Variable && varUsages.get(op.xref) === 0
contextIsUsed && opInfo.fences & Fence.ViewContextWrite || opInfo.fences & Fence.SideEffectful
const stmtOp = createStatementOp(op.initializer.toStmt())
opMap.set(stmtOp, opInfo)
OpList.replace(op, stmtOp)
uncountVariableUsages(op, varUsages)
OpList.remove(op)
opMap.delete(op)
varDecls.delete(op.xref)
varUsages.delete(op.xref)
continue;
opInfo.fences & Fence.ViewContextRead
contextIsUsed = true
