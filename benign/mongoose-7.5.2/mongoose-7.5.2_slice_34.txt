function _virtualPopulate = function _virtualPopulate(model, docs, options, _virtualRes) {
  const map = [];
  const available = {};
  const virtual = _virtualRes.virtual;

  for (const doc of docs) {
    let modelNames = null;
    const data = {};

    // localField and foreignField
    let localField;
    const virtualPrefix = _virtualRes.nestedSchemaPath ?
      _virtualRes.nestedSchemaPath + '.' : '';
    if (typeof options.localField === 'string') {
      localField = options.localField;
    } else if (typeof virtual.options.localField === 'function') {
      localField = virtualPrefix + virtual.options.localField.call(doc, doc);
    } else if (Array.isArray(virtual.options.localField)) {
      localField = virtual.options.localField.map(field => virtualPrefix + field);
    } else {
      localField = virtualPrefix + virtual.options.localField;
    }
    data.count = virtual.options.count;

    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {
      options.skip = virtual.options.skip...
__ecma.Array.factory()
const available = {}
const virtual = _virtualRes.virtual
_iterator_0 = <operator>.iterator(docs)
let modelNames = null
const data = {}
const virtualPrefix = _virtualRes.nestedSchemaPath ?
      _virtualRes.nestedSchemaPath + '.' : ''
_virtualRes.nestedSchemaPath + '.'
typeof options.localField === 'string'
localField = options.localField
typeof virtual.options.localField === 'function'
localField = virtualPrefix + virtual.options.localField.call(doc, doc)
Array.isArray(virtual.options.localField)
localField = virtual.options.localField.map(field => virtualPrefix + field)
localField = virtualPrefix + virtual.options.localField
data.count = virtual.options.count
virtual.options.skip != null && !options.hasOwnProperty('skip')
options.skip = virtual.options.skip
virtual.options.limit != null && !options.hasOwnProperty('limit')
options.limit = virtual.options.limit
virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')
options.perDocumentLimit = virtual.options.perDocumentLimit
let foreignField = virtual.options.foreignField
!localField || !foreignField
typeof localField === 'function'
localField = localField.call(doc, doc)
typeof foreignField === 'function'
foreignField = foreignField.call(doc, doc)
data.isRefPath = false
let justOne = null
'justOne' in options && options.justOne !== void 0
justOne = options.justOne
virtual.options.refPath
modelNames =
        modelNamesFromRefPath(virtual.options.refPath, doc, options.path)
modelNamesFromRefPath(virtual.options.refPath, doc, options.path)
justOne = !!virtual.options.justOne
data.isRefPath = true
virtual.options.ref
typeof virtual.options.ref === 'function' && !virtual.options.ref[modelSymbol]
normalizedRef = virtual.options.ref.call(doc, doc)
normalizedRef = virtual.options.ref
justOne = !!virtual.options.justOne
Array.isArray(normalizedRef)
modelNames = normalizedRef
_tmp_6 = __ecma.Array.factory()
data.isVirtual = true
data.virtual = virtual
data.justOne = justOne
const baseMatch = get(data, 'virtual.options.match', null) ||
      get(data, 'virtual.options.options.match', null)
get(data, 'virtual.options.options.match', null)
let match = get(options, 'match', null) || baseMatch
let hasMatchFunction = typeof match === 'function'
match = match.call(doc, doc, data.virtual)
Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length
match = Object.assign({}, match)
i < localField.length
match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema)
hasMatchFunction = true
localField = localField[0]
foreignField = foreignField[0]
data.localField = localField
data.foreignField = foreignField
data.match = match
data.hasMatchFunction = hasMatchFunction
const ret = _getLocalFieldValues(doc, localField, model, options, virtual)
addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc)
