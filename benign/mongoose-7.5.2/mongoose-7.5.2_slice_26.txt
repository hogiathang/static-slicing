module.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks) {
  if (!(schema && schema.instanceOfSchema)) {
    throw new Error('You must pass a valid discriminator Schema');
  }

  mergeHooks = mergeHooks == null ? true : mergeHooks;

  if (model.schema.discriminatorMapping &&
      !model.schema.discriminatorMapping.isRoot) {
    throw new Error('Discriminator "' + name +
        '" can only be a discriminator of the root model');
  }

  if (applyPlugins) {
    const applyPluginsToDiscriminators = get(model.base,
      'options.applyPluginsToDiscriminators', false) || !mergeHooks;
    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply
    // global plugins to schemas embedded in the discriminator schema (gh-7370)
    model.base._applyPlugins(schema, {
      skipTopLevel: !applyPluginsToDiscriminators
    });
  } else if (!mergeHooks) {
    applyBuiltinPlugins(schema);
  }

  const key = model.schema.options.discriminato...
!(schema && schema.instanceOfSchema)
throw new Error('You must pass a valid discriminator Schema');
mergeHooks = mergeHooks == null ? true : mergeHooks
model.schema.discriminatorMapping &&
      !model.schema.discriminatorMapping.isRoot
!model.schema.discriminatorMapping.isRoot
throw new Error('Discriminator "' + name +
        '" can only be a discriminator of the root model');
"" can only be a discriminator of the root model"
function merge = function merge(schema, baseSchema) {
    // Retain original schema before merging base schema
    schema._baseSchema = baseSchema;
    if (baseSchema.paths._id &&
        baseSchema.paths._id.options &&
        !baseSchema.paths._id.options.auto) {
      schema.remove('_id');
    }

    // Find conflicting paths: if something is a path in the base schema
    // and a nested path in the child schema, overwrite the base schema path.
    // See gh-6076
    const baseSchemaPaths = Object.keys(baseSchema.paths);
    const conflictingPaths = [];

    for (const path of baseSchemaPaths) {
      if (schema.nested[path]) {
        conflictingPaths.push(path);
        continue;
      }

      if (path.indexOf('.') === -1) {
        continue;
      }
      const sp = path.split('.').slice(0, -1);
      let cur = '';
      for (const piece of sp) {
        cur += (cur.length ? '.' : '') + piece;
        if (schema.paths[cur] instanceof Mixed ||
            schema.singleNestedPaths[cur] instance...
