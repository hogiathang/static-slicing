module.exports = function assignVals(o) {
  // Options that aren't explicitly listed in `populateOptions`
  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));
  // `o.options` contains options explicitly listed in `populateOptions`, like
  // `match` and `limit`.
  const populateOptions = Object.assign({}, o.options, userOptions, {
    justOne: o.justOne
  });
  populateOptions.$nullIfNotFound = o.isVirtual;
  const populatedModel = o.populatedModel;

  const originalIds = [].concat(o.rawIds);

  // replace the original ids in our intermediate _ids structure
  // with the documents found by query
  o.allIds = [].concat(o.allIds);
  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);

  // now update the original documents being populated using the
  // result structure that contains real documents.
  const docs = o.docs;
  const rawIds = o.rawIds;
  const options = o.options;
  const count = o.count &&...
const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'))
const populateOptions = Object.assign({}, o.options, userOptions, {
    justOne: o.justOne
  })
_tmp_7.justOne = o.justOne
populateOptions.$nullIfNotFound = o.isVirtual
const populatedModel = o.populatedModel
const originalIds = [].concat(o.rawIds)
o.allIds = [].concat(o.allIds)
assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions)
const docs = o.docs
const rawIds = o.rawIds
const options = o.options
const count = o.count && o.isVirtual
function setValue = function setValue(val) {
    if (count) {
      return val;
    }
    if (val instanceof SkipPopulateValue) {
      return val.val;
    }
    if (val === void 0) {
      return val;
    }

    const _allIds = o.allIds[i];

    if (o.path.endsWith('.$*')) {
      // Skip maps re: gh-12494
      return valueFilter(val, options, populateOptions, _allIds);
    }

    if (o.justOne === true && Array.isArray(val)) {
      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right
      // model before assigning.
      const ret = [];
      for (const doc of val) {
        const _docPopulatedModel = leanPopulateMap.get(doc);
        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {
          ret.push(doc);
        }
      }
      // Since we don't want to have to create a new mongoosearray, make sure to
      // modify the array in place
      while (val.length > ret.length) {
        Array.prototype.pop.apply(val, []);...
i < docs.length
const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path
const existingVal = mpath.get(_path, docs[i], lookupLocalFields)
existingVal == null && !getVirtual(o.originalModel.schema, _path)
continue;
valueToSet = numDocs(rawIds[i])
Array.isArray(o.match)
valueToSet = Array.isArray(rawIds[i]) ?
        rawIds[i].filter(sift(o.match[i])) :
        [rawIds[i]].filter(sift(o.match[i]))[0]
rawIds[i].filter(sift(o.match[i]))
[rawIds[i]].filter(sift(o.match[i]))[0]
valueToSet = rawIds[i]
const originalSchema = o.originalModel.schema
const isDoc = get(docs[i], '$__', null) != null
let isMap = isDoc ?
      existingVal instanceof Map :
      utils.isPOJO(existingVal)
existingVal instanceof Map
utils.isPOJO(existingVal)
isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap')
!o.isVirtual && isMap
const _keys = existingVal instanceof Map ?
        Array.from(existingVal.keys()) :
        Object.keys(existingVal)
Array.from(existingVal.keys())
Object.keys(existingVal)
valueToSet = valueToSet.reduce((cur, v, i) => {
        cur.set(_keys[i], v);
        return cur;
      }, new Map())
_tmp_15 = .alloc
isDoc && Array.isArray(valueToSet)
_iterator_1 = <operator>.iterator(valueToSet)
val != null && val.$__ != null
val.$__.parent = docs[i]
isDoc && valueToSet != null && valueToSet.$__ != null
valueToSet.$__.parent = docs[i]
o.isVirtual && isDoc
docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions)
Array.isArray(valueToSet)
valueToSet = valueToSet.map(v => v == null ? void 0 : v)
mpath.set(_path, valueToSet, docs[i], void 0, setValue, false)
continue;
const parts = _path.split('.')
let cur = docs[i]
const curPath = parts[0]
j < parts.length - 1
Array.isArray(cur) && !utils.isArrayIndex(parts[j])
break;
parts[j] === '$*'
break;
cur[parts[j]] == null
const schematype = originalSchema._getSchema(curPath)
valueToSet == null && schematype != null && schematype.$isMongooseArray
break;
cur[parts[j]] = {}
cur = cur[parts[j]]
typeof cur !== 'object'
break;
docs[i].$__
o.allOptions.options[populateModelSymbol] = o.allOptions.model
docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options)
valueToSet != null && valueToSet.$__ != null
valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] }
valueToSet instanceof Map && !valueToSet.$isMongooseMap
valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType)
mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false)
docs[i].$__
markArraySubdocsPopulated(docs[i], [o.allOptions.options])
