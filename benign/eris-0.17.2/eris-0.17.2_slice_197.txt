const actualCall = (cb) => {
                const headers = {
                    "User-Agent": this.userAgent,
                    "Accept-Encoding": "gzip,deflate"
                };
                let data;
                let finalURL = url;

                try {
                    if(auth) {
                        headers.Authorization = this._client._token;
                    }
                    if(body && body.reason) { // Audit log reason sniping
                        let unencodedReason = body.reason;
                        if(this.options.decodeReasons) {
                            try {
                                if(unencodedReason.includes("%") && !unencodedReason.includes(" ")) {
                                    unencodedReason = decodeURIComponent(unencodedReason);
                                }
                            } catch(err) {
                                this._client.emit("error", err);
                            }
                     ...
const headers = {
                    "User-Agent": this.userAgent,
                    "Accept-Encoding": "gzip,deflate"
                }
_tmp_12.User-Agent = this.userAgent
_tmp_12.Accept-Encoding = "gzip,deflate"
let finalURL = url
headers.Authorization = this._client._token
body && body.reason
let unencodedReason = body.reason
this.options.decodeReasons
unencodedReason.includes("%") && !unencodedReason.includes(" ")
unencodedReason = decodeURIComponent(unencodedReason)
this._client.emit("error", err)
headers["X-Audit-Log-Reason"] = encodeURIComponent(unencodedReason)
(method !== "PUT" || !url.includes("/bans")) && (method !== "POST" || !url.includes("/prune"))
delete body.reason
body.reason = unencodedReason
Array.isArray(file)
data = new MultipartData()
headers["Content-Type"] = "multipart/form-data; boundary=" + data.boundary
file.forEach(function(f) {
                                if(!f.file) {
                                    return;
                                }
                                data.attach(f.name, f.file, f.name);
                            })
data.attach("payload_json", body)
data = data.finish()
file.file
data = new MultipartData()
headers["Content-Type"] = "multipart/form-data; boundary=" + data.boundary
data.attach("file", file.file, file.name)
method === "POST" && url.endsWith("/stickers")
_iterator_0 = <operator>.iterator(body)
data.attach(key, body[key])
data.attach("payload_json", body)
data = data.finish()
throw new Error("Invalid file object");
method === "GET" || method === "DELETE"
let qs = ""
Object.keys(body).forEach(function(key) {
                                if(body[key] != undefined) {
                                    if(Array.isArray(body[key])) {
                                        body[key].forEach(function(val) {
                                            qs += `&${encodeURIComponent(key)}=${encodeURIComponent(val)}`;
                                        });
                                    } else {
                                        qs += `&${encodeURIComponent(key)}=${encodeURIComponent(body[key])}`;
                                    }
                                }
                            })
finalURL += "?" + qs.substring(1)
data = JSON.stringify(body, (k, v) => typeof v === "bigint" ? v.toString() : v)
headers["Content-Type"] = "application/json"
req = HTTPS.request({
                        method: method,
                        host: this.options.domain,
                        path: this.options.baseURL + finalURL,
                        headers: headers,
                        agent: this.options.agent
                    })
_tmp_19.method = method
_tmp_19.host = this.options.domain
_tmp_19.path = this.options.baseURL + finalURL
_tmp_19.headers = headers
_tmp_19.agent = this.options.agent
req.once("abort", () => {
                    cb();
                    reqError = reqError || new Error(`Request aborted by client on ${method} ${url}`);
                    reqError.req = req;
                    reject(reqError);
                }).once("error", (err) => {
                    reqError = err;
                    req.abort();
                })
<lambda>8
let latency = Date.now()
req.once("response", (resp) => {
                    latency = Date.now() - latency;
                    if(!this.options.disableLatencyCompensation) {
                        this.latencyRef.raw.push(latency);
                        this.latencyRef.latency = this.latencyRef.latency - ~~(this.latencyRef.raw.shift() / 10) + ~~(latency / 10);
                    }

                    if(this._client.listeners("rawREST").length) {
                        /**
                         * Fired when the Client's RequestHandler receives a response
                         * @event Client#rawREST
                         * @prop {Object} [request] The data for the request.
                         * @prop {Boolean} request.auth True if the request required an authorization token
                         * @prop {Object} [request.body] The request payload
                         * @prop {Object} [request.file] The file object sent in the request
                         * @prop {Buffer} re...
req.setTimeout(this.options.requestTimeout, () => {
                    reqError = new Error(`Request timed out (>${this.options.requestTimeout}ms) on ${method} ${url}`);
                    req.abort();
                })
