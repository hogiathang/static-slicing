this.udpSocket.on("message", (msg) => {
            if(msg[1] !== 0x78) { // unknown payload type, ignore
                return;
            }

            const nonce = Buffer.alloc(24);
            msg.copy(nonce, 0, 0, 12);
            let data;
            if(Sodium) {
                data = Buffer.alloc(msg.length - 12 - Sodium.crypto_secretbox_MACBYTES);
                Sodium.crypto_secretbox_open_easy(data, msg.subarray(12), nonce, this.secret);
            } else {
                if(!(data = NaCl.secretbox.open(msg.subarray(12), nonce, this.secret))) {
                    /**
                    * Fired to warn of something weird but non-breaking happening
                    * @event VoiceConnection#warn
                    * @prop {String} message The warning message
                    */
                    this.emit("warn", "Failed to decrypt received packet");
                    return;
                }
            }
            const hasExtension = !!(msg[0] & 0b...
msg[1] !== 0x78
const nonce = Buffer.alloc(24)
msg.copy(nonce, 0, 0, 12)
data = Buffer.alloc(msg.length - 12 - Sodium.crypto_secretbox_MACBYTES)
Sodium.crypto_secretbox_open_easy(data, msg.subarray(12), nonce, this.secret)
!(data = NaCl.secretbox.open(msg.subarray(12), nonce, this.secret))
const hasExtension = !!(msg[0] & 0b10000)
const cc = msg[0] & 0b1111
cc > 0
data = data.subarray(cc * 4)
const l = data[2] << 8 | data[3]
data = data.subarray(4 + l * 4)
this.receiveStreamOpus
this.receiveStreamOpus.emit("data", data, this.ssrcUserMap[nonce.readUIntBE(8, 4)], nonce.readUIntBE(4, 4), nonce.readUIntBE(2, 2))
