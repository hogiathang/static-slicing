connect(data) {
        this.connecting = true;
        if(this.ws && this.ws.readyState !== WebSocket.CLOSED) {
            this.disconnect(undefined, true);
            setTimeout(() => {
                if(!this.connecting && !this.ready) {
                    this.connect(data);
                }
            }, 500).unref();
            return;
        }
        clearTimeout(this.connectionTimeout);
        this.connectionTimeout = setTimeout(() => {
            if(this.connecting) {
                this.disconnect(new Error("Voice connection timeout"));
            }
            this.connectionTimeout = null;
        }, this.shard.client ? this.shard.client.options.connectionTimeout : 30000).unref();
        if(!data.endpoint) {
            return; // Endpoint null, wait next update.
        }
        if(!data.token || !data.session_id || !data.user_id) {
            this.disconnect(new Error("Malformed voice server update: " + JSON.stringify(data)));
            return;
      ...
this.connecting = true
this.ws && this.ws.readyState !== WebSocket.CLOSED
clearTimeout(this.connectionTimeout)
this.connectionTimeout = setTimeout(() => {
            if(this.connecting) {
                this.disconnect(new Error("Voice connection timeout"));
            }
            this.connectionTimeout = null;
        }, this.shard.client ? this.shard.client.options.connectionTimeout : 30000).unref()
this.shard.client ? this.shard.client.options.connectionTimeout : 30000
!data.endpoint
!data.token || !data.session_id || !data.user_id
this.channelID = data.channel_id
<operator>.formatString("wss://", data.endpoint, "")
this.endpoint.port === "80"
this.endpoint.port = ""
(_tmp_22 = this.endpoint.searchParams).set
this.ws = new WebSocket(this.endpoint.href)
this.emit("debug", "Connection: " + JSON.stringify(data))
