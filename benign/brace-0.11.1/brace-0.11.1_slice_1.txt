this.getLineTokens = function(line, startState) {
        if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
            }
        } else
            var stack = [];

        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;

        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;

        var token = {type: null, value: ""};

        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
         ...
startState && typeof startState != "string"
var stack = startState.slice(0)
startState = stack[0]
startState === "#tmp"
stack.shift()
startState = stack.shift()
__ecma.Array.factory()
var currentState = startState || "start"
var state = this.states[currentState]
!state
currentState = "start"
state = this.states[currentState]
var mapping = this.matchMappings[currentState]
var re = this.regExps[currentState]
re.lastIndex = 0
__ecma.Array.factory()
var lastIndex = 0
var matchAttempts = 0
var token = {type: null, value: ""}
match = re.exec(line)
var type = mapping.defaultToken
var rule = null
var value = match[0]
var index = re.lastIndex
index - value.length > lastIndex
var skipped = line.substring(lastIndex, index - value.length)
token.type == type
token.value += skipped
token.type
tokens.push(token)
token = {type: type, value: skipped}
i < match.length-2
match[i + 1] === undefined
continue;
rule = state[mapping[i]]
rule.onMatch
type = rule.onMatch(value, currentState, stack, line)
type = rule.token
rule.next
typeof rule.next == "string"
currentState = rule.next
currentState = rule.next(currentState, stack)
state = this.states[currentState]
!state
this.reportError("state doesn't exist", currentState)
currentState = "start"
state = this.states[currentState]
mapping = this.matchMappings[currentState]
lastIndex = index
re = this.regExps[currentState]
re.lastIndex = index
rule.consumeLineEnd
lastIndex = index
break;
typeof type === "string"
(!rule || rule.merge !== false) && token.type === type
token.value += value
token.type
tokens.push(token)
token = {type: type, value: value}
token.type
tokens.push(token)
token = {type: null, value: ""}
i < type.length
tokens.push(type[i])
lastIndex == line.length
lastIndex = index
matchAttempts++ > MAX_TOKEN_COUNT
