_tmp_5.send = <lambda>4
var xhr = options.xhr()
var id = ++xhrId
xhr.open( options.type, options.url, options.async, options.username, options.password )
options.xhrFields
_iterator_1 = <operator>.iterator(options.xhrFields)
xhr[ i ] = options.xhrFields[ i ]
options.mimeType && xhr.overrideMimeType
xhr.overrideMimeType( options.mimeType )
!options.crossDomain && !headers["X-Requested-With"]
headers["X-Requested-With"] = "XMLHttpRequest"
_iterator_2 = <operator>.iterator(headers)
xhr.setRequestHeader( i, headers[ i ] )
callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				}
xhr.onload = callback()
xhr.onerror = callback("error")
callback = xhrCallbacks[ id ] = callback("abort")
xhr.send( options.hasContent && options.data || null )
