exports.access = ({request:client}) => async ({provider, input, input:{query, body, session}}) => {
  query = Object.keys(query).length ? query : body
  if (!query.code) {
    var output = Object.keys(query).length
      ? query : {error: 'Grant: OAuth2 missing code parameter'}
    return {provider, input, output}
  }
  else if (session.state && (query.state !== session.state)) {
    var output = {error: 'Grant: OAuth2 state mismatch'}
    return {provider, input, output}
  }
  var options = {
    method: 'POST',
    url: provider.access_url,
    form: {
      grant_type: 'authorization_code',
      code: query.code,
      client_id: provider.key,
      client_secret: provider.secret,
      redirect_uri: provider.redirect_uri
    }
  }
  if (provider.pkce) {
    options.form.code_verifier = session.code_verifier
  }
  if (provider.basecamp) {
    options.form.type = 'web_server'
  }
  if (provider.concur) {
    delete options.form
    options.qs = {
      code: query.code,
      cli...
query = Object.keys(query).length ? query : body
!query.code
session.state && (query.state !== session.state)
var options = {
    method: 'POST',
    url: provider.access_url,
    form: {
      grant_type: 'authorization_code',
      code: query.code,
      client_id: provider.key,
      client_secret: provider.secret,
      redirect_uri: provider.redirect_uri
    }
  }
_tmp_8.method = "POST"
_tmp_8.url = provider.access_url
_tmp_8.form = {
      grant_type: 'authorization_code',
      code: query.code,
      client_id: provider.key,
      client_secret: provider.secret,
      redirect_uri: provider.redirect_uri
    }
_tmp_9.grant_type = "authorization_code"
_tmp_9.code = query.code
_tmp_9.client_id = provider.key
_tmp_9.client_secret = provider.secret
_tmp_9.redirect_uri = provider.redirect_uri
provider.pkce
options.form.code_verifier = session.code_verifier
provider.basecamp
options.form.type = 'web_server'
provider.concur
delete options.form
options.qs = {
      code: query.code,
      client_id: provider.key,
      client_secret: provider.secret
    }
_tmp_10.code = query.code
_tmp_10.client_id = provider.key
_tmp_10.client_secret = provider.secret
/ebay|fitbit|homeaway|hootsuite|notion|reddit|trustpilot/.test(provider.name)
    || provider.token_endpoint_auth_method === 'client_secret_basic'
provider.token_endpoint_auth_method === 'client_secret_basic'
delete options.form.client_id
delete options.form.client_secret
options.auth = {user: provider.key, pass: provider.secret}
/twitter/.test(provider.name)
options.form.client_id = provider.key
delete options.form.client_secret
options.auth = {user: provider.key, pass: provider.secret}
provider.token_endpoint_auth_method === 'private_key_jwt'
var jwt = ({kid, x5t, secret}) => ({
      header: {
        typ: 'JWT',
        alg: provider.token_endpoint_auth_signing_alg || 'RS256',
        kid,
        x5t
      },
      payload: {
        iss: provider.key,
        sub: provider.key,
        aud: provider.access_url,
        jti: crypto.randomBytes(20).toString('hex'),
        exp: Math.round(Date.now() / 1000) + 300,
        iat: Math.round(Date.now() / 1000) - 120,
        nbf: Math.round(Date.now() / 1000) - 120
      },
      secret
    })
var assertion = (() => {
      var oidc = require('../oidc')
      var {public_key, private_key} = provider
      return oidc.sign(jwt({
        kid: private_key.kty ? oidc.kid(private_key) : undefined,
        x5t: public_key ? public_key.kty ? public_key.x5t : oidc.x5t(public_key) : undefined,
        secret: private_key.kty ? oidc.pem(private_key) : private_key,
      }))
    })()
options.form.client_assertion_type = 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'
options.form.client_assertion = assertion
delete options.form.client_id
delete options.form.client_secret
provider.instagram && /^\d+$/.test(provider.key)
options.form.app_id = options.form.client_id
delete options.form.client_id
options.form.app_secret = options.form.client_secret
delete options.form.client_secret
provider.notion
options.json = options.form
delete options.form
provider.tiktok
options.form.client_key = options.form.client_id
delete options.form.client_id
provider.qq
options.method = 'GET'
options.qs = options.form
delete options.form
provider.untappd
options.method = 'GET'
options.qs = options.form
delete options.qs.grant_type
options.qs.response_type = 'code'
delete options.form
provider.wechat
options.method = 'GET'
options.qs = options.form
delete options.form
options.qs.appid = options.qs.client_id
options.qs.secret = options.qs.client_secret
delete options.qs.client_id
delete options.qs.client_secret
provider.smartsheet
delete options.form.client_secret
var hash = crypto.createHash('sha256')
hash.update(provider.secret + '|' + query.code)
options.form.hash = hash.digest('hex')
provider.surveymonkey
options.qs = {api_key: provider.custom_params.api_key}
provider.visualstudio
options.form = {
      client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
      client_assertion: provider.secret,
      grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
      assertion: query.code,
      redirect_uri: provider.redirect_uri
    }
_tmp_23.client_assertion_type = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
_tmp_23.client_assertion = provider.secret
_tmp_23.grant_type = "urn:ietf:params:oauth:grant-type:jwt-bearer"
_tmp_23.assertion = query.code
_tmp_23.redirect_uri = provider.redirect_uri
provider.withings && /wbsapi/.test(provider.access_url)
options.form.action = 'requesttoken'
provider.subdomain
options.url = options.url.replace('[subdomain]', provider.subdomain)
