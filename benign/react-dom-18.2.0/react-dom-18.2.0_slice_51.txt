function retryTask = function retryTask(request, task) {
  var segment = task.blockedSegment;

  if (segment.status !== PENDING) {
    // We completed this by other means before we had a chance to retry it.
    return;
  } // We restore the context to what it was when we suspended.
  // We don't restore it after we leave because it's likely that we'll end up
  // needing a very similar context soon again.


  switchContext(task.context);
  var prevTaskInDEV = null;

  {
    prevTaskInDEV = currentTaskInDEV;
    currentTaskInDEV = task;
  }

  try {
    // We call the destructive form that mutates this task. That way if something
    // suspends again, we can reuse the same task instead of spawning a new one.
    renderNodeDestructive(request, task, task.node);
    pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
    task.abortSet.delete(task);
    segment.status = COMPLETED;
    finishedTask(request, task.blockedBoundary, segment);
  } catch (x) {
 ...
var segment = task.blockedSegment
segment.status !== PENDING
switchContext(task.context)
var prevTaskInDEV = null
prevTaskInDEV = currentTaskInDEV
currentTaskInDEV = task
renderNodeDestructive(request, task, task.node)
pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded)
(_tmp_130 = task.abortSet).delete
segment.status = COMPLETED
finishedTask(request, task.blockedBoundary, segment)
resetHooksState()
typeof x === 'object' && x !== null && typeof x.then === 'function'
(_tmp_131 = task.abortSet).delete
