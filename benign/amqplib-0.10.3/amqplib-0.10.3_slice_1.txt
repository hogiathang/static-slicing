function encodeFieldValue = function encodeFieldValue(buffer, value, offset) {
    var start = offset;
    var type = typeof value, val = value;
    // A trapdoor for specifying a type, e.g., timestamp
    if (value && type === 'object' && value.hasOwnProperty('!')) {
        val = value.value;
        type = value['!'];
    }

    // If it's a JS number, we'll have to guess what type to encode it
    // as.
    if (type == 'number') {
        // Making assumptions about the kind of number (floating point
        // v integer, signed, unsigned, size) desired is dangerous in
        // general; however, in practice RabbitMQ uses only
        // longstrings and unsigned integers in its arguments, and
        // other clients generally conflate number types anyway. So
        // the only distinction we care about is floating point vs
        // integers, preferring integers since those can be promoted
        // if necessary. If floating point is required, we may as well
        // use double precision.
        i...
var start = offset
var type = typeof value
value && type === 'object' && value.hasOwnProperty('!')
val = value.value
type = value['!']
type == 'number'
isFloatingPoint(val)
type = 'double'
val < 128 && val >= -128
type = 'byte'
val >= -0x8000 && val < 0x8000
type = 'short'
val >= -0x80000000 && val < 0x80000000
type = 'int'
type = 'long'
function tag = function tag(t) { buffer.write(t, offset); offset++; }
"string"
var len = Buffer.byteLength(val, 'utf8')
tag('S')
buffer.writeUInt32BE(len, offset)
buffer.write(val, offset, 'utf8')
