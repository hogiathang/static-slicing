_tmp_61.init = init
!args
args = process.argv
_tmp_72 = process.env
CYPRESS_INTERNAL_ENV = _tmp_72.CYPRESS_INTERNAL_ENV
CYPRESS_DOWNLOAD_USE_CA = _tmp_72.CYPRESS_DOWNLOAD_USE_CA
process.env
process.env.CYPRESS_DOWNLOAD_USE_CA
<operator>.formatString("
        ", logSymbols.warning, " Warning: It looks like you're setting CYPRESS_DOWNLOAD_USE_CA=", CYPRESS_DOWNLOAD_USE_CA, "

        The environment variable "CYPRESS_DOWNLOAD_USE_CA" is no longer required to be set.
        
        You can safely unset this environment variable.
      ")
logSymbols.warning
logger.log()
logger.warn(stripIndent(msg))
logger.log()
!util.isValidCypressInternalEnvValue(CYPRESS_INTERNAL_ENV)
util.isNonProductionCypressInternalEnvValue(CYPRESS_INTERNAL_ENV)
debug('non-production CYPRESS_INTERNAL_ENV value', CYPRESS_INTERNAL_ENV)
<operator>.formatString("
        ", logSymbols.warning, " Warning: It looks like you're passing CYPRESS_INTERNAL_ENV=", CYPRESS_INTERNAL_ENV, "

        The environment variable "CYPRESS_INTERNAL_ENV" is reserved and should only be used internally.

        Unset the "CYPRESS_INTERNAL_ENV" environment variable and run Cypress again.
      ")
logSymbols.warning
logger.log()
logger.warn(stripIndent(msg))
logger.log()
const program = createProgram()
program.command('help').description('Shows CLI help and exits').action(() => {
      program.help();
    })
const handleVersion = cmd => {
      return cmd.option('--component <package|binary|electron|node>', 'component to report version for').action((opts, ...other) => {
        showVersions(util.parseOpts(opts));
      });
    }
handleVersion(program.storeOptionsAsProperties().option('-v, --version', text('version')).command('version').description(text('version')))
maybeAddInspectFlags(addCypressOpenCommand(program)).action(opts => {
      debug('opening Cypress');
      require('./exec/open').start(util.parseOpts(opts)).then(util.exit).catch(util.logErrorExit1);
    })
maybeAddInspectFlags(addCypressRunCommand(program)).action((...fnArgs) => {
      debug('running Cypress with args %o', fnArgs);
      require('./exec/run').start(parseVariableOpts(fnArgs, args)).then(util.exit).catch(util.logErrorExit1);
    })
program.command('open-ct').usage('[options]').description('Opens Cypress component testing interactive mode. Deprecated: use "open --component"').option('-b, --browser <browser-path>', text('browser')).option('-c, --config <config>', text('config')).option('-C, --config-file <config-file>', text('configFile')).option('-d, --detached [bool]', text('detached'), coerceFalse).option('-e, --env <env>', text('env')).option('--global', text('global')).option('-p, --port <port>', text('port')).option('-P, --project <project-path>', text('project')).option('--dev', text('dev'), coerceFalse).action(opts => {
      debug('opening Cypress');
      const msg = `
      ${logSymbols.warning} Warning: open-ct is deprecated and will be removed in a future release.

      Use \`cypress open --component\` instead.
      `;
      logger.warn();
      logger.warn(stripIndent(msg));
      logger.warn();
      require('./exec/open').start({
        ...util.parseOpts(opts),
        testingType: 'component'...
(_tmp_103 = program.command('run-ct').usage('[options]').description('Runs all Cypress component testing suites. Deprecated: use "run --component"').option('-b, --browser <browser-name-or-path>', text('browser')).option('--ci-build-id <id>', text('ciBuildId')).option('-c, --config <config>', text('config')).option('-C, --config-file <config-file>', text('configFile')).option('-e, --env <env>', text('env')).option('--group <name>', text('group')).option('-k, --key <record-key>', text('key')).option('--headed', text('headed')).option('--headless', text('headless')).option('--no-exit', text('exit')).option('--parallel', text('parallel')).option('-p, --port <port>', text('port')).option('-P, --project <project-path>', text('project')).option('-q, --quiet', text('quiet')).option('--record [bool]', text('record'), coerceFalse).option('-r, --reporter <reporter>', text('reporter')).option('-o, --reporter-options <reporter-options>', text('reporterOptions')).option('-s, --spec <spec>', text('spec')).opt...).action
program.command('install').usage('[options]').description('Installs the Cypress executable matching this package\'s version').option('-f, --force', text('forceInstall')).action(opts => {
      require('./tasks/install').start(util.parseOpts(opts)).catch(util.logErrorExit1);
    })
program.command('verify').usage('[options]').description('Verifies that Cypress is installed correctly and executable').option('--dev', text('dev'), coerceFalse).action(opts => {
      const defaultOpts = {
        force: true,
        welcomeMessage: false
      };
      const parsedOpts = util.parseOpts(opts);
      const options = _.extend(parsedOpts, defaultOpts);
      require('./tasks/verify').start(options).catch(util.logErrorExit1);
    })
program.command('cache').usage('[command]').description('Manages the Cypress binary cache').option('list', text('cacheList')).option('path', text('cachePath')).option('clear', text('cacheClear')).option('prune', text('cachePrune')).option('--size', text('cacheSize')).action(function (opts, args) {
      if (!args || !args.length) {
        this.outputHelp();
        util.exit(1);
      }
      const [command] = args;
      if (!_.includes(['list', 'path', 'clear', 'prune'], command)) {
        unknownOption.call(this, `cache ${command}`, 'command');
      }
      if (command === 'list') {
        debug('cache command %o', {
          command,
          size: opts.size
        });
        return cache.list(opts.size).catch({
          code: 'ENOENT'
        }, () => {
          logger.always('No cached binary versions were found.');
          process.exit(0);
        }).catch(e => {
          debug('cache list command failed with "%s"', e.message);
          util.logErrorExit1(e);
  ...
program.command('info').usage('[command]').description('Prints Cypress and system information').option('--dev', text('dev'), coerceFalse).action(opts => {
      require('./exec/info').start(opts).then(util.exit).catch(util.logErrorExit1);
    })
debug('cli starts with arguments %j', args)
util.printNodeOptions()
args.length <= 2
debug('printing help')
program.help()
const firstCommand = args[2]
!_.includes(knownCommands, firstCommand)
debug('unknown command %s', firstCommand)
logger.error('Unknown command', `"${firstCommand}"`)
program.outputHelp()
util.exit(1)
