function _evaluate = function _evaluate(path, state) {
  if (!state.confident) return;
  if (path.isSequenceExpression()) {
    const exprs = path.get("expressions");
    return evaluateCached(exprs[exprs.length - 1], state);
  }
  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
    return path.node.value;
  }
  if (path.isNullLiteral()) {
    return null;
  }
  if (path.isTemplateLiteral()) {
    return evaluateQuasis(path, path.node.quasis, state);
  }
  if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
    const object = path.get("tag.object");
    const {
      node: {
        name
      }
    } = object;
    const property = path.get("tag.property");
    if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
      return evaluateQuasis(path, path.node.quasi.quasis, state, true);
    }
  }
  if (path.isConditionalExpression()) {
    const testResult...
!state.confident
path.isSequenceExpression()
path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()
path.isNullLiteral()
path.isTemplateLiteral()
path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()
const object = path.get("tag.object")
_tmp_4 = object
_tmp_5.name = name
const property = path.get("tag.property")
object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw"
path.isConditionalExpression()
path.isExpressionWrapper()
path.isMemberExpression() && !path.parentPath.isCallExpression({
    callee: path.node
  })
_tmp_8.callee = path.node
const property = path.get("property")
const object = path.get("object")
object.isLiteral()
const value = object.node.value
const type = typeof value
let key = null
path.node.computed
key = evaluateCached(property, state)
!state.confident
property.isIdentifier()
key = property.node.name
(type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")
path.isReferencedIdentifier()
path.isUnaryExpression({
    prefix: true
  })
_tmp_10.prefix = true
path.node.operator === "void"
const argument = path.get("argument")
path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())
const arg = evaluateCached(argument, state)
!state.confident
path.node.operator
path.isArrayExpression()
path.isObjectExpression()
path.isLogicalExpression()
const wasConfident = state.confident
const left = evaluateCached(path.get("left"), state)
const leftConfident = state.confident
state.confident = wasConfident
const right = evaluateCached(path.get("right"), state)
const rightConfident = state.confident
path.node.operator
path.isBinaryExpression()
const left = evaluateCached(path.get("left"), state)
!state.confident
const right = evaluateCached(path.get("right"), state)
!state.confident
path.node.operator
path.isCallExpression()
const callee = path.get("callee")
callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)
func = global[callee.node.name]
callee.isMemberExpression()
const object = callee.get("object")
const property = callee.get("property")
object.isIdentifier() && property.isIdentifier() && isValidCallee(object.node.name) && !isInvalidMethod(property.node.name)
context = global[object.node.name]
func = context[property.node.name]
object.isLiteral() && property.isIdentifier()
const type = typeof object.node.value
type === "string" || type === "number"
context = object.node.value
func = context[property.node.name]
const args = path.get("arguments").map(arg => evaluateCached(arg, state))
