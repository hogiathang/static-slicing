(_tmp_30 = httpsPromise.then(function(startupHttps) {
    if (startupHttps) {
        server = https.createServer(startupHttps,function(req,res) {app(req,res);});

        if (settings.httpsRefreshInterval) {
            var httpsRefreshInterval = parseFloat(settings.httpsRefreshInterval)||12;
            if (httpsRefreshInterval > 596) {
                // Max value based on (2^31-1)ms - the max that setInterval can accept
                httpsRefreshInterval = 596;
            }
            // Check whether setSecureContext is available (Node.js 11+)
            if (server.setSecureContext) {
                // Check whether `http` is a callable function
                if (typeof settings.https === "function") {
                    delayedLogItems.push({type:"info", id:"server.https.refresh-interval", params:{interval:httpsRefreshInterval}});
                    setInterval(function () {
                        try {
                            // Get the result of the function, because cre...).catch
server = https.createServer(startupHttps,function(req,res) {app(req,res);})
settings.httpsRefreshInterval
var httpsRefreshInterval = parseFloat(settings.httpsRefreshInterval)||12
httpsRefreshInterval > 596
httpsRefreshInterval = 596
server.setSecureContext
typeof settings.https === "function"
delayedLogItems.push({type:"info", id:"server.https.refresh-interval", params:{interval:httpsRefreshInterval}})
setInterval(function () {
                        try {
                            // Get the result of the function, because createServer doesn't accept functions as input
                            Promise.resolve(settings.https()).then(function(refreshedHttps) {
                                if (refreshedHttps) {
                                    // The key/cert needs to be updated in the NodeJs http(s) server, when no key/cert is yet available or when the key/cert has changed.
                                    // Note that the refreshed key/cert can be supplied as a string or a buffer.
                                    var updateKey = (server.key == undefined || (Buffer.isBuffer(server.key) && !server.key.equals(refreshedHttps.key)) || (typeof server.key == "string" && server.key != refreshedHttps.key));
                                    var updateCert = (server.cert == undefined || (Buffer.isBuffer(server.cert) && !server.cert.equals(refreshedHttps.cert)) || (typeof...
httpsRefreshInterval*60*60*1000
delayedLogItems.push({type:"warn", id:"server.https.function-required"})
delayedLogItems.push({type:"warn", id:"server.https.nodejs-version"})
server = http.createServer(function(req,res) {app(req,res);})
server.setMaxListeners(0)
function formatRoot = function formatRoot(root) {
        if (root[0] != "/") {
            root = "/" + root;
        }
        if (root.slice(-1) != "/") {
            root = root + "/";
        }
        return root;
    }
settings.httpRoot === false
settings.httpAdminRoot = false
settings.httpNodeRoot = false
settings.disableEditor = settings.disableEditor||false
settings.httpAdminRoot !== false
settings.httpAdminRoot = formatRoot(settings.httpAdminRoot || settings.httpRoot || "/")
settings.httpAdminAuth = settings.httpAdminAuth || settings.httpAuth
settings.disableEditor = true
settings.httpNodeRoot !== false
settings.httpNodeRoot = formatRoot(settings.httpNodeRoot || settings.httpRoot || "/")
settings.httpNodeAuth = settings.httpNodeAuth || settings.httpAuth
settings.httpStatic
settings.httpStaticRoot = formatRoot(settings.httpStaticRoot || "/")
const statics = Array.isArray(settings.httpStatic) ? settings.httpStatic : [settings.httpStatic]
__ecma.Array.factory()
si < statics.length
let sp = statics[si]
typeof sp === "string"
sp = { path: sp, root: "" }
sanitised.push(sp)
typeof sp === "object" && sp.path
sanitised.push(sp)
continue;
sp.subRoot = formatRoot(sp.root || "/")
sp.root = formatRoot(path.posix.join(settings.httpStaticRoot,sp.subRoot))
settings.httpStatic = sanitised.length ? sanitised : false
parsedArgs.port !== undefined
settings.uiPort = parsedArgs.port
settings.uiPort === undefined
settings.uiPort = 1880
settings.uiHost = settings.uiHost||"0.0.0.0"
settings.flowFile = flowFile
parsedArgs.userDir
settings.userDir = parsedArgs.userDir
RED.init(server,settings)
err.code == "unsupported_version"
console.log("Unsupported version of Node.js:",process.version)
console.log("Node-RED requires Node.js v8.9.0 or later")
console.log("Failed to start server:")
err.stack
console.log(err.stack)
console.log(err)
process.exit(1)
function basicAuthMiddleware = function basicAuthMiddleware(user,pass) {
        var basicAuth = require('basic-auth');
        var checkPassword;
        var localCachedPassword;
        if (pass.length == "32") {
            // Assume its a legacy md5 password
            checkPassword = function(p) {
                return crypto.createHash('md5').update(p,'utf8').digest('hex') === pass;
            }
        } else {
            checkPassword = function(p) {
                return bcrypt.compareSync(p,pass);
            }
        }

        var checkPasswordAndCache = function(p) {
            // For BasicAuth routes we know the password cannot change without
            // a restart of Node-RED. This means we can cache the provided crypted
            // version to save recalculating each time.
            if (localCachedPassword === p) {
                return true;
            }
            var result = checkPassword(p);
            if (result) {
                localCachedPassword = p;
            }
     ...
function getListenPath = function getListenPath() {
        var port = settings.serverPort;
        if (port === undefined){
            port = settings.uiPort;
        }

        var listenPath = 'http'+(settings.https?'s':'')+'://'+
                        (settings.uiHost == '::'?'localhost':(settings.uiHost == '0.0.0.0'?'127.0.0.1':settings.uiHost))+
                        ':'+port;
        if (settings.httpAdminRoot !== false) {
            listenPath += settings.httpAdminRoot;
        } else if (settings.httpStatic) {
            listenPath += "/";
        }
        return listenPath;
    }
function exitWhenStopped = function exitWhenStopped() {
        if (!stopping) {
            stopping = true;
            RED.stop().then(function() {
                process.exit();
            });
        }
    }
