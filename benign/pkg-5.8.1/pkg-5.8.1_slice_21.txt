function exec = async function exec(argv2) {
    var _a, _b;
    const argv = (0, minimist_1.default)(argv2, {
        boolean: [
            'b',
            'build',
            'bytecode',
            'native-build',
            'd',
            'debug',
            'h',
            'help',
            'public',
            'v',
            'version',
        ],
        string: [
            '_',
            'c',
            'config',
            'o',
            'options',
            'output',
            'outdir',
            'out-dir',
            'out-path',
            'public-packages',
            'no-dict',
            't',
            'target',
            'targets',
            'C',
            'compress',
        ],
        default: { bytecode: true, 'native-build': true },
    });
    if (argv.h || argv.help) {
        (0, help_1.default)();
        return;
    }
    // version
    if (argv.v || argv.version) {
        // eslint-disable-next-line no-console
        console.log(versi...
const argv = (0, minimist_1.default)(argv2, {
        boolean: [
            'b',
            'build',
            'bytecode',
            'native-build',
            'd',
            'debug',
            'h',
            'help',
            'public',
            'v',
            'version',
        ],
        string: [
            '_',
            'c',
            'config',
            'o',
            'options',
            'output',
            'outdir',
            'out-dir',
            'out-path',
            'public-packages',
            'no-dict',
            't',
            'target',
            'targets',
            'C',
            'compress',
        ],
        default: { bytecode: true, 'native-build': true },
    })
_tmp_13.boolean = [
            'b',
            'build',
            'bytecode',
            'native-build',
            'd',
            'debug',
            'h',
            'help',
            'public',
            'v',
            'version',
        ]
_tmp_14.push("b")
_tmp_14.push("build")
_tmp_14.push("bytecode")
_tmp_14.push("native-build")
_tmp_14.push("d")
_tmp_14.push("debug")
_tmp_14.push("h")
_tmp_14.push("help")
_tmp_14.push("public")
_tmp_14.push("v")
_tmp_14.push("version")
_tmp_13.string = [
            '_',
            'c',
            'config',
            'o',
            'options',
            'output',
            'outdir',
            'out-dir',
            'out-path',
            'public-packages',
            'no-dict',
            't',
            'target',
            'targets',
            'C',
            'compress',
        ]
_tmp_15.push("_")
_tmp_15.push("c")
_tmp_15.push("config")
_tmp_15.push("o")
_tmp_15.push("options")
_tmp_15.push("output")
_tmp_15.push("outdir")
_tmp_15.push("out-dir")
_tmp_15.push("out-path")
_tmp_15.push("public-packages")
_tmp_15.push("no-dict")
_tmp_15.push("t")
_tmp_15.push("target")
_tmp_15.push("targets")
_tmp_15.push("C")
_tmp_15.push("compress")
_tmp_13.default = { bytecode: true, 'native-build': true }
argv.h || argv.help
argv.v || argv.version
<operator>.formatString("pkg@", version, "")
log_1.log.debugMode = argv.d || argv.debug
const forceBuild = argv.b || argv.build
const algo = argv.C || argv.compress || 'None'
let doCompress = compress_type_1.CompressType.None
algo.toLowerCase()
"brotli"
"br"
doCompress = compress_type_1.CompressType.Brotli
break;
"gzip"
"gz"
doCompress = compress_type_1.CompressType.GZip
break;
"none"
break;
default:
throw (0, log_1.wasReported)(`Invalid compression algorithm ${algo} ( should be None, Brotli or Gzip)`);
doCompress !== compress_type_1.CompressType.None
console.log('compression: ', compress_type_1.CompressType[doCompress])
!argv._.length
throw (0, log_1.wasReported)('Entry file/directory is expected', [
            'Pass --help to see usage information',
        ]);
_tmp_18.push("Pass --help to see usage information")
argv._.length > 1
throw (0, log_1.wasReported)('Not more than one entry file/directory is expected');
let input = path_1.default.resolve(argv._[0])
!(0, fs_extra_1.existsSync)(input)
throw (0, log_1.wasReported)('Input file does not exist', [input]);
(_tmp_21 = await (0, fs_extra_1.stat)(input)).isDirectory
input = path_1.default.join(input, 'package.json')
!(0, fs_extra_1.existsSync)(input)
throw (0, log_1.wasReported)('Input file does not exist', [input]);
isConfiguration(input)
inputJson = JSON.parse(await (0, fs_extra_1.readFile)(input, 'utf-8'))
inputJsonName = inputJson.name
inputJsonName = inputJsonName.split('/').pop()
_tmp_25 = inputJson
typeof bin === 'object'
bin[inputJsonName]
bin = bin[inputJsonName]
bin = bin[Object.keys(bin)[0]]
inputBin = path_1.default.resolve(path_1.default.dirname(input), bin)
!(0, fs_extra_1.existsSync)(inputBin)
throw (0, log_1.wasReported)('Bin file does not exist (taken from package.json ' +
                    "'bin' property)", [inputBin]);
_tmp_28 = __ecma.Array.factory()
inputJson && !inputBin
throw (0, log_1.wasReported)("Property 'bin' does not exist in", [input]);
const inputFin = inputBin || input
let config = argv.c || argv.config
inputJson && config
throw (0, log_1.wasReported)("Specify either 'package.json' or config. Not both");
config = path_1.default.resolve(config)
!(0, fs_extra_1.existsSync)(config)
throw (0, log_1.wasReported)('Config file does not exist', [config]);
configJson = require(config)
!configJson.name &&
            !configJson.files &&
            !configJson.dependencies &&
            !configJson.pkg
!configJson.files
!configJson.dependencies
!configJson.pkg
configJson = { pkg: configJson }
let output = argv.o || argv.output
let outputPath = argv['out-path'] || argv.outdir || argv['out-dir']
let autoOutput = false
output && outputPath
throw (0, log_1.wasReported)("Specify either 'output' or 'out-path'. Not both");
!output
name = inputJsonName
!name
throw (0, log_1.wasReported)("Property 'name' does not exist in", [argv._[0]]);
name = configJson.name
!name
name = path_1.default.basename(inputFin)
!outputPath
inputJson && inputJson.pkg
outputPath = inputJson.pkg.outputPath
configJson && configJson.pkg
outputPath = configJson.pkg.outputPath
outputPath = outputPath || ''
autoOutput = true
const ext = path_1.default.extname(name)
output = name.slice(0, -ext.length || undefined)
output = path_1.default.resolve(outputPath || '', output)
output = path_1.default.resolve(output)
const sTargets = argv.t || argv.target || argv.targets || ''
typeof sTargets !== 'string'
throw (0, log_1.wasReported)(`Something is wrong near ${JSON.stringify(sTargets)}`);
