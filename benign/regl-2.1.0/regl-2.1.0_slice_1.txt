function emitUniforms = function emitUniforms (env, scope, args, uniforms, filter, isBatchInnerLoop) {
    var shared = env.shared
    var GL = shared.gl

    var definedArrUniforms = {}
    var infix
    for (var i = 0; i < uniforms.length; ++i) {
      var uniform = uniforms[i]
      var name = uniform.name
      var type = uniform.info.type
      var size = uniform.info.size
      var arg = args.uniforms[name]
      if (size > 1) {
        // either foo[n] or foos, avoid define both
        if (!arg) {
          continue
        }
        var arrUniformName = name.replace('[0]', '')
        if (definedArrUniforms[arrUniformName]) {
          continue
        }
        definedArrUniforms[arrUniformName] = 1
      }
      var UNIFORM = env.link(uniform)
      var LOCATION = UNIFORM + '.location'

      var VALUE
      if (arg) {
        if (!filter(arg)) {
          continue
        }
        if (isStatic(arg)) {
          var value = arg.value
          check.command(
            value !== null && typeof...
var shared = env.shared
var GL = shared.gl
var definedArrUniforms = {}
i < uniforms.length
var uniform = uniforms[i]
var name = uniform.name
var type = uniform.info.type
var size = uniform.info.size
var arg = args.uniforms[name]
size > 1
!arg
continue
var arrUniformName = name.replace('[0]', '')
definedArrUniforms[arrUniformName]
continue
definedArrUniforms[arrUniformName] = 1
var UNIFORM = env.link(uniform)
var LOCATION = UNIFORM + '.location'
!filter(arg)
continue
isStatic(arg)
var value = arg.value
check.command(
            value !== null && typeof value !== 'undefined',
            'missing uniform "' + name + '"', env.commandStr)
value !== null && typeof value !== 'undefined'
'missing uniform "' + name + '"'
type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE
check.command(
              typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))),
              'invalid texture for uniform ' + name, env.commandStr)
typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube')))
(type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))
value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer'
value._reglType === 'framebuffer'
type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube')
value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'
value._reglType === 'framebufferCube'
'invalid texture for uniform ' + name
var TEX_VALUE = env.link(value._texture || value.color[0]._texture)
scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());')
scope.exit(TEX_VALUE, '.unbind();')
type === GL_FLOAT_MAT2 ||
            type === GL_FLOAT_MAT3 ||
            type === GL_FLOAT_MAT4
type === GL_FLOAT_MAT3
type === GL_FLOAT_MAT4
check.optional(function () {
              check.command(isArrayLike(value),
                'invalid matrix for uniform ' + name, env.commandStr)
              check.command(
                (type === GL_FLOAT_MAT2 && value.length === 4) ||
                (type === GL_FLOAT_MAT3 && value.length === 9) ||
                (type === GL_FLOAT_MAT4 && value.length === 16),
                'invalid length for matrix uniform ' + name, env.commandStr)
            })
var MAT_VALUE = env.global.def('new Float32Array([' +
              Array.prototype.slice.call(value) + '])')
(_tmp_120 = Array.prototype.slice).call
var dim = 2
type === GL_FLOAT_MAT3
dim = 3
type === GL_FLOAT_MAT4
dim = 4
scope(
              GL, '.uniformMatrix', dim, 'fv(',
              LOCATION, ',false,', MAT_VALUE, ');')
"fv("
",false,"
case GL_FLOAT:
size === 1
check.commandType(value, 'number', 'uniform ' + name, env.commandStr)
check.command(
                    isArrayLike(value) && (value.length === size),
                    'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length === size)
'uniform ' + name
infix = '1f'
break
case GL_FLOAT_VEC2:
check.command(
                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
                  'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2)
'uniform ' + name
infix = '2f'
break
case GL_FLOAT_VEC3:
check.command(
                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
                  'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3)
'uniform ' + name
infix = '3f'
break
case GL_FLOAT_VEC4:
check.command(
                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
                  'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4)
'uniform ' + name
infix = '4f'
break
case GL_BOOL:
size === 1
check.commandType(value, 'boolean', 'uniform ' + name, env.commandStr)
check.command(
                    isArrayLike(value) && (value.length === size),
                    'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length === size)
'uniform ' + name
infix = '1i'
break
case GL_INT:
size === 1
check.commandType(value, 'number', 'uniform ' + name, env.commandStr)
check.command(
                    isArrayLike(value) && (value.length === size),
                    'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length === size)
'uniform ' + name
infix = '1i'
break
case GL_BOOL_VEC2:
check.command(
                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
                  'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2)
'uniform ' + name
infix = '2i'
break
case GL_INT_VEC2:
check.command(
                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
                  'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2)
'uniform ' + name
infix = '2i'
break
case GL_BOOL_VEC3:
check.command(
                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
                  'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3)
'uniform ' + name
infix = '3i'
break
case GL_INT_VEC3:
check.command(
                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
                  'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3)
'uniform ' + name
infix = '3i'
break
case GL_BOOL_VEC4:
check.command(
                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
                  'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4)
'uniform ' + name
infix = '4i'
break
case GL_INT_VEC4:
check.command(
                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
                  'uniform ' + name, env.commandStr)
isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4)
'uniform ' + name
infix = '4i'
break
size > 1
infix += 'v'
value = env.global.def('[' +
              Array.prototype.slice.call(value) + ']')
(_tmp_122 = Array.prototype.slice).call
value = isArrayLike(value) ? Array.prototype.slice.call(value) : value
scope(GL, '.uniform', infix, '(', LOCATION, ',',
              value,
              ');')
continue
VALUE = arg.append(env, scope)
!filter(SCOPE_DECL)
continue
VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']')
type === GL_SAMPLER_2D
check(!Array.isArray(VALUE), 'must specify a scalar prop for textures')
scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
"._reglType==="framebuffer"){"
".color[0];"
type === GL_SAMPLER_CUBE
check(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps')
scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
"._reglType==="framebufferCube"){"
".color[0];"
check.optional(function () {
        function emitCheck (pred, message) {
          env.assert(scope, pred,
            'bad data or missing for uniform "' + name + '".  ' + message)
        }

        function checkType (type, size) {
          if (size === 1) {
            check(!Array.isArray(VALUE), 'must not specify an array type for uniform')
          }
          emitCheck(
            'Array.isArray(' + VALUE + ') && typeof ' + VALUE + '[0]===" ' + type + '"' +
            ' || typeof ' + VALUE + '==="' + type + '"',
            'invalid type, expected ' + type)
        }

        function checkVector (n, type, size) {
          if (Array.isArray(VALUE)) {
            check(VALUE.length && VALUE.length % n === 0 && VALUE.length <= n * size, 'must have length of ' + (size === 1 ? '' : 'n * ') + n)
          } else {
            emitCheck(
              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length && ' + VALUE + '.length % ' + n + ' === 0' +
              ' && '...
var unroll = 1
case GL_SAMPLER_2D:
case GL_SAMPLER_CUBE:
var TEX = scope.def(VALUE, '._texture')
scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());')
scope.exit(TEX, '.unbind();')
continue
case GL_INT:
case GL_BOOL:
infix = '1i'
break
case GL_INT_VEC2:
case GL_BOOL_VEC2:
infix = '2i'
unroll = 2
break
case GL_INT_VEC3:
case GL_BOOL_VEC3:
infix = '3i'
unroll = 3
break
case GL_INT_VEC4:
case GL_BOOL_VEC4:
infix = '4i'
unroll = 4
break
case GL_FLOAT:
infix = '1f'
break
case GL_FLOAT_VEC2:
infix = '2f'
unroll = 2
break
case GL_FLOAT_VEC3:
infix = '3f'
unroll = 3
break
case GL_FLOAT_VEC4:
infix = '4f'
unroll = 4
break
case GL_FLOAT_MAT2:
infix = 'Matrix2fv'
break
case GL_FLOAT_MAT3:
infix = 'Matrix3fv'
break
case GL_FLOAT_MAT4:
infix = 'Matrix4fv'
break
infix.indexOf('Matrix') === -1 && size > 1
infix += 'v'
unroll = 1
infix.charAt(0) === 'M'
scope(GL, '.uniform', infix, '(', LOCATION, ',')
var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2)
var STORAGE = env.global.def('new Float32Array(', matSize, ')')
Array.isArray(VALUE)
scope(
            'false,(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            }), ',', STORAGE, ')')
"false,("
loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            })
scope(
            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            }), ',', STORAGE, ')')
" instanceof Float32Array)?"
loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            })
scope(');')
unroll > 1
__ecma.Array.factory()
__ecma.Array.factory()
j < unroll
Array.isArray(VALUE)
cur.push(VALUE[j])
cur.push(scope.def(VALUE + '[' + j + ']'))
prev.push(scope.def())
scope('if(!', env.batchId, '||', prev.map(function (p, i) {
            return p + '!==' + cur[i]
          }).join('||'), '){', prev.map(function (p, i) {
            return p + '=' + cur[i] + ';'
          }).join(''))
(_tmp_126 = prev.map(function (p, i) {
            return p + '=' + cur[i] + ';'
          })).join
join
scope(GL, '.uniform', infix, '(', LOCATION, ',', cur.join(','), ');')
scope('}')
check(!Array.isArray(VALUE), 'uniform value must not be an array')
var prevS = scope.def()
scope('if(!', env.batchId, '||', prevS, '!==', VALUE, '){',
            prevS, '=', VALUE, ';')
scope(GL, '.uniform', infix, '(', LOCATION, ',', VALUE, ');')
scope('}')
