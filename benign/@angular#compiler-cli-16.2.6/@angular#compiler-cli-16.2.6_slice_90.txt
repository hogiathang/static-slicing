analyze(node, decorator) {
    var _a, _b, _c, _d;
    this.perf.eventCount(PerfEvent.AnalyzeComponent);
    const containingFile = node.getSourceFile().fileName;
    this.literalCache.delete(decorator);
    let diagnostics;
    let isPoisoned = false;
    const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.refEmitter, this.referencesRegistry, this.isCore, this.annotateForClosureCompiler, this.elementSchemaRegistry.getDefaultComponentElementName());
    if (directiveResult === void 0) {
      return {};
    }
    const { decorator: component, metadata, inputs, outputs, hostDirectives, rawHostDirectives } = directiveResult;
    const encapsulation = (_a = resolveEnumValue(this.evaluator, component, "encapsulation", "ViewEncapsulation")) != null ? _a : ViewEncapsulation.Emulated;
    const changeDetection = resolveEnumValue(this.evaluator, component, "changeDetection", "ChangeDetectionStrategy");
    let animations = null;
    let ani...
this.perf.eventCount(PerfEvent.AnalyzeComponent)
const containingFile = node.getSourceFile().fileName
(_tmp_993 = this.literalCache).delete
let isPoisoned = false
const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.refEmitter, this.referencesRegistry, this.isCore, this.annotateForClosureCompiler, this.elementSchemaRegistry.getDefaultComponentElementName())
directiveResult === void 0
rawHostDirectives = _tmp_996.rawHostDirectives
const encapsulation = (_a = resolveEnumValue(this.evaluator, component, "encapsulation", "ViewEncapsulation")) != null ? _a : ViewEncapsulation.Emulated
const changeDetection = resolveEnumValue(this.evaluator, component, "changeDetection", "ChangeDetectionStrategy")
let animations = null
let animationTriggerNames = null
component.has("animations")
const animationExpression = component.get("animations")
animations = new WrappedNodeExpr7(animationExpression)
const animationsValue = this.evaluator.evaluate(animationExpression, animationTriggerResolver)
animationTriggerNames = { includesDynamicAnimations: false, staticTriggerNames: [] }
collectAnimationNames(animationsValue, animationTriggerNames)
const relativeContextFilePath = this.rootDirs.reduce((previous, rootDir) => {
      const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));
      if (previous === void 0 || candidate.length < previous.length) {
        return candidate;
      } else {
        return previous;
      }
    }, void 0)
void 0
let viewProvidersRequiringFactory = null
let providersRequiringFactory = null
let wrappedViewProviders = null
component.has("viewProviders")
const viewProviders = component.get("viewProviders")
viewProvidersRequiringFactory = resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator)
wrappedViewProviders = new WrappedNodeExpr7(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(viewProviders) : viewProviders)
component.has("providers")
providersRequiringFactory = resolveProvidersRequiringFactory(component.get("providers"), this.reflector, this.evaluator)
let resolvedImports = null
let rawImports = (_b = component.get("imports")) != null ? _b : null
rawImports && !metadata.isStandalone
diagnostics === void 0
__ecma.Array.factory()
diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_NOT_STANDALONE, component.get("imports"), `'imports' is only valid on a component that is standalone.`, [makeRelatedInformation(node.name, `Did you forget to add 'standalone: true' to this @Component?`)]))
isPoisoned = true
this.compilationMode !== CompilationMode.LOCAL && rawImports
const expr = rawImports
const importResolvers = combineResolvers([
        createModuleWithProvidersResolver(this.reflector, this.isCore),
        forwardRefResolver
      ])
_tmp_1003.push(createModuleWithProvidersResolver(this.reflector, this.isCore))
_tmp_1003.push(forwardRefResolver)
const imported = this.evaluator.evaluate(expr, importResolvers)
_tmp_1005 = validateAndFlattenComponentImports(imported, expr)
resolvedImports = flattened
rawImports = expr
importDiagnostics.length > 0
isPoisoned = true
diagnostics === void 0
__ecma.Array.factory()
diagnostics.push(...importDiagnostics)
let schemas = null
component.has("schemas") && !metadata.isStandalone
diagnostics === void 0
__ecma.Array.factory()
diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_NOT_STANDALONE, component.get("schemas"), `'schemas' is only valid on a component that is standalone.`))
this.compilationMode !== CompilationMode.LOCAL && component.has("schemas")
schemas = extractSchemas(component.get("schemas"), this.evaluator, "Component")
metadata.isStandalone
__ecma.Array.factory()
(_tmp_1006 = this.preanalyzeTemplateCache).has
const preanalyzed = this.preanalyzeTemplateCache.get(node)
(_tmp_1008 = this.preanalyzeTemplateCache).delete
template = preanalyzed
const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, this.evaluator, this.depTracker, this.resourceLoader, this.defaultPreserveWhitespaces)
template = extractTemplate(node, templateDecl, this.evaluator, this.depTracker, this.resourceLoader, {
        enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,
        i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,
        usePoisonedData: this.usePoisonedData,
        enabledBlockTypes: this.enabledBlockTypes
      })
_tmp_1009.enableI18nLegacyMessageIdFormat = this.enableI18nLegacyMessageIdFormat
_tmp_1009.i18nNormalizeLineEndingsInICUs = this.i18nNormalizeLineEndingsInICUs
_tmp_1009.usePoisonedData = this.usePoisonedData
_tmp_1009.enabledBlockTypes = this.enabledBlockTypes
const templateResource = template.declaration.isInline ? { path: null, expression: component.get("template") } : {
      path: absoluteFrom(template.declaration.resolvedTemplateUrl),
      expression: template.sourceMapping.node
    }
_tmp_1011.path = absoluteFrom(template.declaration.resolvedTemplateUrl)
_tmp_1011.expression = template.sourceMapping.node
__ecma.Array.factory()
const styleResources = extractStyleResources(this.resourceLoader, component, containingFile)
const styleUrls = [
      ...extractComponentStyleUrls(this.evaluator, component),
      ..._extractTemplateStyleUrls(template)
    ]
_tmp_1012.push(...extractComponentStyleUrls(this.evaluator, component))
_tmp_1012.push(..._extractTemplateStyleUrls(template))
_iterator_115 = <operator>.iterator(styleUrls)
const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile)
const resourceStr = this.resourceLoader.load(resourceUrl)
styles.push(resourceStr)
this.depTracker !== null
this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl))
this.depTracker !== null
this.depTracker.recordDependencyAnalysisFailure(node.getSourceFile())
diagnostics === void 0
__ecma.Array.factory()
const resourceType = styleUrl.source === 2 ? 2 : 1
diagnostics.push(makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType).toDiagnostic())
encapsulation === ViewEncapsulation.ShadowDom && metadata.selector !== null
const selectorError = checkCustomElementSelectorForErrors(metadata.selector)
selectorError !== null
diagnostics === void 0
__ecma.Array.factory()
diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR, component.get("selector"), selectorError))
let inlineStyles = null
(_tmp_1018 = this.preanalyzeStylesCache).has
inlineStyles = this.preanalyzeStylesCache.get(node)
(_tmp_1020 = this.preanalyzeStylesCache).delete
