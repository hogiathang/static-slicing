analyze(node, decorator) {
    var _a, _b, _c, _d, _e;
    this.perf.eventCount(PerfEvent.AnalyzeNgModule);
    const name = node.name.text;
    if (decorator.args === null || decorator.args.length > 1) {
      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @NgModule decorator`);
    }
    const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) : ts22.factory.createObjectLiteralExpression([]);
    if (!ts22.isObjectLiteralExpression(meta)) {
      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, "@NgModule argument must be an object literal");
    }
    const ngModule = reflectObjectLiteral(meta);
    if (ngModule.has("jit")) {
      return {};
    }
    const moduleResolvers = combineResolvers([
      createModuleWithProvidersResolver(this.reflector, this.isCore),
      forwardRefResolver
    ]);
    const diagnostics = [];
    let declarationRefs = [];
    const rawDe...
this.perf.eventCount(PerfEvent.AnalyzeNgModule)
const name = node.name.text
decorator.args === null || decorator.args.length > 1
throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @NgModule decorator`);
const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) : ts22.factory.createObjectLiteralExpression([])
!ts22.isObjectLiteralExpression(meta)
throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, "@NgModule argument must be an object literal");
const ngModule = reflectObjectLiteral(meta)
ngModule.has("jit")
const moduleResolvers = combineResolvers([
      createModuleWithProvidersResolver(this.reflector, this.isCore),
      forwardRefResolver
    ])
_tmp_892.push(createModuleWithProvidersResolver(this.reflector, this.isCore))
_tmp_892.push(forwardRefResolver)
const diagnostics = []
let declarationRefs = []
const rawDeclarations = (_a = ngModule.get("declarations")) != null ? _a : null
this.compilationMode !== CompilationMode.LOCAL && rawDeclarations !== null
const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver)
declarationRefs = this.resolveTypeList(rawDeclarations, declarationMeta, name, "declarations", 0).references
_iterator_104 = <operator>.iterator(declarationRefs)
ref.node.getSourceFile().isDeclarationFile
const errorNode = ref.getOriginForDiagnostics(rawDeclarations)
diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `Cannot declare '${ref.node.name.text}' in an NgModule as it's not a part of the current compilation.`, [makeRelatedInformation(ref.node.name, `'${ref.node.name.text}' is declared here.`)]))
diagnostics.length > 0
__ecma.Array.factory()
let rawImports = (_b = ngModule.get("imports")) != null ? _b : null
this.compilationMode !== CompilationMode.LOCAL && rawImports !== null
const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers)
importRefs = this.resolveTypeList(rawImports, importsMeta, name, "imports", 0).references
__ecma.Array.factory()
const rawExports = (_c = ngModule.get("exports")) != null ? _c : null
