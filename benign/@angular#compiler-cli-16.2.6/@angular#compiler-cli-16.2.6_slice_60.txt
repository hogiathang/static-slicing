analyze(node, decorator) {
    var _a, _b, _c, _d, _e;
    this.perf.eventCount(PerfEvent.AnalyzeNgModule);
    const name = node.name.text;
    if (decorator.args === null || decorator.args.length > 1) {
      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @NgModule decorator`);
    }
    const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) : ts22.factory.createObjectLiteralExpression([]);
    if (!ts22.isObjectLiteralExpression(meta)) {
      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, "@NgModule argument must be an object literal");
    }
    const ngModule = reflectObjectLiteral(meta);
    if (ngModule.has("jit")) {
      return {};
    }
    const moduleResolvers = combineResolvers([
      createModuleWithProvidersResolver(this.reflector, this.isCore),
      forwardRefResolver
    ]);
    const diagnostics = [];
    let declarationRefs = [];
    const rawDe...
this.perf.eventCount(PerfEvent.AnalyzeNgModule)
const name = node.name.text
decorator.args === null || decorator.args.length > 1
throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @NgModule decorator`);
const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) : ts22.factory.createObjectLiteralExpression([])
!ts22.isObjectLiteralExpression(meta)
throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, "@NgModule argument must be an object literal");
const ngModule = reflectObjectLiteral(meta)
ngModule.has("jit")
const moduleResolvers = combineResolvers([
      createModuleWithProvidersResolver(this.reflector, this.isCore),
      forwardRefResolver
    ])
_tmp_892.push(createModuleWithProvidersResolver(this.reflector, this.isCore))
_tmp_892.push(forwardRefResolver)
const diagnostics = []
let declarationRefs = []
const rawDeclarations = (_a = ngModule.get("declarations")) != null ? _a : null
this.compilationMode !== CompilationMode.LOCAL && rawDeclarations !== null
const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver)
declarationRefs = this.resolveTypeList(rawDeclarations, declarationMeta, name, "declarations", 0).references
_iterator_104 = <operator>.iterator(declarationRefs)
ref.node.getSourceFile().isDeclarationFile
const errorNode = ref.getOriginForDiagnostics(rawDeclarations)
diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `Cannot declare '${ref.node.name.text}' in an NgModule as it's not a part of the current compilation.`, [makeRelatedInformation(ref.node.name, `'${ref.node.name.text}' is declared here.`)]))
diagnostics.length > 0
__ecma.Array.factory()
let rawImports = (_b = ngModule.get("imports")) != null ? _b : null
this.compilationMode !== CompilationMode.LOCAL && rawImports !== null
const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers)
importRefs = this.resolveTypeList(rawImports, importsMeta, name, "imports", 0).references
__ecma.Array.factory()
const rawExports = (_c = ngModule.get("exports")) != null ? _c : null
this.compilationMode !== CompilationMode.LOCAL && rawExports !== null
const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers)
exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, "exports", 0).references
this.referencesRegistry.add(node, ...exportRefs)
let bootstrapRefs = []
const rawBootstrap = (_d = ngModule.get("bootstrap")) != null ? _d : null
this.compilationMode !== CompilationMode.LOCAL && rawBootstrap !== null
const bootstrapMeta = this.evaluator.evaluate(rawBootstrap, forwardRefResolver)
bootstrapRefs = this.resolveTypeList(rawBootstrap, bootstrapMeta, name, "bootstrap", 0).references
_iterator_105 = <operator>.iterator(bootstrapRefs)
const dirMeta = this.metaReader.getDirectiveMetadata(ref)
dirMeta == null ? void 0 : dirMeta.isStandalone
diagnostics.push(makeStandaloneBootstrapDiagnostic(node, ref, rawBootstrap))
this.compilationMode !== CompilationMode.LOCAL && ngModule.has("schemas") ? extractSchemas(ngModule.get("schemas"), this.evaluator, "NgModule") : __ecma.Array.factory()
let id = null
ngModule.has("id")
const idExpr = ngModule.get("id")
!isModuleIdExpression(idExpr)
id = new WrappedNodeExpr6(idExpr)
const diag = makeDiagnostic(ErrorCode.WARN_NGMODULE_ID_UNNECESSARY, idExpr, `Using 'module.id' for NgModule.id is a common anti-pattern that is ignored by the Angular compiler.`)
diag.category = ts22.DiagnosticCategory.Warning
diagnostics.push(diag)
const valueContext = node.getSourceFile()
const exportedNodes = new Set(exportRefs.map((ref) => ref.node))
const declarations = []
const exportedDeclarations = []
const bootstrap = bootstrapRefs.map((bootstrap2) => this._toR3Reference(bootstrap2.getOriginForDiagnostics(meta, node.name), bootstrap2, valueContext))
_iterator_106 = <operator>.iterator(declarationRefs)
const decl = this._toR3Reference(ref.getOriginForDiagnostics(meta, node.name), ref, valueContext)
declarations.push(decl)
exportedNodes.has(ref.node)
exportedDeclarations.push(decl.type)
const imports = importRefs.map((imp) => this._toR3Reference(imp.getOriginForDiagnostics(meta, node.name), imp, valueContext))
const exports = exportRefs.map((exp) => this._toR3Reference(exp.getOriginForDiagnostics(meta, node.name), exp, valueContext))
const isForwardReference = (ref) => isExpressionForwardReference(ref.value, node.name, valueContext)
const containsForwardDecls = bootstrap.some(isForwardReference) || declarations.some(isForwardReference) || imports.some(isForwardReference) || exports.some(isForwardReference)
const type = wrapTypeReference(this.reflector, node)
this.compilationMode === CompilationMode.LOCAL
ngModuleMetadata = {
        kind: R3NgModuleMetadataKind.Local,
        type,
        bootstrapExpression: rawBootstrap ? new WrappedNodeExpr6(rawBootstrap) : null,
        declarationsExpression: rawDeclarations ? new WrappedNodeExpr6(rawDeclarations) : null,
        exportsExpression: rawExports ? new WrappedNodeExpr6(rawExports) : null,
        importsExpression: rawImports ? new WrappedNodeExpr6(rawImports) : null,
        id,
        selectorScopeMode: R3SelectorScopeMode.SideEffect,
        schemas: []
      }
_tmp_904.kind = R3NgModuleMetadataKind.Local
_tmp_904.type = type
_tmp_904.bootstrapExpression = rawBootstrap ? new WrappedNodeExpr6(rawBootstrap) : null
_tmp_904.declarationsExpression = rawDeclarations ? new WrappedNodeExpr6(rawDeclarations) : null
_tmp_904.exportsExpression = rawExports ? new WrappedNodeExpr6(rawExports) : null
_tmp_904.importsExpression = rawImports ? new WrappedNodeExpr6(rawImports) : null
_tmp_904.id = id
_tmp_904.selectorScopeMode = R3SelectorScopeMode.SideEffect
_tmp_904.schemas = __ecma.Array.factory()
ngModuleMetadata = {
        kind: R3NgModuleMetadataKind.Global,
        type,
        bootstrap,
        declarations,
        publicDeclarationTypes: this.onlyPublishPublicTypings ? exportedDeclarations : null,
        exports,
        imports,
        includeImportTypes: !this.onlyPublishPublicTypings,
        containsForwardDecls,
        id,
        selectorScopeMode: this.includeSelectorScope ? R3SelectorScopeMode.SideEffect : R3SelectorScopeMode.Omit,
        schemas: []
      }
_tmp_909.kind = R3NgModuleMetadataKind.Global
_tmp_909.type = type
_tmp_909.bootstrap = bootstrap
_tmp_909.declarations = declarations
_tmp_909.publicDeclarationTypes = this.onlyPublishPublicTypings ? exportedDeclarations : null
_tmp_909.exports = exports
_tmp_909.imports = imports
_tmp_909.includeImportTypes = !this.onlyPublishPublicTypings
_tmp_909.containsForwardDecls = containsForwardDecls
_tmp_909.id = id
_tmp_909.selectorScopeMode = this.includeSelectorScope ? R3SelectorScopeMode.SideEffect : R3SelectorScopeMode.Omit
_tmp_909.schemas = __ecma.Array.factory()
const rawProviders = ngModule.has("providers") ? ngModule.get("providers") : null
