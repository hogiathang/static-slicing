function run = function run(transformFile, paths, options) {
  let usedRemoteScript = false;
  const cpus = options.cpus ? Math.min(availableCpus, options.cpus) : availableCpus;
  const extensions =
    options.extensions && options.extensions.split(',').map(ext => '.' + ext);
  const fileCounters = {error: 0, ok: 0, nochange: 0, skip: 0};
  const statsCounter = {};
  const startTime = process.hrtime();

  ignores.add(options.ignorePattern);
  ignores.addFromFile(options.ignoreConfig);

  if (/^http/.test(transformFile)) {
    usedRemoteScript = true;
    return new Promise((resolve, reject) => {
      // call the correct `http` or `https` implementation
      (transformFile.indexOf('https') !== 0 ?  http : https).get(transformFile, (res) => {
        let contents = '';
        res
          .on('data', (d) => {
            contents += d.toString();
          })
          .on('end', () => {
            const ext = path.extname(transformFile);
            temp.open({ prefix:...
let usedRemoteScript = false
const cpus = options.cpus ? Math.min(availableCpus, options.cpus) : availableCpus
const extensions =
    options.extensions && options.extensions.split(',').map(ext => '.' + ext)
options.extensions && options.extensions.split(',').map(ext => '.' + ext)
const fileCounters = {error: 0, ok: 0, nochange: 0, skip: 0}
const statsCounter = {}
const startTime = process.hrtime()
ignores.add(options.ignorePattern)
ignores.addFromFile(options.ignoreConfig)
/^http/.test(transformFile)
!fs.existsSync(transformFile)
process.stderr.write(
      chalk.white.bgRed('ERROR') + ' Transform file ' + transformFile + ' does not exist \n'
    )
function transform = function transform(transformFile) {
    return getAllFiles(
      paths,
      name => !extensions || extensions.indexOf(path.extname(name)) != -1
    ).then(files => {
        const numFiles = files.length;

        if (numFiles === 0) {
          process.stdout.write('No files selected, nothing to do. \n');
          return [];
        }

        const processes = options.runInBand ? 1 : Math.min(numFiles, cpus);
        const chunkSize = processes > 1 ?
          Math.min(Math.ceil(numFiles / processes), CHUNK_SIZE) :
          numFiles;

        let index = 0;
        // return the next chunk of work for a free worker
        function next() {
          if (!options.silent && !options.runInBand && index < numFiles) {
            process.stdout.write(
              'Sending ' +
              Math.min(chunkSize, numFiles-index) +
              ' files to free worker...\n'
            );
          }
          return files.slice(index, index += chunkSize);...
