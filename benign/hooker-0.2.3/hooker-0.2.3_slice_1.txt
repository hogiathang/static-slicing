var path = require('path')
var fs = require('fs')
var nodeunit = require('nodeunit')
var filepaths = fs.readdirSync('test').map(function(filename) {
  return path.join('test', filename);
})
var unfinished = {}
function sendMessage = function sendMessage(message) {
  process.stdout.write(JSON.stringify(message) + '\n');
}
process.on('uncaughtException', function (e) {
  sendMessage({error: [e.name, e.message, e.stack]});
  process.exit();
})
var unfinished = {}
process.on('exit', function (e) {
  var len = Object.keys(unfinished).length
  if (len > 0) {
    sendMessage({exit: ['UNFINISHED']});
    // process.reallyExit(len);
  } else {
    sendMessage({exit: ['finished']});
  }
  // process.exit();
})
nodeunit.reporters.test = {
  run: function(files, options, callback) {
    // Nodeunit needs absolute paths.
    var paths = files.map(function (filepath) {
      return path.resolve(filepath);
    });
    nodeunit.runFiles(paths, {
      // No idea.
      testspec: undefined,
      // Executed when the first test in a file is run. If no tests exist in
      // the file, this doesn't execute.
      moduleStart: function(name) {
        // Keep track of this so that moduleDone output can be suppressed in
        // cases where a test file contains no tests.
        currentModule = name;
        // Send back to the parent process.
        sendMessage({moduleStart: [name.toString()]});
      },
      // Executed after a file is done being processed. This executes whether
      // tests exist in the file or not.
      moduleDone: function(name) {
        // Abort if no tests actually ran.
        if (name !== currentModule) { return; }
        // Send back to the parent process.
      ...
_tmp_10.run = <lambda>3
nodeunit.reporters.test.run(filepaths, {})
