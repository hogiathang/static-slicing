function oAuthCallback = async function oAuthCallback(params: {
  options: InternalOptions<"oauth">
  query: RequestInternal["query"]
  body: RequestInternal["body"]
  method: Required<RequestInternal>["method"]
  cookies: RequestInternal["cookies"]
}) {
  const { options, query, body, method, cookies } = params
  const { logger, provider } = options

  const errorMessage = body?.error ?? query?.error
  if (errorMessage) {
    const error = new Error(errorMessage)
    logger.error("OAUTH_CALLBACK_HANDLER_ERROR", {
      error,
      error_description: query?.error_description,
      providerId: provider.id,
    })
    logger.debug("OAUTH_CALLBACK_HANDLER_ERROR", { body })
    throw error
  }

  if (provider.version?.startsWith("1.")) {
    try {
      const client = await oAuth1Client(options)
      // Handle OAuth v1.x
      const { oauth_token, oauth_verifier } = query ?? {}
      const tokens = (await (client as any).getOAuthAccessToken(
        oauth_token,
        oAuth1TokenStore.get(oauth_token),
   ...
options = _tmp_6.options
provider = _tmp_7.provider
const errorMessage = body?.error ?? query?.error
const error = new Error(errorMessage)
logger.error("OAUTH_CALLBACK_HANDLER_ERROR", {
      error,
      error_description: query?.error_description,
      providerId: provider.id,
    })
_tmp_9.error = error
_tmp_9.error_description = query.error_description
_tmp_9.providerId = provider.id
logger.debug("OAUTH_CALLBACK_HANDLER_ERROR", { body })
throw error
provider.version?.startsWith("1.")
const client = await oAuth1Client(options)
oauth_verifier = _tmp_12.oauth_verifier
const tokens = (await (client as any).getOAuthAccessToken(
        oauth_token,
        oAuth1TokenStore.get(oauth_token),
        oauth_verifier
      )) as TokenSet
oAuth1TokenStore.get(oauth_token)
let profile: Profile = await (client as any).get(
        provider.profileUrl,
        tokens.oauth_token,
        tokens.oauth_token_secret
      )
provider.profileUrl
tokens.oauth_token
tokens.oauth_token_secret
typeof profile === "string"
profile = JSON.parse(profile)
const newProfile = await getProfile({ profile, tokens, provider, logger })
_tmp_16.cookies = __ecma.Array.factory()
logger.error("OAUTH_V1_GET_ACCESS_TOKEN_ERROR", error as Error)
throw error
oAuth1TokenStore.delete(query.oauth_token)
const client = await openidClient(options)
const checks: OAuthChecks = {}
const resCookies: Cookie[] = []
await _checks.state.use(cookies, resCookies, options, checks)
await _checks.pkce.use(cookies, resCookies, options, checks)
await _checks.nonce.use(cookies, resCookies, options, checks)
const params: CallbackParamsType = {
      ...client.callbackParams({
        url: `http://n?${new URLSearchParams(query)}`,
        // TODO: Ask to allow object to be passed upstream:
        // https://github.com/panva/node-openid-client/blob/3ae206dfc78c02134aa87a07f693052c637cab84/types/index.d.ts#L439
        // @ts-expect-error
        body,
        method,
      }),
      ...provider.token?.params,
    }
...client.callbackParams({
        url: `http://n?${new URLSearchParams(query)}`,
        // TODO: Ask to allow object to be passed upstream:
        // https://github.com/panva/node-openid-client/blob/3ae206dfc78c02134aa87a07f693052c637cab84/types/index.d.ts#L439
        // @ts-expect-error
        body,
        method,
      })
_tmp_22.url = <operator>.formatString("http://n?", new URLSearchParams(query), "")
_tmp_22.body = body
_tmp_22.method = method
...provider.token?.params
provider.token.request
const response = await provider.token.request({
        provider,
        params,
        checks,
        client,
      })
_tmp_25.provider = provider
_tmp_25.params = params
_tmp_25.checks = checks
_tmp_25.client = client
tokens = new TokenSet(response.tokens)
provider.idToken
tokens = await client.callback(provider.callbackUrl, params, checks)
tokens = await client.oauthCallback(provider.callbackUrl, params, checks)
Array.isArray(tokens.scope)
tokens.scope = tokens.scope.join(" ")
provider.userinfo.request
profile = await provider.userinfo.request({
        provider,
        tokens,
        client,
      })
