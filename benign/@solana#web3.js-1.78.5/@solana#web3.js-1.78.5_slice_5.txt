digestInto(out) {
          assert$3.exists(this);
          assert$3.output(out, this);
          this.finished = true;
          // Padding
          // We can avoid allocation of buffer for padding completely if it
          // was previously not allocated here. But it won't change performance.
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          // append the bit '1' to the message
          buffer[pos++] = 0b10000000;
          this.buffer.subarray(pos).fill(0);
          // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
          if (this.padOffset > blockLen - pos) {
              this.process(view, 0);
              pos = 0;
          }
          // Pad until full block byte with zeros
          for (let i = pos; i < blockLen; i++)
              buffer[i] = 0;
          // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before tha...
assert$3.exists(this)
assert$3.output(out, this)
this.finished = true
blockLen = _tmp_1153.blockLen
pos = _tmp_1154.pos
buffer[pos++] = 0b10000000
(_tmp_1155 = this.buffer.subarray(pos)).fill
this.padOffset > blockLen - pos
this.process(view, 0)
pos = 0
i < blockLen
buffer[i] = 0
setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE)
this.process(view, 0)
const oview = createView(out)
const len = this.outputLen
len % 4
throw new Error('_sha2: outputLen should be aligned to 32bit');
const outLen = len / 4
const state = this.get()
