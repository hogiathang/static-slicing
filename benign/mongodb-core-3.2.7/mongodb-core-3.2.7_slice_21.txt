Pool.prototype.connect = function() {
  if (this.state !== DISCONNECTED) {
    throw new MongoError('connection in unlawful state ' + this.state);
  }

  const self = this;
  stateTransition(this, CONNECTING);

  self.connectingConnections++;
  connect(self.options, (err, connection) => {
    self.connectingConnections--;

    if (err) {
      if (self.logger.isDebug()) {
        self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
      }

      if (self.state === CONNECTING) {
        self.emit('error', err);
      }

      return;
    }

    if (self.state === DESTROYED || self.state === DESTROYING) {
      connection.destroy();
      return self.destroy();
    }

    // attach event handlers
    connection.on('error', self._connectionErrorHandler);
    connection.on('close', self._connectionCloseHandler);
    connection.on('timeout', self._connectionTimeoutHandler);
    connection.on('parseError', self._connectionParseErrorHandler);
    connection....
this.state !== DISCONNECTED
throw new MongoError('connection in unlawful state ' + this.state);
const self = this
stateTransition(this, CONNECTING)
self.connectingConnections++
connect(self.options, (err, connection) => {
    self.connectingConnections--;

    if (err) {
      if (self.logger.isDebug()) {
        self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
      }

      if (self.state === CONNECTING) {
        self.emit('error', err);
      }

      return;
    }

    if (self.state === DESTROYED || self.state === DESTROYING) {
      connection.destroy();
      return self.destroy();
    }

    // attach event handlers
    connection.on('error', self._connectionErrorHandler);
    connection.on('close', self._connectionCloseHandler);
    connection.on('timeout', self._connectionTimeoutHandler);
    connection.on('parseError', self._connectionParseErrorHandler);
    connection.on('message', self._messageHandler);

    // If we are in a topology, delegate the auth to it
    // This is to avoid issues where we would auth against an
    // arbiter
    if (self.options.inTopology) {
      stateTransition(self, CONNECTED);...
