onMessage(message: BinMsg | Response) {
    const delayedTimeoutId = this[kDelayedTimeoutId];
    if (delayedTimeoutId != null) {
      clearTimeout(delayedTimeoutId);
      this[kDelayedTimeoutId] = null;
    }

    const socketTimeoutMS = this[kStream].timeout ?? 0;
    this[kStream].setTimeout(0);

    // always emit the message, in case we are streaming
    this.emit('message', message);
    let operationDescription = this[kQueue].get(message.responseTo);

    if (!operationDescription && this.isMonitoringConnection) {
      // This is how we recover when the initial hello's requestId is not
      // the responseTo when hello responses have been skipped:

      // First check if the map is of invalid size
      if (this[kQueue].size > 1) {
        this.cleanup(true, new MongoRuntimeError(INVALID_QUEUE_SIZE));
      } else {
        // Get the first orphaned operation description.
        const entry = this[kQueue].entries().next();
        if (entry.value != null) {
          co...
const delayedTimeoutId = this[kDelayedTimeoutId]
delayedTimeoutId != null
clearTimeout(delayedTimeoutId)
this[kDelayedTimeoutId] = null
const socketTimeoutMS = this[kStream].timeout ?? 0
(_tmp_31 = this[kStream]).setTimeout
this.emit('message', message)
let operationDescription = this[kQueue].get(message.responseTo)
!operationDescription && this.isMonitoringConnection
this[kQueue].size > 1
this.cleanup(true, new MongoRuntimeError(INVALID_QUEUE_SIZE))
const entry = this[kQueue].entries().next()
entry.value != null
requestId = _tmp_36[0]
operationDescription = orphaned
(_tmp_37 = this[kQueue]).delete
!operationDescription
const callback = operationDescription.cb
this[kQueue].delete(message.responseTo)
