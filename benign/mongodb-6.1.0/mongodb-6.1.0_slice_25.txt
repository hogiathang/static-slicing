async execute<T extends Document>(
    executor: StateMachineExecutable,
    context: MongoCryptContext
  ): Promise<T> {
    const keyVaultNamespace = executor._keyVaultNamespace;
    const keyVaultClient = executor._keyVaultClient;
    const metaDataClient = executor._metaDataClient;
    const mongocryptdClient = executor._mongocryptdClient;
    const mongocryptdManager = executor._mongocryptdManager;
    let result: T | null = null;

    while (context.state !== MONGOCRYPT_CTX_DONE && context.state !== MONGOCRYPT_CTX_ERROR) {
      debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);

      switch (context.state) {
        case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
          const filter = deserialize(context.nextMongoOperation());
          if (!metaDataClient) {
            throw new MongoCryptError(
              'unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined'
            );
      ...
const keyVaultNamespace = executor._keyVaultNamespace
const keyVaultClient = executor._keyVaultClient
const metaDataClient = executor._metaDataClient
const mongocryptdClient = executor._mongocryptdClient
const mongocryptdManager = executor._mongocryptdManager
let result: T | null = null
context.state !== MONGOCRYPT_CTX_DONE && context.state !== MONGOCRYPT_CTX_ERROR
<operator>.formatString("[context#", context.id, "] ", stateToString.get(context.state) || context.state, "")
context.state
case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO:
const filter = deserialize(context.nextMongoOperation())
!metaDataClient
throw new MongoCryptError(
              'unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined'
            );
"unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined"
const collInfo = await this.fetchCollectionInfo(metaDataClient, context.ns, filter)
context.addMongoOperationResponse(collInfo)
context.finishMongoOperation()
break;
case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS:
const command = context.nextMongoOperation()
!mongocryptdClient
throw new MongoCryptError(
              'unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined'
            );
"unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined"
const markedCommand: Uint8Array = mongocryptdManager
            ? await mongocryptdManager.withRespawn(
                this.markCommand.bind(this, mongocryptdClient, context.ns, command)
              )
            : await this.markCommand(mongocryptdClient, context.ns, command)
await mongocryptdManager.withRespawn(
                this.markCommand.bind(this, mongocryptdClient, context.ns, command)
              )
this.markCommand.bind(this, mongocryptdClient, context.ns, command)
await this.markCommand(mongocryptdClient, context.ns, command)
context.addMongoOperationResponse(markedCommand)
context.finishMongoOperation()
break;
case MONGOCRYPT_CTX_NEED_MONGO_KEYS:
const filter = context.nextMongoOperation()
const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter)
keys.length === 0
_tmp_14.v = __ecma.Array.factory()
_iterator_0 = <operator>.iterator(keys)
context.addMongoOperationResponse(serialize(key))
context.finishMongoOperation()
break;
case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS:
const kmsProviders = await executor.askForKMSCredentials()
context.provideKMSProviders(serialize(kmsProviders))
break;
case MONGOCRYPT_CTX_NEED_KMS:
const requests = Array.from(this.requests(context))
await Promise.all(requests)
context.finishKMSRequests()
break;
case MONGOCRYPT_CTX_READY:
const finalizedContext = context.finalize()
context.state === MONGOCRYPT_CTX_ERROR
const message = context.status.message || 'Finalization error'
throw new MongoCryptError(message);
result = deserialize(finalizedContext, this.options) as T
break;
default:
throw new MongoCryptError(`Unknown state: ${context.state}`);
