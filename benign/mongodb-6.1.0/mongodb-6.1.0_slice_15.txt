function parseOptions = function parseOptions(uri, mongoClient = undefined, options = {}) {
    if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
        options = mongoClient;
        mongoClient = undefined;
    }
    // validate BSONOptions
    if (options.useBigInt64 && typeof options.promoteLongs === 'boolean' && !options.promoteLongs) {
        throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
    }
    if (options.useBigInt64 && typeof options.promoteValues === 'boolean' && !options.promoteValues) {
        throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
    }
    const url = new mongodb_connection_string_url_1.default(uri);
    const { hosts, isSRV } = url;
    const mongoOptions = Object.create(null);
    // Feature flags
    for (const flag of Object.getOwnPropertySymbols(options)) {
        if (exports.FEATURE_FLAGS.has(flag)) {
            mongoOptions[flag] = options...
mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)
options = mongoClient
mongoClient = undefined
options.useBigInt64 && typeof options.promoteLongs === 'boolean' && !options.promoteLongs
throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
options.useBigInt64 && typeof options.promoteValues === 'boolean' && !options.promoteValues
throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
const url = new mongodb_connection_string_url_1.default(uri)
hosts = _tmp_29.hosts
const mongoOptions = Object.create(null)
_iterator_2 = <operator>.iterator(Object.getOwnPropertySymbols(options))
(_tmp_30 = exports.FEATURE_FLAGS).has
mongoOptions[flag] = options[flag]
mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString)
const urlOptions = new CaseInsensitiveMap()
url.pathname !== '/' && url.pathname !== ''
const dbName = decodeURIComponent(url.pathname[0] === '/' ? url.pathname.slice(1) : url.pathname)
urlOptions.set('dbName', [dbName])
url.username !== ''
const auth = {
            username: decodeURIComponent(url.username)
        }
_tmp_34.username = decodeURIComponent(url.username)
typeof url.password === 'string'
auth.password = decodeURIComponent(url.password)
_tmp_35 = __ecma.Array.factory()
_iterator_3 = <operator>.iterator(url.searchParams.keys())
const values = url.searchParams.getAll(key)
const isReadPreferenceTags = /readPreferenceTags/i.test(key)
!isReadPreferenceTags && values.length > 1
throw new error_1.MongoInvalidArgumentError(`URI option "${key}" cannot appear more than once in the connection string`);
!isReadPreferenceTags && values.includes('')
throw new error_1.MongoAPIError(`URI option "${key}" cannot be specified with no value`);
!urlOptions.has(key)
urlOptions.set(key, values)
const objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(([, v]) => v != null))
urlOptions.has('serverApi')
throw new error_1.MongoParseError('URI cannot contain `serverApi`, it can only be passed to the client');
const uriMechanismProperties = urlOptions.get('authMechanismProperties')
_iterator_4 = <operator>.iterator(uriMechanismProperties)
(_tmp_44 = /(^|,)ALLOWED_HOSTS:/).test
throw new error_1.MongoParseError('Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.');
objectOptions.has('loadBalanced')
throw new error_1.MongoParseError('loadBalanced is only a valid option in the URI');
const allProvidedOptions = new CaseInsensitiveMap()
const allProvidedKeys = new Set([...urlOptions.keys(), ...objectOptions.keys()])
_iterator_5 = <operator>.iterator(allProvidedKeys)
__ecma.Array.factory()
const objectOptionValue = objectOptions.get(key)
objectOptionValue != null
values.push(objectOptionValue)
const urlValues = urlOptions.get(key) ?? []
values.push(...urlValues)
allProvidedOptions.set(key, values)
allProvidedOptions.has('tls') || allProvidedOptions.has('ssl')
const tlsAndSslOpts = (allProvidedOptions.get('tls') || [])
            .concat(allProvidedOptions.get('ssl') || [])
            .map(getBoolean.bind(null, 'tls/ssl'))
allProvidedOptions.get('ssl') || []
