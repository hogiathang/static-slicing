function executeOperationAsync = async function executeOperationAsync(client, operation) {
    if (!(operation instanceof operation_1.AbstractOperation)) {
        // TODO(NODE-3483): Extend MongoRuntimeError
        throw new error_1.MongoRuntimeError('This method requires a valid operation instance');
    }
    if (client.topology == null) {
        // Auto connect on operation
        if (client.s.hasBeenClosed) {
            throw new error_1.MongoNotConnectedError('Client must be connected before running operations');
        }
        client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;
        try {
            await client.connect();
        }
        finally {
            delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];
        }
    }
    const { topology } = client;
    if (topology == null) {
        throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');
    }
    // The driver sessions spec mandates that we implicitly create ses...
!(operation instanceof operation_1.AbstractOperation)
throw new error_1.MongoRuntimeError('This method requires a valid operation instance');
client.topology == null
client.s.hasBeenClosed
throw new error_1.MongoNotConnectedError('Client must be connected before running operations');
client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true
await client.connect()
delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')]
topology = _tmp_2.topology
topology == null
throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');
let session = operation.session
session == null
owner = Symbol()
session = client.startSession({ owner, explicit: false })
session.hasEnded
throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');
session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads
throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');
session.client !== client
throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');
const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary
const inTransaction = !!session?.inTransaction()
inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)
throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);
session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck
session.unpin()
operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)
selector = (0, server_selection_1.sameServerSelector)(operation.server?.description)
operation.trySecondaryWrite
selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference)
selector = readPreference
const server = await topology.selectServerAsync(selector, { session })
session == null
operation.execute(server, undefined)
