function makeConnection = function makeConnection(options, _callback) {
    const useTLS = options.tls ?? false;
    const noDelay = options.noDelay ?? true;
    const connectTimeoutMS = options.connectTimeoutMS ?? 30000;
    const rejectUnauthorized = options.rejectUnauthorized ?? true;
    const existingSocket = options.existingSocket;
    let socket;
    const callback = function (err, ret) {
        if (err && socket) {
            socket.destroy();
        }
        _callback(err, ret);
    };
    if (options.proxyHost != null) {
        // Currently, only Socks5 is supported.
        return makeSocks5Connection({
            ...options,
            connectTimeoutMS // Should always be present for Socks5
        }, callback);
    }
    if (useTLS) {
        const tlsSocket = tls.connect(parseSslOptions(options));
        if (typeof tlsSocket.disableRenegotiation === 'function') {
            tlsSocket.disableRenegotiation();
        }
        socket = tlsSocket;
    }
    else if (existingSocket) {
    ...
const useTLS = options.tls ?? false
const noDelay = options.noDelay ?? true
const connectTimeoutMS = options.connectTimeoutMS ?? 30000
const rejectUnauthorized = options.rejectUnauthorized ?? true
const existingSocket = options.existingSocket
const callback = function (err, ret) {
        if (err && socket) {
            socket.destroy();
        }
        _callback(err, ret);
    }
options.proxyHost != null
const tlsSocket = tls.connect(parseSslOptions(options))
typeof tlsSocket.disableRenegotiation === 'function'
tlsSocket.disableRenegotiation()
socket = tlsSocket
socket = existingSocket
socket = net.createConnection(parseConnectOptions(options))
socket.setKeepAlive(true, 300000)
socket.setTimeout(connectTimeoutMS)
function errorHandler = function errorHandler(eventName) {
        return (err) => {
            SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));
            if (cancellationHandler && options.cancellationToken) {
                options.cancellationToken.removeListener('cancel', cancellationHandler);
            }
            socket.removeListener(connectEvent, connectHandler);
            callback(connectionFailureError(eventName, err));
        };
    }
function connectHandler = function connectHandler() {
        SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));
        if (cancellationHandler && options.cancellationToken) {
            options.cancellationToken.removeListener('cancel', cancellationHandler);
        }
        if ('authorizationError' in socket) {
            if (socket.authorizationError && rejectUnauthorized) {
                // TODO(NODE-5192): wrap this with a MongoError subclass
                return callback(socket.authorizationError);
            }
        }
        socket.setTimeout(0);
        callback(undefined, socket);
    }
