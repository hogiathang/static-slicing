function processWaitQueue = function processWaitQueue(topology: Topology) {
  if (topology.s.state === STATE_CLOSED) {
    drainWaitQueue(topology[kWaitQueue], new MongoTopologyClosedError());
    return;
  }

  const isSharded = topology.description.type === TopologyType.Sharded;
  const serverDescriptions = Array.from(topology.description.servers.values());
  const membersToProcess = topology[kWaitQueue].length;
  for (let i = 0; i < membersToProcess; ++i) {
    const waitQueueMember = topology[kWaitQueue].shift();
    if (!waitQueueMember) {
      continue;
    }

    if (waitQueueMember[kCancelled]) {
      continue;
    }

    let selectedDescriptions;
    try {
      const serverSelector = waitQueueMember.serverSelector;
      selectedDescriptions = serverSelector
        ? serverSelector(topology.description, serverDescriptions)
        : serverDescriptions;
    } catch (e) {
      if (waitQueueMember.timer) {
        clearTimeout(waitQueueMember.timer);
      }

      waitQueueMember.callback(e);
     ...
topology.s.state === STATE_CLOSED
const isSharded = topology.description.type === TopologyType.Sharded
const serverDescriptions = Array.from(topology.description.servers.values())
const membersToProcess = topology[kWaitQueue].length
i < membersToProcess
const waitQueueMember = topology[kWaitQueue].shift()
!waitQueueMember
continue;
waitQueueMember[kCancelled]
continue;
const serverSelector = waitQueueMember.serverSelector
selectedDescriptions = serverSelector
        ? serverSelector(topology.description, serverDescriptions)
        : serverDescriptions
serverSelector(topology.description, serverDescriptions)
waitQueueMember.timer
clearTimeout(waitQueueMember.timer)
waitQueueMember.callback(e)
continue;
selectedDescriptions.length === 0
topology[kWaitQueue].push(waitQueueMember)
continue;
selectedDescriptions.length === 1
selectedServer = topology.s.servers.get(selectedDescriptions[0].address)
const descriptions = shuffle(selectedDescriptions, 2)
const server1 = topology.s.servers.get(descriptions[0].address)
const server2 = topology.s.servers.get(descriptions[1].address)
selectedServer =
        server1 && server2 && server1.s.operationCount < server2.s.operationCount
          ? server1
          : server2
server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2
!selectedServer
const transaction = waitQueueMember.transaction
isSharded && transaction && transaction.isActive && selectedServer
transaction.pinServer(selectedServer)
waitQueueMember.timer
clearTimeout(waitQueueMember.timer)
waitQueueMember.callback(undefined, selectedServer)
