function prepareEventListenerParameters = function prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {
    const { type, name, target, phase, handler } = eventAst;
    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {
        throw new Error(`Unexpected global target '${target}' defined for '${name}' event.
        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);
    }
    const eventArgumentName = '$event';
    const implicitReceiverAccesses = new Set();
    const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?
        o.variable(CONTEXT_NAME) :
        scope.getOrCreateSharedContextVar(0);
    const bindingStatements = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);
    const statements = [];
    const variableDeclarations = scope?.variableDeclarations();
    const restoreViewStatement = scope?.restoreViewStatement();
    if (variableDeclaration...
handler = _tmp_32.handler
target && !GLOBAL_TARGET_RESOLVERS.has(target)
<operator>.formatString("Unexpected global target '", target, "' defined for '", name, "' event.
        Supported list of global targets: ", Array.from(GLOBAL_TARGET_RESOLVERS.keys()), ".")
Array.from(GLOBAL_TARGET_RESOLVERS.keys())
const eventArgumentName = '$event'
const implicitReceiverAccesses = new Set()
const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?
        o.variable(CONTEXT_NAME) :
        scope.getOrCreateSharedContextVar(0)
o.variable(CONTEXT_NAME)
scope.getOrCreateSharedContextVar(0)
const bindingStatements = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS)
__ecma.Array.factory()
const variableDeclarations = scope?.variableDeclarations()
const restoreViewStatement = scope?.restoreViewStatement()
statements.push(...variableDeclarations)
statements.push(...bindingStatements)
statements.unshift(restoreViewStatement)
const lastStatement = statements[statements.length - 1]
lastStatement instanceof o.ReturnStatement
statements[statements.length - 1] = new o.ReturnStatement(invokeInstruction(lastStatement.value.sourceSpan, R3.resetView, [lastStatement.value]))
statements.push(new o.ExpressionStatement(invokeInstruction(null, R3.resetView, [])))
const eventName = type === 1 /* ParsedEventType.Animation */ ? prepareSyntheticListenerName(name, phase) : name
const fnName = handlerName && sanitizeIdentifier(handlerName)
__ecma.Array.factory()
implicitReceiverAccesses.has(eventArgumentName)
fnArgs.push(new o.FnParam(eventArgumentName, o.DYNAMIC_TYPE))
const handlerFn = o.fn(fnArgs, statements, o.INFERRED_TYPE, null, fnName)
const params = [o.literal(eventName), handlerFn]
params.push(o.literal(false), // `useCapture` flag, defaults to `false`
        o.importExpr(GLOBAL_TARGET_RESOLVERS.get(target)))
o.importExpr(GLOBAL_TARGET_RESOLVERS.get(target))
