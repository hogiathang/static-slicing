constructor(config) {
    var _config$extensionASTN, _config$directives;

    // If this schema was built from a source known to be valid, then it may be
    // marked with assumeValid to avoid an additional type system validation.
    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.

    (0, _isObjectLike.isObjectLike)(config) ||
      (0, _devAssert.devAssert)(false, 'Must provide configuration object.');
    !config.types ||
      Array.isArray(config.types) ||
      (0, _devAssert.devAssert)(
        false,
        `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
          config.types,
        )}.`,
      );
    !config.directives ||
      Array.isArray(config.directives) ||
      (0, _devAssert.devAssert)(
        false,
        '"directives" must be Array if provided but got: ' +
          `${(0, _inspect.inspect)(config.directives)}.`,
      );
    this.descri...
this.__validationErrors = config.assumeValid === true ? [] : undefined
(0, _isObjectLike.isObjectLike)(config) ||
      (0, _devAssert.devAssert)(false, 'Must provide configuration object.')
(0, _devAssert.devAssert)(false, 'Must provide configuration object.')
!config.types ||
      Array.isArray(config.types) ||
      (0, _devAssert.devAssert)(
        false,
        `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
          config.types,
        )}.`,
      )
Array.isArray(config.types)
(0, _devAssert.devAssert)(
        false,
        `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
          config.types,
        )}.`,
      )
<operator>.formatString(""types" must be Array if provided but got: ", (0, _inspect.inspect)(
          config.types,
        ), ".")
config.types
!config.directives ||
      Array.isArray(config.directives) ||
      (0, _devAssert.devAssert)(
        false,
        '"directives" must be Array if provided but got: ' +
          `${(0, _inspect.inspect)(config.directives)}.`,
      )
Array.isArray(config.directives)
(0, _devAssert.devAssert)(
        false,
        '"directives" must be Array if provided but got: ' +
          `${(0, _inspect.inspect)(config.directives)}.`,
      )
'"directives" must be Array if provided but got: ' +
          `${(0, _inspect.inspect)(config.directives)}.`
<operator>.formatString("", (0, _inspect.inspect)(config.directives), ".")
this.description = config.description
this.extensions = (0, _toObjMap.toObjMap)(config.extensions)
this.astNode = config.astNode
this.extensionASTNodes =
      (_config$extensionASTN = config.extensionASTNodes) !== null &&
      _config$extensionASTN !== void 0
        ? _config$extensionASTN
        : []
(_config$extensionASTN = config.extensionASTNodes) !== null &&
      _config$extensionASTN !== void 0 ? _config$extensionASTN : __ecma.Array.factory()
_config$extensionASTN !== void 0
__ecma.Array.factory()
this._queryType = config.query
this._mutationType = config.mutation
this._subscriptionType = config.subscription
this._directives =
      (_config$directives = config.directives) !== null &&
      _config$directives !== void 0
        ? _config$directives
        : _directives.specifiedDirectives
(_config$directives = config.directives) !== null &&
      _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives
_config$directives !== void 0
_directives.specifiedDirectives
const allReferencedTypes = new Set(config.types)
config.types != null
_iterator_5 = <operator>.iterator(config.types)
allReferencedTypes.delete(type)
collectReferencedTypes(type, allReferencedTypes)
