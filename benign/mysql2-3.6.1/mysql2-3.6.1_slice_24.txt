constructor(opts) {
    super();
    this.config = opts.config;
    // TODO: fill defaults
    // if no params, connect to /var/lib/mysql/mysql.sock ( /tmp/mysql.sock on OSX )
    // if host is given, connect to host:3306
    // TODO: use `/usr/local/mysql/bin/mysql_config --socket` output? as default socketPath
    // if there is no host/port and no socketPath parameters?
    if (!opts.config.stream) {
      if (opts.config.socketPath) {
        this.stream = Net.connect(opts.config.socketPath);
      } else {
        this.stream = Net.connect(
          opts.config.port,
          opts.config.host
        );

        // Optionally enable keep-alive on the socket.
        if (this.config.enableKeepAlive) {
          this.stream.on('connect', () => {
            this.stream.setKeepAlive(true, this.config.keepAliveInitialDelay);
          });
        }

        // Enable TCP_NODELAY flag. This is needed so that the network packets
        // are sent immediately to the server
       ...
super()
this.config = opts.config
!opts.config.stream
opts.config.socketPath
this.stream = Net.connect(opts.config.socketPath)
this.stream = Net.connect(
          opts.config.port,
          opts.config.host
        )
opts.config.port
opts.config.host
this.config.enableKeepAlive
this.stream.on('connect', () => {
            this.stream.setKeepAlive(true, this.config.keepAliveInitialDelay);
          })
(_tmp_2 = this.stream).setNoDelay
typeof opts.config.stream === 'function'
this.stream = opts.config.stream(opts)
this.stream = opts.config.stream
this._internalId = _connectionId++
this._commands = new Queue()
this._command = null
this._paused = false
this._paused_packets = new Queue()
this._statements = new LRU({
      max: this.config.maxPreparedStatements,
      dispose: function(statement) {
        statement.close();
      }
    })
_tmp_7.max = this.config.maxPreparedStatements
_tmp_7.dispose = <lambda>1
this.serverCapabilityFlags = 0
this.authorized = false
this.sequenceId = 0
this.compressedSequenceId = 0
this.threadId = null
this._handshakePacket = null
this._fatalError = null
this._protocolError = null
this._outOfOrderPackets = []
this.clientEncoding = CharsetToEncoding[this.config.charsetNumber]
this.stream.on('error', this._handleNetworkError.bind(this))
this.packetParser = new PacketParser(p => {
      this.handlePacket(p);
    })
this.stream.on('data', data => {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      this.packetParser.execute(data);
    })
this.stream.on('end', () => {
      // emit the end event so that the pooled connection can close the connection
      this.emit('end');
    })
this.stream.on('close', () => {
      // we need to set this flag everywhere where we want connection to close
      if (this._closing) {
        return;
      }
      if (!this._protocolError) {
        // no particular error message before disconnect
        this._protocolError = new Error(
          'Connection lost: The server closed the connection.'
        );
        this._protocolError.fatal = true;
        this._protocolError.code = 'PROTOCOL_CONNECTION_LOST';
      }
      this._notifyError(this._protocolError);
    })
!this.config.isServer
handshakeCommand = new Commands.ClientHandshake(this.config.clientFlags)
handshakeCommand.on('end', () => {
        // this happens when handshake finishes early either because there was
        // some fatal error or the server sent an error packet instead of
        // an hello packet (for example, 'Too many connections' error)
        if (!handshakeCommand.handshake || this._fatalError || this._protocolError) {
          return;
        }
        this._handshakePacket = handshakeCommand.handshake;
        this.threadId = handshakeCommand.handshake.connectionId;
        this.emit('connect', handshakeCommand.handshake);
      })
handshakeCommand.on('error', err => {
        this._closing = true;
        this._notifyError(err);
      })
this.addCommand(handshakeCommand)
this.serverEncoding = 'utf8'
this.config.connectTimeout
const timeoutHandler = this._handleTimeoutError.bind(this)
this.connectTimeout = Timers.setTimeout(
        timeoutHandler,
        this.config.connectTimeout
      )
this.config.connectTimeout
