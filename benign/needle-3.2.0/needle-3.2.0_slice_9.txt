request = protocol.request(request_opts, function(resp) {

    var headers = resp.headers;
    debug('Got response', resp.statusCode, headers);
    out.emit('response', resp);

    set_timeout('read', config.read_timeout);

    // if we got cookies, parse them unless we were instructed not to. make sure to include any
    // cookies that might have been set on previous redirects.
    if (config.parse_cookies && (headers['set-cookie'] || config.previous_resp_cookies)) {
      resp.cookies = extend(config.previous_resp_cookies || {}, cookies.read(headers['set-cookie']));
      debug('Got cookies', resp.cookies);
    }

    // if redirect code is found, determine if we should follow it according to the given options.
    if (redirect_codes.indexOf(resp.statusCode) !== -1 && self.should_follow(headers.location, config, uri)) {
      // clear timer before following redirects to prevent unexpected setTimeout consequence
      clearTimeout(timer);

      if (count <= config.follow_max) {
 ...
var headers = resp.headers
debug('Got response', resp.statusCode, headers)
out.emit('response', resp)
set_timeout('read', config.read_timeout)
config.parse_cookies && (headers['set-cookie'] || config.previous_resp_cookies)
resp.cookies = extend(config.previous_resp_cookies || {}, cookies.read(headers['set-cookie']))
debug('Got cookies', resp.cookies)
redirect_codes.indexOf(resp.statusCode) !== -1 && self.should_follow(headers.location, config, uri)
clearTimeout(timer)
count <= config.follow_max
config.follow_max > 0
resp.statusCode == 401 && headers['www-authenticate'] && config.credentials
!config.headers['authorization']
var auth_header = auth.header(headers['www-authenticate'], config.credentials, request_opts)
out.emit('header', resp.statusCode, headers)
out.emit('headers', headers)
var pipeline      = []
var mime          = utils.parse_content_type(headers['content-type'])
var text_response = mime.type && (mime.type.indexOf('text/') != -1 || !!mime.type.match(/(\/|\+)(xml|json)$/))
headers['content-encoding'] && decompressors[headers['content-encoding']]
var decompressor = decompressors[headers['content-encoding']]()
decompressor.on('error', had_error)
pipeline.push(decompressor)
config.parser && parsers[mime.type]
var parser_name = config.parser.toString().toLowerCase()
['xml', 'json'].indexOf(parser_name) == -1 || parsers[mime.type].name == parser_name
out.parser = parsers[mime.type].name
pipeline.push(parsers[mime.type].fn())
out._writableState.objectMode = true
out._readableState.objectMode = true
text_response && config.decode_response && mime.charset
pipeline.push(decoder(mime.charset))
pipeline.push(out)
utils.pump_streams([resp].concat(pipeline), function(err) {
      if (err) debug(err)

      // on node v8.x, if an error ocurrs on the receiving end,
      // then we want to abort the request to avoid having dangling sockets
      if (err && err.message == 'write after end') request.destroy();
    })
config.output && resp.statusCode == 200
var file = fs.createWriteStream(config.output)
