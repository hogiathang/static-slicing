const dox = require(`dox`)
const fs = require(`fs`)
mapValues = _tmp_22.mapValues
const path = require(`path`)
const SOURCE_FILE = path.join(__dirname, `..`, `mixpanel.js`)
const TEMPLATE_FILE = path.join(__dirname, `template.md`)
const OUTPUT_FILE = path.join(__dirname, `readme.io`, `javascript-full-api-reference.md`)
const NAMESPACES = {
  MixpanelLib: `mixpanel`,
  MixpanelPeople: `mixpanel.people`,
  MixpanelGroup: `mixpanel.group`,
}
_tmp_23.MixpanelLib = "mixpanel"
_tmp_23.MixpanelPeople = "mixpanel.people"
_tmp_23.MixpanelGroup = "mixpanel.group"
const DESCRIPTION_REGEXES = {
  description: /([\S\s]+?)(<h3>|$)/,
  usage: /<h3>Usage:<\/h3>([\S\s]+?)(<h3>|$)/,
  notes: /<h3>Notes:<\/h3>([\S\s]+?)(<h3>|$)/,
}
_tmp_24.description = /([\S\s]+?)(<h3>|$)/
_tmp_24.usage = /<h3>Usage:<\/h3>([\S\s]+?)(<h3>|$)/
_tmp_24.notes = /<h3>Notes:<\/h3>([\S\s]+?)(<h3>|$)/
function parseDescriptionAttrs = function parseDescriptionAttrs(html) {
  return mapValues(DESCRIPTION_REGEXES, regex => {
    const match = html.match(regex);
    return match && match[1]
      .trim()
      .replace(/<br \/>/g, ` `)
      .replace(/<p>([\S\s]+?)<\/p>/g, (str, match) => match.replace(/\n/g, ` `) + `\n`)
      .replace(/<pre><code>([\s\S]+?)<\/code><\/pre>/g, '\n```javascript\n$1\n```\n')
      ;
  });
}
function stripPTags = function stripPTags(str) {
  return str.replace(/<p>([\S\s]+?)<\/?p>/g, `$1`);
}
function isDeprecated = function isDeprecated(item) {
  return item.tags.find(tag => tag.type === `deprecated`);
}
function doxToMD = function doxToMD(items) {
  const renderMD = template(fs.readFileSync(TEMPLATE_FILE).toString());
  return renderMD({
    namespaces: Object.entries(NAMESPACES).map(([constructor, namespace]) => ({
      name: namespace,
      items: items

        // filter down to public methods of the current namespace/class
        .filter(item =>
          !item.isPrivate &&
          item.ctx &&
          !item.ctx.name.startsWith(`_`) &&
          item.ctx.constructor === constructor &&
          !isDeprecated(item)
        )

        // sort by method name within each namespace
        .sort((a, b) => a.ctx.name > b.ctx.name ? 1 : -1)

        // transform each method's data into the format we want (for instance stripping out
        // <p> tags and adding a `required` field rather than [] around param names)
        .map(item => ({
          name: `${namespace}.${item.ctx.name}`,
          arguments: item.tags
            .filter(arg => !!arg.name)
            .map(arg => ({
              n...
dox.contextPatternMatchers.push(function (str) {
  if (/^\s*([\w$.]+)\s*\.\s*prototype\s*\['\s*([\w$]+)'\]\s*=\s*([^\n;]+)/.exec(str)) {
    return {
        type: 'property'
      , constructor: RegExp.$1
      , cons: RegExp.$1
      , name: RegExp.$2
      , value: RegExp.$3.trim()
      , string: RegExp.$1 + '.prototype.' + RegExp.$2
    };
  }
})
const rawCode = fs.readFileSync(SOURCE_FILE).toString().trim()
const parsed = dox.parseComments(rawCode)
fs.writeFileSync(OUTPUT_FILE, doxToMD(parsed))
