this.parent.acquire(this, (err, connection, config) => {
        if (err) return callback(err)

        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))

        let row

        if (this.canceled) {
          debug('request(%d): canceled', IDS.get(this))
          this.parent.release(connection)
          return callback(new RequestError('Canceled.', 'ECANCEL'))
        }

        this._cancel = () => {
          debug('request(%d): cancel', IDS.get(this))
          connection.cancel()
        }

        // attach handler to handle multiple error messages
        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)
        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))
        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))

        if (debug.enabled) {
          // log stored procedure executions and provided parameters
          const p...
debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))
this.canceled
this._cancel = () => {
          debug('request(%d): cancel', IDS.get(this))
          connection.cancel()
        }
connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)
connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))
connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))
debug.enabled
const params = Object.keys(this.parameters).map(k => this.parameters[k])
const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s
const logName = param => param.name + ' [sql.' + param.type.name + ']'
const logParams = {}
params.forEach(p => { logParams[logName(p)] = logValue(p.value) })
debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams)
