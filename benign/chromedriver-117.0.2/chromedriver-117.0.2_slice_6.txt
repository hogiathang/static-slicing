const fs = require('node:fs')
const helper = require('./lib/chromedriver')
const axios = require('axios')
const path = require('node:path')
const child_process = require('node:child_process')
const os = require('node:os')
const url = require('node:url')
const https = require('node:https')
_tmp_40 = require('node:util')
_tmp_41 = require('node:stream')
const extractZip = require('extract-zip')
_tmp_42 = require('@testim/chrome-version')
const HttpsProxyAgent = require('https-proxy-agent')
const getProxyForUrl = require("proxy-from-env").getProxyForUrl
compareVersions = _tmp_43.compareVersions
const finishedAsync = promisify(finished)
const skipDownload = (process.env.npm_config_chromedriver_skip_download || process.env.CHROMEDRIVER_SKIP_DOWNLOAD) === 'true'
console.log('Found CHROMEDRIVER_SKIP_DOWNLOAD variable, skipping installation.')
process.exit(0)
function getPlatform = function getPlatform(chromedriverVersion) {
  const thePlatform = process.platform;
  if (thePlatform === 'linux') {
    if (process.arch === 'arm64' || process.arch === 's390x' || process.arch === 'x64') {
      return 'linux64';
    } else {
      console.log('Only Linux 64 bits supported.');
      process.exit(1);
    }
  } else if (thePlatform === 'darwin' || thePlatform === 'freebsd') {
    const osxPlatform = getMacOsRealArch(chromedriverVersion);

    if (!osxPlatform) {
      console.log('Only Mac 64 bits supported.');
      process.exit(1);
    }

    return osxPlatform;
  } else if (thePlatform === 'win32') {
    if (compareVersions(chromedriverVersion, '115') < 0) {
      return 'win32';
    }
    return (process.arch === 'x64') ? 'win64' : 'win32';
  }

  console.log('Unexpected platform or architecture:', process.platform, process.arch);
  process.exit(1);
}
function downloadFile = async function downloadFile(cdnUrl, useLegacyDownloadMethod, downloadedFile, chromedriverVersion, platform) {
  const configuredfilePath = process.env.npm_config_chromedriver_filepath || process.env.CHROMEDRIVER_FILEPATH;
  if (configuredfilePath) {
    console.log('Using file: ', configuredfilePath);
    return configuredfilePath;
  } else {
    const fileName = path.basename(downloadedFile);
    if (useLegacyDownloadMethod) {
      const formattedDownloadUrl = `${cdnUrl}/${chromedriverVersion}/${fileName}`;
      console.log('Downloading from file: ', formattedDownloadUrl);
      await requestBinary(getRequestOptions(formattedDownloadUrl), downloadedFile);
    } else {
      const formattedDownloadUrl = `${cdnUrl}/${chromedriverVersion}/${platform}/${fileName}`;
      console.log('Downloading from file: ', formattedDownloadUrl);
      await requestBinary(getRequestOptions(formattedDownloadUrl), downloadedFile);
    }
    return downloadedFile;
  }
}
function getDownloadFilePath = function getDownloadFilePath(useLegacyPath, dirToLoadTo, platform) {
  const fileName = useLegacyPath ? `chromedriver_${platform}.zip` : `chromedriver-${platform}.zip`;
  const downloadedFile = path.resolve(dirToLoadTo, fileName);
  console.log('Saving to file:', downloadedFile);
  return downloadedFile;
}
function verifyIfChromedriverIsAvailableAndHasCorrectVersion = function verifyIfChromedriverIsAvailableAndHasCorrectVersion(chromedriverVersion, chromedriverBinaryFilePath) {
  if (!fs.existsSync(chromedriverBinaryFilePath))
    return Promise.resolve(false);
  const forceDownload = process.env.npm_config_chromedriver_force_download === 'true' || process.env.CHROMEDRIVER_FORCE_DOWNLOAD === 'true';
  if (forceDownload)
    return Promise.resolve(false);
  console.log('ChromeDriver binary exists. Validating...');
  const deferred = new Deferred();
  try {
    fs.accessSync(chromedriverBinaryFilePath, fs.constants.X_OK);
    const cp = child_process.spawn(chromedriverBinaryFilePath, ['--version']);
    let str = '';
    cp.stdout.on('data', data => str += data);
    cp.on('error', () => deferred.resolve(false));
    cp.on('close', code => {
      if (code !== 0)
        return deferred.resolve(false);
      const parts = str.split(' ');
      if (parts.length < 3)
        return deferred.resolve(false);
      if (parts[1].startsWith(chromedriverVe...
function findSuitableTempDirectory = function findSuitableTempDirectory(chromedriverVersion) {
  const now = Date.now();
  const candidateTmpDirs = [
    process.env.npm_config_tmp,
    process.env.XDG_CACHE_HOME,
    // Platform specific default, including TMPDIR/TMP/TEMP env
    os.tmpdir(),
    path.join(process.cwd(), 'tmp')
  ];

  for (const tempDir of candidateTmpDirs) {
    if (!tempDir) continue;
    const namespace = chromedriverVersion;
    const candidatePath = path.join(tempDir, namespace, 'chromedriver');
    try {
      fs.mkdirSync(candidatePath, { recursive: true });
      const testFile = path.join(candidatePath, now + '.tmp');
      fs.writeFileSync(testFile, 'test');
      fs.unlinkSync(testFile);
      return candidatePath;
    } catch (e) {
      console.log(candidatePath, 'is not writable:', e.message);
    }
  }
  console.error('Can not find a writable tmp directory, please report issue on https://github.com/giggio/chromedriver/issues/ with as much information as possible.');
  process.exit(1);
}
function getRequestOptions = function getRequestOptions(downloadPath) {
  /** @type import('axios').AxiosRequestConfig */
  const options = { url: downloadPath, method: "GET" };
  const urlParts = url.parse(downloadPath);
  const isHttps = urlParts.protocol === 'https:';
  const proxyUrl = getProxyForUrl(downloadPath);

  if (proxyUrl) {
    const proxyUrlParts = url.parse(proxyUrl);
    if (proxyUrlParts.hostname && proxyUrlParts.protocol)
      options.proxy = {
        host: proxyUrlParts.hostname,
        port: proxyUrlParts.port ? parseInt(proxyUrlParts.port) : 80,
        protocol: proxyUrlParts.protocol
      };
  }

  if (isHttps) {
    // Use certificate authority settings from npm
    let ca = process.env.npm_config_ca;
    if (ca)
      console.log('Using npmconf ca.');

    if (!ca && process.env.npm_config_cafile) {
      try {
        ca = fs.readFileSync(process.env.npm_config_cafile, { encoding: 'utf8' });
      } catch (e) {
        console.error('Could not read cafile', process.env.npm_config_...
function getChromeDriverVersion = async function getChromeDriverVersion(cdnUrl, legacyCdnUrl, majorVersion) {
  if (majorVersion == null || majorVersion > 114) {
    console.log('Finding Chromedriver version.');
    let chromedriverVersion;
    if (majorVersion) {
      const requestOptions = getRequestOptions(`${cdnUrl}/chrome-for-testing/latest-versions-per-milestone.json`);
      // @ts-expect-error
      const response = await axios.request(requestOptions);
      chromedriverVersion = response.data?.milestones[majorVersion.toString()]?.version;
    } else {
      const requestOptions = getRequestOptions(`${cdnUrl}/chrome-for-testing/last-known-good-versions.json`);
      // @ts-expect-error
      const response = await axios.request(requestOptions);
      chromedriverVersion = response.data?.channels?.Stable?.version;
    }
    console.log(`Chromedriver version is ${chromedriverVersion}.`);
    return chromedriverVersion;
  } else {
    console.log('Finding Chromedriver version using legacy method.');
    const ...
function requestBinary = async function requestBinary(requestOptions, filePath) {
  const outFile = fs.createWriteStream(filePath);
  let response;
  try {
    // @ts-expect-error
    response = await axios.request({ responseType: 'stream', ...requestOptions });
  } catch (error) {
    if (error && error.response) {
      if (error.response.status)
        console.error('Error status code:', error.response.status);
      if (error.response.data) {
        error.response.data.on('data', data => console.error(data.toString('utf8')));
        try {
          await finishedAsync(error.response.data);
        } catch (error) {
          console.error('Error downloading entire response:', error);
        }
      }
    }
    throw new Error('Error with http(s) request: ' + error);
  }
  let count = 0;
  let notifiedCount = 0;
  response.data.on('data', data => {
    count += data.length;
    if ((count - notifiedCount) > 1024 * 1024) {
      console.log('Received ' + Math.floor(count / 1024) + 'K...');
      notif...
function extractDownload = async function extractDownload(dirToExtractTo, chromedriverBinaryFilePath, downloadedFile) {
  if (path.extname(downloadedFile) !== '.zip') {
    fs.copyFileSync(downloadedFile, chromedriverBinaryFilePath);
    console.log('Skipping zip extraction - binary file found.');
    return;
  }
  console.log(`Extracting zip contents to ${dirToExtractTo}.`);
  try {
    await extractZip(path.resolve(downloadedFile), { dir: dirToExtractTo });
  } catch (error) {
    throw new Error('Error extracting archive: ' + error);
  }
}
function copyIntoPlace = async function copyIntoPlace(originPath, targetPath) {
  fs.rmSync(targetPath, { recursive: true, force: true });
  console.log(`Copying from ${originPath} to target path ${targetPath}`);
  fs.mkdirSync(targetPath);

  // Look for the extracted directory, so we can rename it.
  const files = fs.readdirSync(originPath, { withFileTypes: true })
    .filter(dirent => dirent.isFile() && dirent.name.startsWith('chromedriver') && !dirent.name.endsWith(".debug") && !dirent.name.endsWith(".zip"))
    .map(dirent => dirent.name);
  const promises = files.map(name => {
    return /** @type {Promise<void>} */(new Promise((resolve) => {
      const file = path.join(originPath, name);
      const reader = fs.createReadStream(file);
      const targetFile = path.join(targetPath, name);
      const writer = fs.createWriteStream(targetFile);
      writer.on("close", () => resolve());
      reader.pipe(writer);
    }));
  });
  await Promise.all(promises);
}
function fixFilePermissions = function fixFilePermissions() {
  // Check that the binary is user-executable and fix it if it isn't (problems with unzip library)
  if (process.platform != 'win32') {
    const stat = fs.statSync(helper.path);
    // 64 == 0100 (no octal literal in strict mode)
    if (!(stat.mode & 64)) {
      console.log('Fixing file permissions.');
      fs.chmodSync(helper.path, '755');
    }
  }
}
function getMacOsRealArch = function getMacOsRealArch(chromedriverVersion) {
  if (process.arch === 'arm64' || isEmulatedRosettaEnvironment()) {
    return compareVersions(chromedriverVersion, '106.0.5249.61') < 0
      ? 'mac64_m1'
      : compareVersions(chromedriverVersion, '115') < 0 ? 'mac_arm64' : 'mac-arm64';
  }

  if (process.arch === 'x64') {
    return compareVersions(chromedriverVersion, '115') < 0 ? 'mac64' : 'mac-x64';
  }

  return null;
}
function isEmulatedRosettaEnvironment = function isEmulatedRosettaEnvironment() {
  const archName = child_process.spawnSync('uname', ['-m']).stdout.toString().trim();

  if (archName === 'x86_64') {
    const proc = child_process.spawnSync('sysctl', ['-in', 'sysctl.proc_translated']);

    // When run with `-in`, the return code is 0 even if there is no `sysctl.proc_translated`
    if (proc.status) {
      throw new Error('Unexpected return code from sysctl: ' + proc.status);
    }

    // If there is no `sysctl.proc_translated` (i.e. not rosetta) then nothing is printed to
    // stdout
    if (!proc.stdout) {
      return false;
    }

    const processTranslated = proc.stdout.toString().trim();

    return processTranslated === '1';
  }

  return false;
}
function Deferred = function Deferred() {
  this.resolve = null;
  this.reject = null;
  this.promise = new Promise(function (resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  }.bind(this));
  Object.freeze(this);
}
