module.exports = function main(source, outDir, args) {
    //--------------------------------------------------------------------------
    // Resolve Command.
    var commands = [].concat(args.command).filter(Boolean).map(function (command) {
        if (typeof command !== "string") {
            console.error("Invalid --command option");
            process.exit(1);
        }

        return function (file) {
            var env = (0, _create2.default)(process.env, { FILE: { value: file } });
            var parts = parseShellQuote(command, env);
            var child = spawn(parts[0], parts.slice(1), { env: env });
            var outer = duplexer(child.stdin, child.stdout);
            child.on("exit", function (code) {
                if (code !== 0) {
                    var error = new Error("non-zero exit code in command: " + command);
                    outer.emit("error", error);
                }
            });
            child.stderr.pipe(process.stderr);

           ...
var commands = [].concat(args.command).filter(Boolean).map(function (command) {
        if (typeof command !== "string") {
            console.error("Invalid --command option");
            process.exit(1);
        }

        return function (file) {
            var env = (0, _create2.default)(process.env, { FILE: { value: file } });
            var parts = parseShellQuote(command, env);
            var child = spawn(parts[0], parts.slice(1), { env: env });
            var outer = duplexer(child.stdin, child.stdout);
            child.on("exit", function (code) {
                if (code !== 0) {
                    var error = new Error("non-zero exit code in command: " + command);
                    outer.emit("error", error);
                }
            });
            child.stderr.pipe(process.stderr);

            return outer;
        };
    })
var ABS_OR_REL = /^[.\/]/
var transforms = [].concat(args.transform).filter(Boolean).map(function (arg) {
        // eslint-disable-line array-callback-return,consistent-return
        if (typeof arg === "string") {
            return { name: arg, argv: null };
        }
        if (typeof arg._[0] === "string") {
            return { name: arg._.shift(), argv: arg };
        }

        console.error("Invalid --transform option");
        process.exit(1);
    }).map(function (item) {
        var createStream = ABS_OR_REL.test(item.name) ? require(resolvePath(item.name)) : require(resolveModule(item.name, { basedir: process.cwd() }));
        return function (file) {
            return createStream(file, item.argv);
        };
    })
<lambda>4
var C_OR_COMMAND = /^(?:-c|--command)$/
var T_OR_TRANSFORM = /^(?:-t|--transform)$/
var mergedTransformFactories = process.argv.map(function (part) {
        if (C_OR_COMMAND.test(part)) {
            return commands.shift();
        }
        if (T_OR_TRANSFORM.test(part)) {
            return transforms.shift();
        }
        return null;
    }).filter(Boolean)
filter
var cpx = new Cpx(source, outDir, {
        transform: mergedTransformFactories,
        dereference: args.dereference,
        includeEmptyDirs: args.includeEmptyDirs,
        initialCopy: args.initial,
        preserve: args.preserve,
        update: args.update
    })
_tmp_20.transform = mergedTransformFactories
_tmp_20.dereference = args.dereference
_tmp_20.includeEmptyDirs = args.includeEmptyDirs
_tmp_20.initialCopy = args.initial
_tmp_20.preserve = args.preserve
_tmp_20.update = args.update
args.verbose
cpx.on("copy", function (event) {
            console.log("Copied: " + event.srcPath + " --> " + event.dstPath);
        })
cpx.on("remove", function (event) {
            console.log("Removed: " + event.path);
        })
args.clean
args.verbose
console.log()
console.log("Clean: " + cpx.src2dst(cpx.source))
console.log()
cpx.cleanSync()
console.error("Failed to clean: " + err.message + ".")
process.exit(1)
