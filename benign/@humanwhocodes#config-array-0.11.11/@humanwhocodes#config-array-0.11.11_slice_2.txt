getConfig(filePath) {

		assertNormalized(this);

		const cache = this[ConfigArraySymbol.configCache];

		// first check the cache for a filename match to avoid duplicate work
		let finalConfig = cache.get(filePath);

		if (finalConfig) {
			return finalConfig;
		}

		// next check to see if the file should be ignored

		// check if this should be ignored due to its directory
		if (this.isDirectoryIgnored(path.dirname(filePath))) {
			debug(`Ignoring ${filePath} based on directory pattern`);

			// cache and return result - finalConfig is undefined at this point
			cache.set(filePath, finalConfig);
			return finalConfig;
		}

		// TODO: Maybe move elsewhere?
		const relativeFilePath = path.relative(this.basePath, filePath);

		if (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {
			debug(`Ignoring ${filePath} based on file pattern`);

			// cache and return result - finalConfig is undefined at this point
			cache.set(filePath, finalConfig);
			return finalConfig;
		}

	...
assertNormalized(this)
const cache = this[ConfigArraySymbol.configCache]
let finalConfig = cache.get(filePath)
this.isDirectoryIgnored(path.dirname(filePath))
const relativeFilePath = path.relative(this.basePath, filePath)
shouldIgnorePath(this.ignores, filePath, relativeFilePath)
const matchingConfigIndices = []
let matchFound = false
const universalPattern = /\/\*{1,2}$/
this.forEach((config, index) => {

			if (!config.files) {

				if (!config.ignores) {
					debug(`Anonymous universal config found for ${filePath}`);
					matchingConfigIndices.push(index);
					return;
				}

				if (pathMatchesIgnores(filePath, this.basePath, config)) {
					debug(`Matching config found for ${filePath} (based on ignores: ${config.ignores})`);
					matchingConfigIndices.push(index);
					return;
				}
				
				debug(`Skipped config found for ${filePath} (based on ignores: ${config.ignores})`);
				return;
			}

			/*
			 * If a config has a files pattern ending in /** or /*, and the
			 * filePath only matches those patterns, then the config is only
			 * applied if there is another config where the filePath matches
			 * a file with a specific extensions such as *.js.
			 */

			const universalFiles = config.files.filter(
				pattern => universalPattern.test(pattern)
			);

			// universal patterns were found so we need to check the config twice
			if (universalF...
!matchFound
finalConfig = cache.get(matchingConfigIndices.toString())
