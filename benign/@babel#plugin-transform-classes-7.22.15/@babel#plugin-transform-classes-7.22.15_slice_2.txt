function verifyConstructor = function verifyConstructor() {
    if (!classState.isDerived) return;
    const path = classState.userConstructorPath;
    const body = path.get("body");
    path.traverse(findThisesVisitor);
    let thisRef = function () {
      const ref = path.scope.generateDeclaredUidIdentifier("this");
      thisRef = () => _core.types.cloneNode(ref);
      return ref;
    };
    for (const thisPath of classState.superThises) {
      const {
        node,
        parentPath
      } = thisPath;
      if (parentPath.isMemberExpression({
        object: node
      })) {
        thisPath.replaceWith(thisRef());
        continue;
      }
      thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [thisRef()]));
    }
    const bareSupers = [];
    path.traverse(_core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {
      Super(path) {
        const {
          node,
          parentPath
        } = path;
        if (parentPath.isCallExpressi...
!classState.isDerived
const path = classState.userConstructorPath
const body = path.get("body")
path.traverse(findThisesVisitor)
let thisRef = function () {
      const ref = path.scope.generateDeclaredUidIdentifier("this");
      thisRef = () => _core.types.cloneNode(ref);
      return ref;
    }
_iterator_4 = <operator>.iterator(classState.superThises)
_tmp_66 = thisPath
node = _tmp_66.node
parentPath = _tmp_66.parentPath
parentPath.isMemberExpression({
        object: node
      })
_tmp_67.object = node
thisPath.replaceWith(thisRef())
continue;
thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [thisRef()]))
__ecma.Array.factory()
path.traverse(_core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {
      Super(path) {
        const {
          node,
          parentPath
        } = path;
        if (parentPath.isCallExpression({
          callee: node
        })) {
          bareSupers.unshift(parentPath);
        }
      }
    }]))
_tmp_73.Super = Super
let guaranteedSuperBeforeFinish = !!bareSupers.length
_iterator_5 = <operator>.iterator(bareSupers)
wrapSuperCall(bareSuper, classState.superName, thisRef, body)
bareSuper.find(function (parentPath) {
          if (parentPath === path) {
            return true;
          }
          if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
            guaranteedSuperBeforeFinish = false;
            return true;
          }
        })
classState.isLoose
wrapReturn = returnArg => {
        const thisExpr = _core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [thisRef()]);
        return returnArg ? _core.types.logicalExpression("||", returnArg, thisExpr) : thisExpr;
      }
wrapReturn = returnArg => {
        const returnParams = [thisRef()];
        if (returnArg != null) {
          returnParams.push(returnArg);
        }
        return _core.types.callExpression(classState.file.addHelper("possibleConstructorReturn"), returnParams);
      }
const bodyPaths = body.get("body")
