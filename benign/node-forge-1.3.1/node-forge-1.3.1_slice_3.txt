pem.decode = function(str) {
  var rval = [];

  // split string into PEM messages (be lenient w/EOF on BEGIN line)
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match;
  while(true) {
    match = rMessage.exec(str);
    if(!match) {
      break;
    }

    // accept "NEW CERTIFICATE REQUEST" as "CERTIFICATE REQUEST"
    // https://datatracker.ietf.org/doc/html/rfc7468#section-7
    var type = match[1];
    if(type === 'NEW CERTIFICATE REQUEST') {
      type = 'CERTIFICATE REQUEST';
    }

    var msg = {
      type: type,
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge.util.decode64(match[3])
    };
    rval.push(msg);

    // no headers
    if(!match[2]) {
      continue;
    }

    // parse headers
    var lines = match[2].split(rCRLF);
    var li = 0;
   ...
__ecma.Array.factory()
var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g
var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/
var rCRLF = /\r?\n/
match = rMessage.exec(str)
!match
var type = match[1]
type === 'NEW CERTIFICATE REQUEST'
type = 'CERTIFICATE REQUEST'
var msg = {
      type: type,
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge.util.decode64(match[3])
    }
_tmp_11.type = type
_tmp_11.procType = null
_tmp_11.contentDomain = null
_tmp_11.dekInfo = null
_tmp_11.headers = __ecma.Array.factory()
_tmp_11.body = forge.util.decode64(match[3])
rval.push(msg)
!match[2]
continue;
var lines = match[2].split(rCRLF)
var li = 0
match && li < lines.length
var line = lines[li].replace(/\s+$/, '')
nl < lines.length
var next = lines[nl]
(_tmp_15 = /\s/).test
break;
line += next
li = nl
match = line.match(rHeader)
var header = {name: match[1], values: []}
var values = match[2].split(',')
vi < values.length
header.values.push(ltrim(values[vi]))
!msg.procType
header.name !== 'Proc-Type'
throw new Error('Invalid PEM formatted message. The first ' +
              'encapsulated header must be "Proc-Type".');
"encapsulated header must be "Proc-Type"."
header.values.length !== 2
throw new Error('Invalid PEM formatted message. The "Proc-Type" ' +
              'header must have two subfields.');
"header must have two subfields."
msg.procType = {version: values[0], type: values[1]}
!msg.contentDomain && header.name === 'Content-Domain'
msg.contentDomain = values[0] || ''
!msg.dekInfo && header.name === 'DEK-Info'
header.values.length === 0
throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
              'header must have at least one subfield.');
"header must have at least one subfield."
msg.dekInfo = {algorithm: values[0], parameters: values[1] || null}
(_tmp_24 = msg.headers).push
++li
msg.procType === 'ENCRYPTED' && !msg.dekInfo
throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
        'header must be present if "Proc-Type" is "ENCRYPTED".');
"header must be present if "Proc-Type" is "ENCRYPTED"."
