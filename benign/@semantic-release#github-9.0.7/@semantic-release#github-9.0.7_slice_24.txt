function success = async function success(pluginConfig, context, { Octokit }) {
  const {
    options: { repositoryUrl },
    commits,
    nextRelease,
    releases,
    logger,
  } = context;
  const {
    githubToken,
    githubUrl,
    githubApiPathPrefix,
    proxy,
    successComment,
    failComment,
    failTitle,
    releasedLabels,
    addReleases,
  } = resolveConfig(pluginConfig, context);

  const octokit = new Octokit(
    toOctokitOptions({ githubToken, githubUrl, githubApiPathPrefix, proxy }),
  );

  // In case the repo changed name, get the new `repo`/`owner` as the search API will not follow redirects
  const { data: repoData } = await octokit.request(
    "GET /repos/{owner}/{repo}",
    parseGithubUrl(repositoryUrl),
  );
  const [owner, repo] = repoData.full_name.split("/");

  const errors = [];

  if (successComment === false) {
    logger.log("Skip commenting on issues and pull requests.");
  } else {
    const parser = issueParser(
      "github",
      githubUrl ? { hosts: [g...
_tmp_0 = context
_tmp_1.repositoryUrl = repositoryUrl
commits = _tmp_0.commits
nextRelease = _tmp_0.nextRelease
releases = _tmp_0.releases
logger = _tmp_0.logger
_tmp_2 = resolveConfig(pluginConfig, context)
githubToken = _tmp_2.githubToken
githubUrl = _tmp_2.githubUrl
githubApiPathPrefix = _tmp_2.githubApiPathPrefix
proxy = _tmp_2.proxy
successComment = _tmp_2.successComment
failComment = _tmp_2.failComment
failTitle = _tmp_2.failTitle
releasedLabels = _tmp_2.releasedLabels
addReleases = _tmp_2.addReleases
resolveConfig(pluginConfig, context)
const octokit = new Octokit(
    toOctokitOptions({ githubToken, githubUrl, githubApiPathPrefix, proxy }),
  )
toOctokitOptions({ githubToken, githubUrl, githubApiPathPrefix, proxy })
_tmp_5 = await octokit.request(
    "GET /repos/{owner}/{repo}",
    parseGithubUrl(repositoryUrl),
  )
"GET /repos/{owner}/{repo}"
parseGithubUrl(repositoryUrl)
_tmp_7 = repoData.full_name.split("/")
__ecma.Array.factory()
successComment === false
logger.log("Skip commenting on issues and pull requests.")
const parser = issueParser(
      "github",
      githubUrl ? { hosts: [githubUrl] } : {},
    )
"github"
githubUrl ? { hosts: [githubUrl] } : {}
const releaseInfos = releases.filter((release) => Boolean(release.name))
const shas = commits.map(({ hash }) => hash)
const searchQueries = getSearchQueries(
      `repo:${owner}/${repo}+type:pr+is:merged`,
      shas,
    ).map(
      async (q) =>
        (await octokit.request("GET /search/issues", { q })).data.items,
    )
<operator>.formatString("repo:", owner, "/", repo, "+type:pr+is:merged")
map
<lambda>2
const searchQueriesResults = await Promise.all(searchQueries)
const uniqueSearchQueriesResults = uniqBy(
      flatten(searchQueriesResults),
      "number",
    )
flatten(searchQueriesResults)
"number"
const prs = await pFilter(
      uniqueSearchQueriesResults,
      async ({ number }) => {
        const commits = await octokit.paginate(
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
          {
            owner,
            repo,
            pull_number: number,
          },
        );
        const matchingCommit = commits.find(({ sha }) => shas.includes(sha));
        if (matchingCommit) return matchingCommit;

        const { data: pullRequest } = await octokit.request(
          "GET /repos/{owner}/{repo}/pulls/{pull_number}",
          {
            owner,
            repo,
            pull_number: number,
          },
        );
        return shas.includes(pullRequest.merge_commit_sha);
      },
    )
number = param1_1.number
debug(
      "found pull requests: %O",
      prs.map((pr) => pr.number),
    )
"found pull requests: %O"
prs.map((pr) => pr.number)
const issues = [
      ...prs.map((pr) => pr.body),
      ...commits.map((commit) => commit.message),
    ].reduce(
      (issues, message) =>
        message
          ? issues.concat(
              parser(message)
                .actions.close.filter(
                  (action) =>
                    isNil(action.slug) || action.slug === `${owner}/${repo}`,
                )
                .map((action) => ({
                  number: Number.parseInt(action.issue, 10),
                })),
            )
          : issues,
      [],
    )
_tmp_17.push(...prs.map((pr) => pr.body))
_tmp_17.push(...commits.map((commit) => commit.message))
reduce
<lambda>8
__ecma.Array.factory()
debug("found issues via comments: %O", issues)
await Promise.all(
      uniqBy([...prs, ...issues], "number").map(async (issue) => {
        const body = successComment
          ? template(successComment)({ ...context, issue })
          : getSuccessComment(issue, releaseInfos, nextRelease);
        try {
          const comment = { owner, repo, issue_number: issue.number, body };
          debug("create comment: %O", comment);
          const {
            data: { html_url: url },
          } = await octokit.request(
            "POST /repos/{owner}/{repo}/issues/{issue_number}/comments",
            comment,
          );
          logger.log("Added comment to issue #%d: %s", issue.number, url);

          if (releasedLabels) {
            const labels = releasedLabels.map((label) =>
              template(label)(context),
            );
            await octokit.request(
              "POST /repos/{owner}/{repo}/issues/{issue_number}/labels",
              {
                owner,
                repo,
                issue_n...
uniqBy([...prs, ...issues], "number").map(async (issue) => {
        const body = successComment
          ? template(successComment)({ ...context, issue })
          : getSuccessComment(issue, releaseInfos, nextRelease);
        try {
          const comment = { owner, repo, issue_number: issue.number, body };
          debug("create comment: %O", comment);
          const {
            data: { html_url: url },
          } = await octokit.request(
            "POST /repos/{owner}/{repo}/issues/{issue_number}/comments",
            comment,
          );
          logger.log("Added comment to issue #%d: %s", issue.number, url);

          if (releasedLabels) {
            const labels = releasedLabels.map((label) =>
              template(label)(context),
            );
            await octokit.request(
              "POST /repos/{owner}/{repo}/issues/{issue_number}/labels",
              {
                owner,
                repo,
                issue_number: issue.number,
    ...
failComment === false || failTitle === false
logger.log("Skip closing issue.")
const srIssues = await findSRIssues(octokit, failTitle, owner, repo)
debug("found semantic-release issues: %O", srIssues)
await Promise.all(
      srIssues.map(async (issue) => {
        debug("close issue: %O", issue);
        try {
          const updateIssue = {
            owner,
            repo,
            issue_number: issue.number,
            state: "closed",
          };
          debug("closing issue: %O", updateIssue);
          const {
            data: { html_url: url },
          } = await octokit.request(
            "PATCH /repos/{owner}/{repo}/issues/{issue_number}",
            updateIssue,
          );
          logger.log("Closed issue #%d: %s.", issue.number, url);
        } catch (error) {
          errors.push(error);
          logger.error("Failed to close the issue #%d.", issue.number);
          // Don't throw right away and continue to close other issues
        }
      }),
    )
srIssues.map(async (issue) => {
        debug("close issue: %O", issue);
        try {
          const updateIssue = {
            owner,
            repo,
            issue_number: issue.number,
            state: "closed",
          };
          debug("closing issue: %O", updateIssue);
          const {
            data: { html_url: url },
          } = await octokit.request(
            "PATCH /repos/{owner}/{repo}/issues/{issue_number}",
            updateIssue,
          );
          logger.log("Closed issue #%d: %s.", issue.number, url);
        } catch (error) {
          errors.push(error);
          logger.error("Failed to close the issue #%d.", issue.number);
          // Don't throw right away and continue to close other issues
        }
      })
addReleases !== false && errors.length === 0
const ghRelease = releases.find(
      (release) => release.name && release.name === RELEASE_NAME,
    )
release.name && release.name === RELEASE_NAME
!isNil(ghRelease)
const ghRelaseId = ghRelease.id
const additionalReleases = getReleaseLinks(releases)
!isEmpty(additionalReleases) && !isNil(ghRelaseId)
const newBody =
          addReleases === "top"
            ? additionalReleases.concat("\n---\n", nextRelease.notes)
            : nextRelease.notes.concat("\n---\n", additionalReleases)
addReleases === "top" ? additionalReleases.concat("\n---\n", nextRelease.notes) : nextRelease.notes.concat("\n---\n", additionalReleases)
additionalReleases.concat("\n---\n", nextRelease.notes)
nextRelease.notes.concat("\n---\n", additionalReleases)
await octokit.request(
          "PATCH /repos/{owner}/{repo}/releases/{release_id}",
          {
            owner,
            repo,
            release_id: ghRelaseId,
            body: newBody,
          },
        )
"PATCH /repos/{owner}/{repo}/releases/{release_id}"
