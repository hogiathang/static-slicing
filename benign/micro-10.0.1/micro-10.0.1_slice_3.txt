var Module = require("module")
var http = require("http")
var path = require("path")
var existsSync = require("fs").existsSync
var arg = require("arg")
var serve = require("../lib").serve
var handle = require("../lib/handler").handle
var version = require("../../package.json").version
var logError = require("../lib/error").logError
var parseEndpoint = require("../lib/parse-endpoint").parseEndpoint
var AddressInfo = require("net").AddressInfo
var RequestHandler = require("../lib").RequestHandler
const args = arg({
  '--listen': parseEndpoint,
  '-l': '--listen',
  '--help': Boolean,
  '--version': Boolean,
  '-v': '--version',
})
_tmp_1.--listen = parseEndpoint
_tmp_1.-l = "--listen"
_tmp_1.--help = Boolean
_tmp_1.--version = Boolean
_tmp_1.-v = "--version"
args["--help"]
console.error(`
  micro - Asynchronous HTTP microservices

  USAGE

      $ micro --help
      $ micro --version
      $ micro [-l listen_uri [-l ...]] [entry_point.js]

      By default micro will listen on 0.0.0.0:3000 and will look first
      for the "main" property in package.json and subsequently for index.js
      as the default entry_point.

      Specifying a single --listen argument will overwrite the default, not supplement it.

  OPTIONS

      --help                              shows this help message

      -v, --version                       displays the current version of micro

      -l, --listen listen_uri             specify a URI endpoint on which to listen (see below) -
                                          more than one may be specified to listen in multiple places

  ENDPOINTS

      Listen endpoints (specified by the --listen or -l options above) instruct micro
      to listen on one or more interfaces/ports, UNIX domain sockets, or Windows named pipes.
...
process.exit(2)
args["--version"]
console.log(version)
process.exit()
!args['--listen']
args['--listen'] = [String(3000)]
let file = args._[0]
!file
const req = Module.createRequire(module.filename)
const packageJson: unknown = req(
      path.resolve(process.cwd(), 'package.json'),
    )
path.resolve(process.cwd(), 'package.json')
hasMain(packageJson)
file = packageJson.main
file = 'index.js'
isNodeError(err) && err.code !== 'MODULE_NOT_FOUND'
logError(
        `Could not read \`package.json\`: ${err.message}`,
        'invalid-package-json',
      )
<operator>.formatString("Could not read \`package.json\`: ", err.message, "")
"invalid-package-json"
process.exit(1)
function registerShutdown = function registerShutdown(fn: () => void) {
  let run = false;

  const wrapper = () => {
    if (!run) {
      run = true;
      fn();
    }
  };

  process.on('SIGINT', wrapper);
  process.on('SIGTERM', wrapper);
  process.on('exit', wrapper);
}
function startEndpoint = function startEndpoint(module: RequestHandler, endpoint: string) {
  const server = new http.Server(serve(module));

  server.on('error', (err) => {
    console.error('micro:', err.stack);
    process.exit(1);
  });

  server.listen(endpoint, () => {
    const details = server.address();
    registerShutdown(() => {
      console.log('micro: Gracefully shutting down. Please wait...');
      server.close();
      process.exit();
    });

    // `micro` is designed to run only in production, so
    // this message is perfect for prod
    if (typeof details === 'string') {
      console.log(`micro: Accepting connections on ${details}`);
    } else if (isAddressInfo(details)) {
      console.log(`micro: Accepting connections on port ${details.port}`);
    } else {
      console.log('micro: Accepting connections');
    }
  });
}
function start = async function start() {
  if (file && args['--listen']) {
    const loadedModule = await handle(file);

    for (const endpoint of args['--listen']) {
      startEndpoint(loadedModule as RequestHandler, endpoint);
    }
  }
}
function hasMain = function hasMain(packageJson: unknown): packageJson is { main: string } {
  return (
    typeof packageJson === 'object' &&
    packageJson !== null &&
    'main' in packageJson
  );
}
function isNodeError = function isNodeError(
  error: unknown,
): error is { code: string; message: string } {
  return error instanceof Error && 'code' in error;
}
function isAddressInfo = function isAddressInfo(obj: unknown): obj is AddressInfo {
  return 'port' in (obj as AddressInfo);
}
