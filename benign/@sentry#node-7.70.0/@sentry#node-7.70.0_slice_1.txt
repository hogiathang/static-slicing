async addSourceContext(event) {
    // keep a lookup map of which files we've already enqueued to read,
    // so we don't enqueue the same file multiple times which would cause multiple i/o reads
    const enqueuedReadSourceFileTasks = {};
    const readSourceFileTasks = [];

    if (this._contextLines > 0 && _optionalChain([event, 'access', _2 => _2.exception, 'optionalAccess', _3 => _3.values])) {
      for (const exception of event.exception.values) {
        if (!_optionalChain([exception, 'access', _4 => _4.stacktrace, 'optionalAccess', _5 => _5.frames])) {
          continue;
        }

        // We want to iterate in reverse order as calling cache.get will bump the file in our LRU cache.
        // This ends up prioritizes source context for frames at the top of the stack instead of the bottom.
        for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {
          const frame = exception.stacktrace.frames[i];
          // Call cache.get to bump the file to th...
const enqueuedReadSourceFileTasks = {}
const readSourceFileTasks = []
this._contextLines > 0 && _optionalChain([event, 'access', _2 => _2.exception, 'optionalAccess', _3 => _3.values])
_iterator_0 = <operator>.iterator(event.exception.values)
!_optionalChain([exception, 'access', _4 => _4.stacktrace, 'optionalAccess', _5 => _5.frames])
continue;
let i = exception.stacktrace.frames.length - 1
const frame = exception.stacktrace.frames[i]
frame.filename &&
            !enqueuedReadSourceFileTasks[frame.filename] &&
            !FILE_CONTENT_CACHE.get(frame.filename)
!enqueuedReadSourceFileTasks[frame.filename]
!FILE_CONTENT_CACHE.get(frame.filename)
readSourceFileTasks.push(_readSourceFile(frame.filename))
enqueuedReadSourceFileTasks[frame.filename] = 1
