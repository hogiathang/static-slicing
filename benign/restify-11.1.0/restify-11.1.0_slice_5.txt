Server.prototype._finishReqResCycle = function _finishReqResCycle(
    req,
    res,
    err
) {
    var self = this;
    var route = req.route; // can be undefined when 404 or error

    // if the returned err value was a string, then we're handling the
    // next('foo') case where we redirect to another middleware stack. don't
    // do anything here because we're not done yet.
    if (res._finished || _.isString(err)) {
        return;
    }

    if (res._flushed && res._handlersFinished) {
        // decrement number of requests
        self._inflightRequests--;
        res._finished = true;
        req._timeFinished = process.hrtime();

        // after event has signature of function(req, res, route, err) {...}
        var finalErr = err || res.err;
        req.emit('restifyDone', route, finalErr);
        self.emit('after', req, res, route, finalErr);
    } else if (
        res._handlersFinished === true &&
        res.headersSent === false &&
        !res.err
    ) {
     ...
var self = this
var route = req.route
res._finished || _.isString(err)
res._flushed && res._handlersFinished
self._inflightRequests--
res._finished = true
req._timeFinished = process.hrtime()
var finalErr = err || res.err
req.emit('restifyDone', route, finalErr)
