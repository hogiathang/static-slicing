self.leapManager.withEntry(tryEntry, function () {
        self.explodeStatement(path.get("block"));
        if (catchLoc) {
          if (finallyLoc) {
            // If we have both a catch block and a finally block, then
            // because we emit the catch block first, we need to jump over
            // it to the finally block.
            self.jump(finallyLoc);
          } else {
            // If there is no finally block, then we need to jump over the
            // catch block to the fall-through location.
            self.jump(after);
          }
          self.updateContextPrevLoc(self.mark(catchLoc));
          var bodyPath = path.get("handler.body");
          var safeParam = self.makeTempVar();
          self.clearPendingException(tryEntry.firstLoc, safeParam);
          bodyPath.traverse(catchParamVisitor, {
            getSafeParam: function getSafeParam() {
              return t.cloneDeep(safeParam);
            },
            catchParamName: handler.param.name...
self.explodeStatement(path.get("block"))
self.jump(finallyLoc)
self.jump(after)
self.updateContextPrevLoc(self.mark(catchLoc))
var bodyPath = path.get("handler.body")
var safeParam = self.makeTempVar()
self.clearPendingException(tryEntry.firstLoc, safeParam)
bodyPath.traverse(catchParamVisitor, {
            getSafeParam: function getSafeParam() {
              return t.cloneDeep(safeParam);
            },
            catchParamName: handler.param.name
          })
_tmp_62.getSafeParam = getSafeParam
_tmp_62.catchParamName = handler.param.name
self.leapManager.withEntry(catchEntry, function () {
            self.explodeStatement(bodyPath);
          })
self.updateContextPrevLoc(self.mark(finallyLoc))
self.leapManager.withEntry(finallyEntry, function () {
            self.explodeStatement(path.get("finalizer"));
          })
self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])))
