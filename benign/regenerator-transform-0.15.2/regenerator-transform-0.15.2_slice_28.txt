Ep.explodeStatement = function(path, labelId) {
  const t = util.getTypes();
  let stmt = path.node;
  let self = this;
  let before, after, head;

  t.assertStatement(stmt);

  if (labelId) {
    t.assertIdentifier(labelId);
  } else {
    labelId = null;
  }

  // Explode BlockStatement nodes even if they do not contain a yield,
  // because we don't want or need the curly braces.
  if (t.isBlockStatement(stmt)) {
    path.get("body").forEach(function (path) {
      self.explodeStatement(path);
    });
    return;
  }

  if (!meta.containsLeap(stmt)) {
    // Technically we should be able to avoid emitting the statement
    // altogether if !meta.hasSideEffects(stmt), but that leads to
    // confusing generated code (for instance, `while (true) {}` just
    // disappears) and is probably a more appropriate job for a dedicated
    // dead code elimination pass.
    self.emit(stmt);
    return;
  }

  switch (stmt.type) {
  case "ExpressionStatement":
    self.explodeExpression(pat...
const t = util.getTypes()
let stmt = path.node
let self = this
t.assertStatement(stmt)
t.assertIdentifier(labelId)
labelId = null
t.isBlockStatement(stmt)
!meta.containsLeap(stmt)
stmt.type
"SwitchStatement"
let disc = self.emitAssign(
      self.makeTempVar(),
      self.explodeExpression(path.get("discriminant"))
    )
self.makeTempVar()
self.explodeExpression(path.get("discriminant"))
after = this.loc()
let defaultLoc = this.loc()
let condition = defaultLoc
__ecma.Array.factory()
let cases = stmt.cases || []
let i = cases.length - 1
let c = cases[i]
t.assertSwitchCase(c)
c.test
condition = t.conditionalExpression(
          t.binaryExpression("===", t.cloneDeep(disc), c.test),
          caseLocs[i] = this.loc(),
          condition
        )
t.binaryExpression("===", t.cloneDeep(disc), c.test)
caseLocs[i] = this.loc()
caseLocs[i] = defaultLoc
let discriminant = path.get("discriminant")
