self.leapManager.withEntry(tryEntry, function() {
      self.explodeStatement(path.get("block"));

      if (catchLoc) {
        if (finallyLoc) {
          // If we have both a catch block and a finally block, then
          // because we emit the catch block first, we need to jump over
          // it to the finally block.
          self.jump(finallyLoc);

        } else {
          // If there is no finally block, then we need to jump over the
          // catch block to the fall-through location.
          self.jump(after);
        }

        self.updateContextPrevLoc(self.mark(catchLoc));

        let bodyPath = path.get("handler.body");
        let safeParam = self.makeTempVar();
        self.clearPendingException(tryEntry.firstLoc, safeParam);

        bodyPath.traverse(catchParamVisitor, {
          getSafeParam: () => t.cloneDeep(safeParam),
          catchParamName: handler.param.name
        });

        self.leapManager.withEntry(catchEntry, function() {
          self.e...
self.explodeStatement(path.get("block"))
self.jump(finallyLoc)
self.jump(after)
self.updateContextPrevLoc(self.mark(catchLoc))
let bodyPath = path.get("handler.body")
let safeParam = self.makeTempVar()
self.clearPendingException(tryEntry.firstLoc, safeParam)
bodyPath.traverse(catchParamVisitor, {
          getSafeParam: () => t.cloneDeep(safeParam),
          catchParamName: handler.param.name
        })
_tmp_53.getSafeParam = <lambda>33
_tmp_53.catchParamName = handler.param.name
self.leapManager.withEntry(catchEntry, function() {
          self.explodeStatement(bodyPath);
        })
self.updateContextPrevLoc(self.mark(finallyLoc))
self.leapManager.withEntry(finallyEntry, function() {
          self.explodeStatement(path.get("finalizer"));
        })
self.emit(t.returnStatement(t.callExpression(
          self.contextProperty("finish"),
          [finallyEntry.firstLoc]
        )))
