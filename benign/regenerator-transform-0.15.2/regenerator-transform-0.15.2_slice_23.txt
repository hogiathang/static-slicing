_tmp_18.exit = util.wrapWithTypes(t, function (path, state) {
        var node = path.node;
        if (!shouldRegenerate(node, state)) return;

        // if this is an ObjectMethod, we need to convert it to an ObjectProperty
        path = (0, _replaceShorthandObjectMethod["default"])(path);
        node = path.node;
        var contextId = path.scope.generateUidIdentifier("context");
        var argsId = path.scope.generateUidIdentifier("args");
        path.ensureBlock();
        var bodyBlockPath = path.get("body");
        if (node.async) {
          bodyBlockPath.traverse(awaitVisitor);
        }
        bodyBlockPath.traverse(functionSentVisitor, {
          context: contextId
        });
        var outerBody = [];
        var innerBody = [];
        bodyBlockPath.get("body").forEach(function (childPath) {
          var node = childPath.node;
          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
            // Babylon represents directives like "use strict" ...
var node = path.node
!shouldRegenerate(node, state)
path = (0, _replaceShorthandObjectMethod["default"])(path)
node = path.node
var contextId = path.scope.generateUidIdentifier("context")
var argsId = path.scope.generateUidIdentifier("args")
path.ensureBlock()
var bodyBlockPath = path.get("body")
node.async
bodyBlockPath.traverse(awaitVisitor)
bodyBlockPath.traverse(functionSentVisitor, {
          context: contextId
        })
_tmp_21.context = contextId
__ecma.Array.factory()
__ecma.Array.factory()
bodyBlockPath.get("body").forEach(function (childPath) {
          var node = childPath.node;
          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
            // Babylon represents directives like "use strict" as elements
            // of a bodyBlockPath.node.directives array, but they could just
            // as easily be represented (by other parsers) as traditional
            // string-literal-valued expression statements, so we need to
            // handle that here. (#248)
            outerBody.push(node);
          } else if (node && node._blockHoist != null) {
            outerBody.push(node);
          } else {
            innerBody.push(node);
          }
        })
outerBody.length > 0
bodyBlockPath.node.body = innerBody
var outerFnExpr = getOuterFnExpr(path)
t.assertIdentifier(node.id)
var innerFnId = t.identifier(node.id.name + "$")
var vars = (0, _hoist.hoist)(path)
var context = {
          usesThis: false,
          usesArguments: false,
          getArgsId: function getArgsId() {
            return t.clone(argsId);
          }
        }
_tmp_23.usesThis = false
_tmp_23.usesArguments = false
_tmp_23.getArgsId = getArgsId
path.traverse(argumentsThisVisitor, context)
context.usesArguments
vars = vars || t.variableDeclaration("var", [])
vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier("arguments")))
var emitter = new _emit.Emitter(contextId)
emitter.explode(path.get("body"))
