_tmp_18.exit = util.wrapWithTypes(t, function (path, state) {
        var node = path.node;
        if (!shouldRegenerate(node, state)) return;

        // if this is an ObjectMethod, we need to convert it to an ObjectProperty
        path = (0, _replaceShorthandObjectMethod["default"])(path);
        node = path.node;
        var contextId = path.scope.generateUidIdentifier("context");
        var argsId = path.scope.generateUidIdentifier("args");
        path.ensureBlock();
        var bodyBlockPath = path.get("body");
        if (node.async) {
          bodyBlockPath.traverse(awaitVisitor);
        }
        bodyBlockPath.traverse(functionSentVisitor, {
          context: contextId
        });
        var outerBody = [];
        var innerBody = [];
        bodyBlockPath.get("body").forEach(function (childPath) {
          var node = childPath.node;
          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
            // Babylon represents directives like "use strict" ...
var node = path.node
!shouldRegenerate(node, state)
path = (0, _replaceShorthandObjectMethod["default"])(path)
node = path.node
var contextId = path.scope.generateUidIdentifier("context")
var argsId = path.scope.generateUidIdentifier("args")
path.ensureBlock()
var bodyBlockPath = path.get("body")
node.async
bodyBlockPath.traverse(awaitVisitor)
bodyBlockPath.traverse(functionSentVisitor, {
          context: contextId
        })
_tmp_21.context = contextId
__ecma.Array.factory()
__ecma.Array.factory()
bodyBlockPath.get("body").forEach(function (childPath) {
          var node = childPath.node;
          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
            // Babylon represents directives like "use strict" as elements
            // of a bodyBlockPath.node.directives array, but they could just
            // as easily be represented (by other parsers) as traditional
            // string-literal-valued expression statements, so we need to
            // handle that here. (#248)
            outerBody.push(node);
          } else if (node && node._blockHoist != null) {
            outerBody.push(node);
          } else {
            innerBody.push(node);
          }
        })
