_tmp_10.exit = util.wrapWithTypes(t, function(path, state) {
      let node = path.node;

      if (!shouldRegenerate(node, state)) return;

      // if this is an ObjectMethod, we need to convert it to an ObjectProperty
      path = replaceShorthandObjectMethod(path);
      node = path.node;

      let contextId = path.scope.generateUidIdentifier("context");
      let argsId = path.scope.generateUidIdentifier("args");

      path.ensureBlock();
      let bodyBlockPath = path.get("body");

      if (node.async) {
        bodyBlockPath.traverse(awaitVisitor);
      }

      bodyBlockPath.traverse(functionSentVisitor, {
        context: contextId
      });

      let outerBody = [];
      let innerBody = [];

      bodyBlockPath.get("body").forEach(function(childPath) {
        let node = childPath.node;
        if (t.isExpressionStatement(node) &&
            t.isStringLiteral(node.expression)) {
          // Babylon represents directives like "use strict" as elements
          // of a bodyBlockPat...
let node = path.node
!shouldRegenerate(node, state)
path = replaceShorthandObjectMethod(path)
node = path.node
let contextId = path.scope.generateUidIdentifier("context")
let argsId = path.scope.generateUidIdentifier("args")
path.ensureBlock()
let bodyBlockPath = path.get("body")
node.async
bodyBlockPath.traverse(awaitVisitor)
bodyBlockPath.traverse(functionSentVisitor, {
        context: contextId
      })
_tmp_13.context = contextId
__ecma.Array.factory()
__ecma.Array.factory()
bodyBlockPath.get("body").forEach(function(childPath) {
        let node = childPath.node;
        if (t.isExpressionStatement(node) &&
            t.isStringLiteral(node.expression)) {
          // Babylon represents directives like "use strict" as elements
          // of a bodyBlockPath.node.directives array, but they could just
          // as easily be represented (by other parsers) as traditional
          // string-literal-valued expression statements, so we need to
          // handle that here. (#248)
          outerBody.push(node);
        } else if (node && node._blockHoist != null) {
          outerBody.push(node);
        } else {
          innerBody.push(node);
        }
      })
