constructor(url, network) {
        // This will be added in the future; please open an issue to expedite
        if (network === "any") {
            logger.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "network:any"
            });
        }
        if (typeof (url) === "string") {
            super(url, network);
        }
        else {
            super("_websocket", network);
        }
        this._pollingInterval = -1;
        this._wsReady = false;
        if (typeof (url) === "string") {
            defineReadOnly(this, "_websocket", new WebSocket(this.connection.url));
        }
        else {
            defineReadOnly(this, "_websocket", url);
        }
        defineReadOnly(this, "_requests", {});
        defineReadOnly(this, "_subs", {});
        defineReadOnly(this, "_subIds", {});
        defineReadOnly(this, "_detectNetwork", super.detectNetwork());
        // Stall sending requ...
network === "any"
logger.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "network:any"
            })
_tmp_5.operation = "network:any"
typeof (url) === "string"
super(url, network)
super("_websocket", network)
this._pollingInterval = -1
this._wsReady = false
typeof (url) === "string"
defineReadOnly(this, "_websocket", new WebSocket(this.connection.url))
defineReadOnly(this, "_websocket", url)
defineReadOnly(this, "_requests", {})
defineReadOnly(this, "_subs", {})
defineReadOnly(this, "_subIds", {})
defineReadOnly(this, "_detectNetwork", super.detectNetwork())
this.websocket.onopen = () => {
            this._wsReady = true;
            Object.keys(this._requests).forEach((id) => {
                this.websocket.send(this._requests[id].payload);
            });
        }
this.websocket.onmessage = (messageEvent) => {
            const data = messageEvent.data;
            const result = JSON.parse(data);
            if (result.id != null) {
                const id = String(result.id);
                const request = this._requests[id];
                delete this._requests[id];
                if (result.result !== undefined) {
                    request.callback(null, result.result);
                    this.emit("debug", {
                        action: "response",
                        request: JSON.parse(request.payload),
                        response: result.result,
                        provider: this
                    });
                }
                else {
                    let error = null;
                    if (result.error) {
                        error = new Error(result.error.message || "unknown error");
                        defineReadOnly(error, "code", result.error.code || null);
                        defin...
const fauxPoll = setInterval(() => {
            this.emit("poll");
        }, 1000)
1000
