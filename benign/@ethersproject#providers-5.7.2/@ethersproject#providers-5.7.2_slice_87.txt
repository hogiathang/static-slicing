send(method, params) {
        const request = {
            method: method,
            params: params,
            id: (this._nextId++),
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "request",
            request: deepCopy(request),
            provider: this
        });
        // We can expand this in the future to any call, but for now these
        // are the biggest wins and do not require any serializing parameters.
        const cache = (["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0);
        if (cache && this._cache[method]) {
            return this._cache[method];
        }
        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {
            this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: this
            });
            return result;
        }, (error) => {
            ...
const request = {
            method: method,
            params: params,
            id: (this._nextId++),
            jsonrpc: "2.0"
        }
_tmp_76.method = method
_tmp_76.params = params
_tmp_76.id = this._nextId++
_tmp_76.jsonrpc = "2.0"
this.emit("debug", {
            action: "request",
            request: deepCopy(request),
            provider: this
        })
_tmp_77.action = "request"
_tmp_77.request = deepCopy(request)
_tmp_77.provider = this
const cache = (["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0)
cache && this._cache[method]
const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {
            this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: this
            });
            return result;
        }, (error) => {
            this.emit("debug", {
                action: "response",
                error: error,
                request: request,
                provider: this
            });
            throw error;
        })
<lambda>30
this._cache[method] = result
setTimeout(() => {
                this._cache[method] = null;
            }, 0)
