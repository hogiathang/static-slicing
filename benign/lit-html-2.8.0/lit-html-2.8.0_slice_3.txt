_updateRefValue(element) {
        var _a;
        if (typeof this._ref === 'function') {
            // If the current ref was called with a previous value, call with
            // `undefined`; We do this to ensure callbacks are called in a consistent
            // way regardless of whether a ref might be moving up in the tree (in
            // which case it would otherwise be called with the new value before the
            // previous one unsets it) and down in the tree (where it would be unset
            // before being set). Note that element lookup is keyed by
            // both the context and the callback, since we allow passing unbound
            // functions that are called on options.host, and we want to treat
            // these as unique "instances" of a function.
            const context = (_a = this._context) !== null && _a !== void 0 ? _a : globalThis;
            let lastElementForCallback = lastElementForContextAndCallback.get(context);
            if (last...
typeof this._ref === 'function'
const context = (_a = this._context) !== null && _a !== void 0 ? _a : globalThis
let lastElementForCallback = lastElementForContextAndCallback.get(context)
lastElementForCallback === undefined
lastElementForCallback = new WeakMap()
lastElementForContextAndCallback.set(context, lastElementForCallback)
lastElementForCallback.get(this._ref) !== undefined
