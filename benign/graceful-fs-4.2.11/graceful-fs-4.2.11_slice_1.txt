function ReadStream = function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        thro...
!(this instanceof ReadStream)
Stream.call(this)
var self = this
this.path = path
this.fd = null
this.readable = true
this.paused = false
this.flags = 'r'
this.mode = 438
this.bufferSize = 64 * 1024
options = options || {}
var keys = Object.keys(options)
var length = keys.length
var key = keys[index]
this[key] = options[key]
this.setEncoding(this.encoding)
this.start !== undefined
'number' !== typeof this.start
throw TypeError('start must be a Number');
this.end === undefined
this.end = Infinity
'number' !== typeof this.end
throw TypeError('end must be a Number');
this.start > this.end
throw new Error('start must be <= end');
this.pos = this.start
this.fd !== null
process.nextTick(function() {
        self._read();
      })
