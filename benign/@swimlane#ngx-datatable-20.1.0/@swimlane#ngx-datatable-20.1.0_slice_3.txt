temp.sort(function (rowA, rowB) {
        for (const cachedDir of cachedDirs) {
            // Get property and valuegetters for column to be sorted
            const { prop, valueGetter } = cachedDir;
            // Get A and B cell values from rows based on properties of the columns
            const propA = valueGetter(rowA, prop);
            const propB = valueGetter(rowB, prop);
            // Compare function gets five parameters:
            // Two cell values to be compared as propA and propB
            // Two rows corresponding to the cells as rowA and rowB
            // Direction of the sort for this column as SortDirection
            // Compare can be a standard JS comparison function (a,b) => -1|0|1
            // as additional parameters are silently ignored. The whole row and sort
            // direction enable more complex sort logic.
            const comparison = cachedDir.dir !== SortDirection.desc
                ? cachedDir.compareFn(propA, propB, rowA, rowB...
_iterator_6 = <operator>.iterator(cachedDirs)
valueGetter = _tmp_28.valueGetter
const propA = valueGetter(rowA, prop)
const propB = valueGetter(rowB, prop)
const comparison = cachedDir.dir !== SortDirection.desc
                ? cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir)
                : -cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir)
cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir)
-cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir)
comparison !== 0
!(rowToIndexMap.has(rowA) && rowToIndexMap.has(rowB))
rowToIndexMap.get(rowA) < rowToIndexMap.get(rowB) ? -1 : 1
