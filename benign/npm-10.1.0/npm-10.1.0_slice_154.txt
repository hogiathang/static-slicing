async exec (args) {
    if (args.length === 0) {
      args = ['.']
    }
    if (args.length !== 1) {
      throw this.usageError()
    }

    log.verbose('publish', replaceInfo(args))

    const unicode = this.npm.config.get('unicode')
    const dryRun = this.npm.config.get('dry-run')
    const json = this.npm.config.get('json')
    const defaultTag = this.npm.config.get('tag')
    const ignoreScripts = this.npm.config.get('ignore-scripts')
    const { silent } = this.npm

    if (semver.validRange(defaultTag)) {
      throw new Error('Tag name must not be a valid SemVer range: ' + defaultTag.trim())
    }

    const opts = { ...this.npm.flatOptions, progress: false }
    log.disableProgress()

    // you can publish name@version, ./foo.tgz, etc.
    // even though the default is the 'file:.' cwd.
    const spec = npa(args[0])
    let manifest = await this.getManifest(spec, opts)

    // only run scripts for directory type publishes
    if (spec.type === 'directory' && !ignoreScri...
args.length === 0
_tmp_2 = __ecma.Array.factory()
args.length !== 1
throw this.usageError()
log.verbose('publish', replaceInfo(args))
const unicode = this.npm.config.get('unicode')
const dryRun = this.npm.config.get('dry-run')
const json = this.npm.config.get('json')
const defaultTag = this.npm.config.get('tag')
const ignoreScripts = this.npm.config.get('ignore-scripts')
silent = _tmp_8.silent
semver.validRange(defaultTag)
throw new Error('Tag name must not be a valid SemVer range: ' + defaultTag.trim())
const opts = { ...this.npm.flatOptions, progress: false }
log.disableProgress()
const spec = npa(args[0])
let manifest = await this.getManifest(spec, opts)
spec.type === 'directory' && !ignoreScripts
await runScript({
        event: 'prepublishOnly',
        path: spec.fetchSpec,
        stdio: 'inherit',
        pkg: manifest,
        banner: !silent,
      })
_tmp_11.event = "prepublishOnly"
_tmp_11.path = spec.fetchSpec
_tmp_11.stdio = "inherit"
_tmp_11.pkg = manifest
_tmp_11.banner = !silent
const tarballData = await pack(spec, {
      ...opts,
      dryRun: true,
      prefix: this.npm.localPrefix,
      workspaces: this.workspacePaths,
    })
...opts
_tmp_12.dryRun = true
_tmp_12.prefix = this.npm.localPrefix
_tmp_12.workspaces = this.workspacePaths
const pkgContents = await getContents(manifest, tarballData)
manifest = await this.getManifest(spec, opts, true)
!json
logTar(pkgContents, { unicode })
const resolved = npa.resolve(manifest.name, manifest.version)
const registry = npmFetch.pickRegistry(resolved, opts)
const creds = this.npm.config.getCredentialsByURI(registry)
const noCreds = !(creds.token || creds.username || creds.certfile && creds.keyfile)
const outputRegistry = replaceInfo(registry)
<operator>.formatString("This command requires you to be logged in to ", outputRegistry, "")
<operator>.formatString("", msg, " (dry-run)")
throw Object.assign(new Error(msg), { code: 'ENEEDAUTH' })
const access = opts.access === null ? 'default' : opts.access
<operator>.formatString("Publishing to ", outputRegistry, " with tag ", defaultTag, " and ", access, " access")
<operator>.formatString("", msg, " (dry-run)")
log.notice('', msg)
!dryRun
await otplease(this.npm, opts, o => libpub(manifest, tarballData, o))
spec.type === 'directory' && !ignoreScripts
await runScript({
        event: 'publish',
        path: spec.fetchSpec,
        stdio: 'inherit',
        pkg: manifest,
        banner: !silent,
      })
_tmp_17.event = "publish"
_tmp_17.path = spec.fetchSpec
_tmp_17.stdio = "inherit"
_tmp_17.pkg = manifest
_tmp_17.banner = !silent
await runScript({
        event: 'postpublish',
        path: spec.fetchSpec,
        stdio: 'inherit',
        pkg: manifest,
        banner: !silent,
      })
_tmp_18.event = "postpublish"
_tmp_18.path = spec.fetchSpec
_tmp_18.stdio = "inherit"
_tmp_18.pkg = manifest
_tmp_18.banner = !silent
!this.suppressOutput
!silent && json
this.npm.output(JSON.stringify(pkgContents, null, 2))
