async exec (args) {
    const opts = {
      ...this.npm.flatOptions,
      ...this.npm.flatOptions.search,
      include: args.map(s => s.toLowerCase()).filter(s => s),
      exclude: this.npm.flatOptions.search.exclude.split(/\s+/),
    }

    if (opts.include.length === 0) {
      throw new Error('search must be called with arguments')
    }

    // Used later to figure out whether we had any packages go out
    let anyOutput = false

    class FilterStream extends Minipass {
      constructor () {
        super({ objectMode: true })
      }

      write (pkg) {
        if (filter(pkg, opts.include, opts.exclude)) {
          super.write(pkg)
        }
      }
    }

    const filterStream = new FilterStream()

    // Grab a configured output stream that will spit out packages in the
    // desired format.
    const outputStream = formatSearchStream({
      args, // --searchinclude options are not highlighted
      ...opts,
    })

    log.silly('search', 'searching packages')
  ...
const opts = {
      ...this.npm.flatOptions,
      ...this.npm.flatOptions.search,
      include: args.map(s => s.toLowerCase()).filter(s => s),
      exclude: this.npm.flatOptions.search.exclude.split(/\s+/),
    }
...this.npm.flatOptions
...this.npm.flatOptions.search
_tmp_10.include = args.map(s => s.toLowerCase()).filter(s => s)
_tmp_10.exclude = this.npm.flatOptions.search.exclude.split(/\s+/)
opts.include.length === 0
throw new Error('search must be called with arguments')
let anyOutput = false
FilterStream = package\lib\commands\search.js::program:Search:exec:FilterStream:<init>
const filterStream = new FilterStream()
const outputStream = formatSearchStream({
      args, // --searchinclude options are not highlighted
      ...opts,
    })
_tmp_17.args = args
...opts
log.silly('search', 'searching packages')
const p = new Pipeline(
      libSearch.stream(opts.include, opts),
      filterStream,
      outputStream
    )
libSearch.stream(opts.include, opts)
p.on('data', chunk => {
      if (!anyOutput) {
        anyOutput = true
      }
      this.npm.output(chunk.toString('utf8'))
    })
await p.promise()
!anyOutput && !this.npm.config.get('json') && !this.npm.config.get('parseable')
