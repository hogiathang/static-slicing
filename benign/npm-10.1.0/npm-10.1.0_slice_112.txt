process.on('exit', code => {
  log.disableProgress()

  // process.emit is synchronous, so the timeEnd handler will run before the
  // unfinished timer check below
  process.emit('timeEnd', 'npm')

  const hasLoadedNpm = npm?.config.loaded

  // Unfinished timers can be read before config load
  if (npm) {
    for (const [name, timer] of npm.unfinishedTimers) {
      log.verbose('unfinished npm timer', name, timer)
    }
  }

  if (!code) {
    log.info('ok')
  } else {
    log.verbose('code', code)
  }

  if (!exitHandlerCalled) {
    process.exitCode = code || 1
    log.error('', 'Exit handler never called!')
    // eslint-disable-next-line no-console
    console.error('')
    log.error('', 'This is an error with npm itself. Please report this error at:')
    log.error('', '    <https://github.com/npm/cli/issues>')
    showLogFileError = true
  }

  // npm must be loaded to know where the log file was written
  if (hasLoadedNpm) {
    // write the timing file now, this might do n...
log.disableProgress()
process.emit('timeEnd', 'npm')
const hasLoadedNpm = npm?.config.loaded
_iterator_0 = <operator>.iterator(npm.unfinishedTimers)
log.verbose('unfinished npm timer', name, timer)
!code
log.info('ok')
log.verbose('code', code)
!exitHandlerCalled
process.exitCode = code || 1
log.error('', 'Exit handler never called!')
console.error('')
log.error('', 'This is an error with npm itself. Please report this error at:')
log.error('', '    <https://github.com/npm/cli/issues>')
showLogFileError = true
npm.writeTimingFile()
const logsDir = npm.logsDir
const logFiles = npm.logFiles
const timingDir = npm.timingDir
const timingFile = npm.timingFile
const timing = npm.config.get('timing')
const logsMax = npm.config.get('logs-max')
