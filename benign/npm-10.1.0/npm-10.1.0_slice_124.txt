async execWorkspaces (args) {
    // if the root package is uninitiated, take care of it first
    if (this.npm.flatOptions.includeWorkspaceRoot) {
      await this.exec(args)
    }

    // reads package.json for the top-level folder first, by doing this we
    // ensure the command throw if no package.json is found before trying
    // to create a workspace package.json file or its folders
    const { content: pkg } = await PackageJson.normalize(this.npm.localPrefix).catch(err => {
      if (err.code === 'ENOENT') {
        log.warn('Missing package.json. Try with `--include-workspace-root`.')
      }
      throw err
    })

    // these are workspaces that are being created, so we cant use
    // this.setWorkspaces()
    const filters = this.npm.config.get('workspace')
    const wPath = filterArg => resolve(this.npm.localPrefix, filterArg)

    const workspacesPaths = []
    // npm-exec style, runs in the context of each workspace filter
    if (args.length) {
      for (const fil...
this.npm.flatOptions.includeWorkspaceRoot
await this.exec(args)
_tmp_4 = await PackageJson.normalize(this.npm.localPrefix).catch(err => {
      if (err.code === 'ENOENT') {
        log.warn('Missing package.json. Try with `--include-workspace-root`.')
      }
      throw err
    })
const filters = this.npm.config.get('workspace')
const wPath = filterArg => resolve(this.npm.localPrefix, filterArg)
const workspacesPaths = []
args.length
_iterator_0 = <operator>.iterator(filters)
const path = wPath(filterArg)
await mkdir(path, { recursive: true })
workspacesPaths.push(path)
await this.execCreate(args, path)
await this.setWorkspace(pkg, path)
