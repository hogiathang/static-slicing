const errorMessage = (er, npm) => {
  const short = []
  const detail = []
  const files = []

  if (er.message) {
    er.message = replaceInfo(er.message)
  }
  if (er.stack) {
    er.stack = replaceInfo(er.stack)
  }

  switch (er.code) {
    case 'ERESOLVE': {
      short.push(['ERESOLVE', er.message])
      detail.push(['', ''])
      // XXX(display): error messages are logged so we use the logColor since that is based
      // on stderr. This should be handled solely by the display layer so it could also be
      // printed to stdout if necessary.
      const { explanation, file } = report(er, npm.logChalk, npm.noColorChalk)
      detail.push(['', explanation])
      files.push(['eresolve-report.txt', file])
      break
    }

    case 'ENOLOCK': {
      const cmd = npm.command || ''
      short.push([cmd, 'This command requires an existing lockfile.'])
      detail.push([cmd, 'Try creating one first with: npm i --package-lock-only'])
      detail.push([cmd, `Original error: ${er.mes...
__ecma.Array.factory()
__ecma.Array.factory()
__ecma.Array.factory()
er.message
er.message = replaceInfo(er.message)
er.stack
er.stack = replaceInfo(er.stack)
er.code
"EACCES"
"EPERM"
const isCachePath =
        typeof er.path === 'string' &&
        npm.config.loaded &&
        er.path.startsWith(npm.config.get('cache'))
typeof er.path === 'string' &&
        npm.config.loaded &&
        er.path.startsWith(npm.config.get('cache'))
npm.config.loaded
er.path.startsWith(npm.config.get('cache'))
typeof er.dest === 'string' &&
        npm.config.loaded &&
        er.dest.startsWith(npm.config.get('cache'))
npm.config.loaded
er.dest.startsWith(npm.config.get('cache'))
