async gatherBundles () {
    if (this.seen.has(this.tree)) {
      return
    }

    // add this node to our seen tracker
    this.seen.add(this.tree)

    // if we're the project root, then we look at our bundleDependencies, otherwise we got here
    // because we're a bundled dependency of the root, which means we need to include all prod
    // and optional dependencies in the bundle
    let toBundle
    if (this.tree.isProjectRoot) {
      const { bundleDependencies } = this.tree.package
      toBundle = bundleDependencies || []
    } else {
      const { dependencies, optionalDependencies } = this.tree.package
      toBundle = Object.keys(dependencies || {}).concat(Object.keys(optionalDependencies || {}))
    }

    for (const dep of toBundle) {
      const edge = this.tree.edgesOut.get(dep)
      // no edgeOut = missing node, so skip it. we can't pack it if it's not here
      // we also refuse to pack peer dependencies and dev dependencies
      if (!edge || edge.peer || edge...
(_tmp_51 = this.seen).has
(_tmp_52 = this.seen).add
this.tree.isProjectRoot
bundleDependencies = _tmp_53.bundleDependencies
toBundle = bundleDependencies || []
optionalDependencies = _tmp_54.optionalDependencies
toBundle = Object.keys(dependencies || {}).concat(Object.keys(optionalDependencies || {}))
_iterator_3 = <operator>.iterator(toBundle)
const edge = this.tree.edgesOut.get(dep)
!edge || edge.peer || edge.dev
continue
const node = this.tree.edgesOut.get(dep).to
!node
continue
const path = node.path
const tree = node.target
const walkerOpts = {
        path,
        isPackage: true,
        ignoreFiles: [],
        seen: this.seen, // pass through seen so we can prevent infinite circular loops
      }
_tmp_60.path = path
_tmp_60.isPackage = true
_tmp_60.ignoreFiles = __ecma.Array.factory()
_tmp_60.seen = this.seen
node.isLink
walkerOpts.ignoreFiles.push(defaultRules)
walkerOpts.ignoreFiles.push('package.json')
node.isLink
walkerOpts.ignoreFiles.push('.npmignore')
walkerOpts.ignoreFiles.push('.gitignore')
walkerOpts.ignoreFiles.push(strictRules)
const walker = new PackWalker(tree, walkerOpts)
const bundled = await new Promise((pResolve, pReject) => {
        walker.on('error', pReject)
        walker.on('done', pResolve)
        walker.start()
      })
const relativeFrom = relative(this.root, walker.path)
_iterator_4 = <operator>.iterator(bundled)
this.result.add(join(relativeFrom, file).replace(/\\/g, '/'))
