config.load(settings, function (config) {
    if (!config.options.dump && !config.options.execOptions.script &&
      config.options.execOptions.exec === 'node') {
      if (!config.required) {
        console.log(help('usage'));
        process.exit();
      }
      return;
    }

    // before we print anything, update the colour setting on logging
    utils.colours = config.options.colours;

    // always echo out the current version
    utils.log.info(version.pinned);

    const cwd = process.cwd();

    if (config.options.cwd) {
      utils.log.detail('process root: ' + cwd);
    }

    config.loaded.map(file => file.replace(cwd, '.')).forEach(file => {
      utils.log.detail('reading config ' + file);
    });

    if (config.options.stdin && config.options.restartable) {
      // allow nodemon to restart when the use types 'rs\n'
      process.stdin.resume();
      process.stdin.setEncoding('utf8');
      process.stdin.on('data', data => {
        const str = data.toString().t...
!config.options.dump && !config.options.execOptions.script &&
      config.options.execOptions.exec === 'node'
config.options.execOptions.exec === 'node'
utils.colours = config.options.colours
utils.log.info(version.pinned)
const cwd = process.cwd()
config.options.cwd
utils.log.detail('process root: ' + cwd)
config.loaded.map(file => file.replace(cwd, '.')).forEach(file => {
      utils.log.detail('reading config ' + file);
    })
config.options.stdin && config.options.restartable
(_tmp_7 = process.stdin).resume
(_tmp_8 = process.stdin).setEncoding
process.stdin.on('data', data => {
        const str = data.toString().trim().toLowerCase();

        // if the keys entered match the restartable value, then restart!
        if (str === config.options.restartable) {
          bus.emit('restart');
        } else if (data.charCodeAt(0) === 12) { // ctrl+l
          console.clear();
        }
      })
config.options.stdin
var ctrlC = false
var buffer = ''
process.stdin.on('data', function (data) {
        data = data.toString();
        buffer += data;
        const chr = data.charCodeAt(0);

        // if restartable, echo back
        if (chr === 3) {
          if (ctrlC) {
            process.exit(0);
          }

          ctrlC = true;
          return;
        } else if (buffer === '.exit' || chr === 4) { // ctrl+d
          process.exit();
        } else if (chr === 13 || chr === 10) { // enter / carriage return
          buffer = '';
        } else if (chr === 12) { // ctrl+l
          console.clear();
          buffer = '';
        }
        ctrlC = false;
      })
process.stdin.setRawMode
(_tmp_13 = process.stdin).setRawMode
config.options.restartable
utils.log.info('to restart at any time, enter `' +
        config.options.restartable + '`')
config.options.restartable
!config.required
const restartSignal = config.options.signal === 'SIGUSR2' ? 'SIGHUP' : 'SIGUSR2'
process.on(restartSignal, nodemon.restart)
utils.bus.on('error', () => {
        utils.log.fail((new Error().stack));
      })
utils.log.detail((config.options.restartable ? 'or ' : '') + 'send ' +
        restartSignal + ' to ' + process.pid + ' to restart')
process.pid
const ignoring = config.options.monitor.map(function (rule) {
      if (rule.slice(0, 1) !== '!') {
        return false;
      }

      rule = rule.slice(1);

      // don't notify of default ignores
      if (defaults.ignoreRoot.indexOf(rule) !== -1) {
        return false;
        return rule.slice(3).slice(0, -3);
      }

      if (rule.startsWith(cwd)) {
        return rule.replace(cwd, '.');
      }

      return rule;
    }).filter(Boolean).join(' ')
join
utils.log.detail('ignoring: ' + ignoring)
utils.log.info('watching path(s): ' + config.options.monitor.map(function (rule) {
      if (rule.slice(0, 1) !== '!') {
        try {
          rule = path.relative(process.cwd(), rule);
        } catch (e) {}

        return rule;
      }

      return false;
    }).filter(Boolean).join(' '))
join
utils.log.info('watching extensions: ' + (config.options.execOptions.ext || '(all)'))
config.options.dump
utils.log._log('log', '--------------')
utils.log._log('log', 'node: ' + process.version)
utils.log._log('log', 'nodemon: ' + version.pinned)
utils.log._log('log', 'command: ' + process.argv.join(' '))
utils.log._log('log', 'cwd: ' + cwd)
utils.log._log('log', ['OS:', process.platform, process.arch].join(' '))
utils.log._log('log', '--------------')
utils.log._log('log', util.inspect(config, { depth: null }))
utils.log._log('log', '--------------')
!config.required
process.exit()
