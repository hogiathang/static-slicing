function readDOMChange = function readDOMChange(view: EditorView, from: number, to: number, typeOver: boolean, addedNodes: readonly DOMNode[]) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0)
  view.input.compositionPendingChanges = 0
  
  if (from < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null
    let newSel = selectionFromDOM(view, origin)
    if (newSel && !view.state.selection.eq(newSel)) {
      if (browser.chrome && browser.android &&
          view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime &&
          view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter"))))
        return
      let tr = view.state.tr.setSelection(newSel)
      if (origin == "pointer") tr.setMeta("pointer", true)
      else if (origin == "key") tr.scrollIntoView()
      if (compositionID) tr.setMeta("composition", compositionID)
      view.dispatch(tr)
    }
    ret...
let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0)
view.input.compositionPendingChanges = 0
from < 0
let $before = view.state.doc.resolve(from)
let shared = $before.sharedDepth(to)
from = $before.before(shared + 1)
to = view.state.doc.resolve(to).after(shared + 1)
let sel = view.state.selection
let parse = parseBetween(view, from, to)
let compare = doc.slice(parse.from, parse.to)
view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime
preferredPos = view.state.selection.to
preferredSide = "end"
preferredPos = view.state.selection.from
preferredSide = "start"
view.input.lastKeyCode = null
let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide)
(browser.ios && view.input.lastIOSEnter > Date.now() - 225 || browser.android) &&
      addedNodes.some(n => n.nodeType == 1 && !isInline.test(n.nodeName)) &&
      (!change || change.endA >= change.endB) &&
      view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")))
addedNodes.some(n => n.nodeType == 1 && !isInline.test(n.nodeName))
!change || change.endA >= change.endB
view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")))
!change
typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&
        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)
!(parse.sel && parse.sel.anchor != parse.sel.head)
change = {start: sel.from, endA: sel.to, endB: sel.to}
browser.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from &&
      parse.sel.head == parse.sel.anchor
parse.sel.head == parse.sel.anchor
let size = change.endB - change.start
parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size}
view.input.domChangeCount++
view.state.selection.from < view.state.selection.to &&
      change.start == change.endB &&
      view.state.selection instanceof TextSelection
change.start == change.endB
view.state.selection instanceof TextSelection
change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 &&
        view.state.selection.from >= parse.from
view.state.selection.from >= parse.from
change.start = view.state.selection.from
change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 &&
               view.state.selection.to <= parse.to
view.state.selection.to <= parse.to
change.endB += (view.state.selection.to - change.endA)
change.endA = view.state.selection.to
browser.ie && browser.ie_version <= 11 && change.endB == change.start + 1 &&
      change.endA == change.start && change.start > parse.from &&
      parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \u00a0"
change.endA == change.start
parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \u00a0"
change.start--
change.endA--
change.endB--
let $from = parse.doc.resolveNoCache(change.start - parse.from)
let $to = parse.doc.resolveNoCache(change.endB - parse.from)
let $fromA = doc.resolve(change.start)
let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA
((browser.ios && view.input.lastIOSEnter > Date.now() - 225 &&
        (!inlineChange || addedNodes.some(n => n.nodeName == "DIV" || n.nodeName == "P"))) ||
       (!inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) &&
        (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&
        nextSel.head == $to.pos)) &&
      view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")))
!inlineChange || addedNodes.some(n => n.nodeName == "DIV" || n.nodeName == "P")
!inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) &&
        (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&
        nextSel.head == $to.pos
nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)
nextSel.head == $to.pos
view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")))
view.state.selection.anchor > change.start &&
      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&
      view.someProp("handleKeyDown", f => f(view, keyEvent(8, "Backspace")))
looksLikeJoin(doc, change.start, change.endA, $from, $to)
view.someProp("handleKeyDown", f => f(view, keyEvent(8, "Backspace")))
browser.chrome && browser.android && change.endB == change.start
view.input.lastAndroidDelete = Date.now()
browser.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&
      parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA
parse.sel.anchor == parse.sel.head
change.endB -= 2
$to = parse.doc.resolveNoCache(change.endB - parse.from)
setTimeout(() => {
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); })
    }, 20)
