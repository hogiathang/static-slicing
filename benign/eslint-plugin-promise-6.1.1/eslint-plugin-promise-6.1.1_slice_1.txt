_getAlreadyResolvedData(segment, promiseCodePathContext) {
    const prevSegments = segment.prevSegments.filter(
      (prev) => !promiseCodePathContext.isResolvedTryBlockCodePathSegment(prev)
    )
    if (prevSegments.length === 0) {
      return null
    }
    const prevSegmentInfos = prevSegments.map((prev) =>
      this._getProcessedSegmentInfo(prev, promiseCodePathContext)
    )
    if (prevSegmentInfos.every((info) => info.resolved)) {
      // If the previous paths are all resolved, the next path is also resolved.
      return {
        resolved: prevSegmentInfos[0].resolved,
        kind: 'certain',
      }
    }

    for (const prevSegmentInfo of prevSegmentInfos) {
      if (prevSegmentInfo.resolved) {
        // If the previous path is partially resolved,
        // then the next path is potentially resolved.
        return {
          resolved: prevSegmentInfo.resolved,
          kind: 'potential',
        }
      }
      if (prevSegmentInfo.potentiallyResolved) {
     ...
const prevSegments = segment.prevSegments.filter(
      (prev) => !promiseCodePathContext.isResolvedTryBlockCodePathSegment(prev)
    )
!promiseCodePathContext.isResolvedTryBlockCodePathSegment(prev)
prevSegments.length === 0
const prevSegmentInfos = prevSegments.map((prev) =>
      this._getProcessedSegmentInfo(prev, promiseCodePathContext)
    )
prevSegmentInfos.every((info) => info.resolved)
_iterator_10 = <operator>.iterator(prevSegmentInfos)
prevSegmentInfo.resolved
prevSegmentInfo.potentiallyResolved
let potential = false
prevSegmentInfo.segment.nextSegments.length === 1
potential = true
const segmentInfo = this.segmentInfos.get(segment)
segmentInfo && segmentInfo.resolved
prevSegmentInfo.segment.nextSegments.every((next) => {
                const nextSegmentInfo = this.segmentInfos.get(next)
                return (
                  nextSegmentInfo &&
                  nextSegmentInfo.resolved === segmentInfo.resolved
                )
              })
potential = true
