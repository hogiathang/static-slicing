var _u=class extends eL{constructor(){super(),this[Bs]=new AL,this[hA]=[],this[fs]=0;let A=this;this[Hu]=function(r,n){let i=A[Bs],s=!1;for(;!s;){let o=i.shift();if(!o)break;A[fs]--,s=!this.dispatch(o.opts,o.handler)}this[sA]=s,!this[sA]&&A[sA]&&(A[sA]=!1,A.emit("drain",r,[A,...n])),A[Ou]&&i.isEmpty()&&Promise.all(A[hA].map(o=>o.close())).then(A[Ou])},this[wp]=(t,r)=>{A.emit("connect",t,[A,...r])},this[Rp]=(t,r,n)=>{A.emit("disconnect",t,[A,...r],n)},this[Dp]=(t,r,n)=>{A.emit("connectionError",t,[A,...r],n)},this[bp]=new aL(this)}get[tL](){return this[sA]}get[qu](){return this[hA].filter(A=>A[qu]).length}get[rL](){return this[hA].filter(A=>A[qu]&&!A[sA]).length}get[yp](){let A=this[fs];for(let{[yp]:t}of this[hA])A+=t;return A}get[mp](){let A=0;for(let{[mp]:t}of this[hA])A+=t;return A}get[pp](){let A=this[fs];for(let{[pp]:t}of this[hA])A+=t;return A}get stats(){return this[bp]}async[iL](){return this[Bs].isEmpty()?Promise.all(this[hA].map(A=>A.close())):new Promise(A=>{this[Ou]=A})}async...
