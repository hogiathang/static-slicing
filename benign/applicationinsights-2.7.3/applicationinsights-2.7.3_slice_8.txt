__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        payload = Util.stringify(envelope);
                        options = (_a = {},
                            _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = true,
                            _a.host = (redirectedHostEndpoint && redirectedHostEndpoint.length > 0) ? redirectedHostEndpoint : this._config.quickPulseHost,
                            _a.method = QuickPulseConfig.method,
                            _a.path = "/QuickPulseService.svc/" + postOrPing + "?ikey=" + this._config.instrumentationKey,
                            _a.headers = (_b = {
                                    "Expect": "100-continue"
                                },
                                _b[QuickPulseConfig.time] = QuickPulseUtil.getTransmissionTime(),
                                _b["Content-Type"] = "application\/json",
                     ...
_c.label
4
this._config.httpsAgent
options.agent = this._config.httpsAgent
options.agent = Util.tlsRestrictedAgent
req = https.request(options, function (res) {
                            if (res.statusCode == 200) {
                                var shouldPOSTData = res.headers[QuickPulseConfig.subscribed] === "true";
                                var redirectHeader = null;
                                try {
                                    redirectHeader = res.headers[QuickPulseConfig.endpointRedirect] ? new url.URL(res.headers[QuickPulseConfig.endpointRedirect].toString()).host : null;
                                }
                                catch (error) {
                                    _this._onError("Failed to parse redirect header from QuickPulse: " + Util.dumpObj(error));
                                }
                                var pollingIntervalHint = res.headers[QuickPulseConfig.pollingIntervalHint] ? parseInt(res.headers[QuickPulseConfig.pollingIntervalHint].toString()) : null;
                                _this._consecutiveErrors = 0;...
req.on("error", function (error) {
                            _this._onError(error);
                            done();
                        })
req.write(payload)
