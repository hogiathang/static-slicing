CollectionBase.prototype.set = function(models, options) {
  options = _.defaults({}, options, setOptions);
  if (!Array.isArray(models)) models = models ? [models] : [];
  if (options.parse) models = this.parse(models, options);
  let i, l, id, model, attrs;
  const at = options.at;
  const targetModel = this.model;
  const toAdd = [];
  const toRemove = [];
  const modelMap = {};
  let order = options.add && options.remove ? [] : false;

  // Turn bare objects into model references, and prevent invalid models
  // from being added.
  for (i = 0, l = models.length; i < l; i++) {
    attrs = models[i];
    if (attrs instanceof ModelBase) {
      id = model = attrs;
    } else {
      id = attrs[targetModel.prototype.idAttribute];
    }

    // If a duplicate is found, prevent it from being added and
    // optionally merge it into the existing model.
    const existing = this.get(id);
    if (existing && (options.merge || options.remove)) {
      if (options.remove) {
        modelM...
options = _.defaults({}, options, setOptions)
models ? [models] : __ecma.Array.factory()
models = this.parse(models, options)
const at = options.at
const targetModel = this.model
__ecma.Array.factory()
__ecma.Array.factory()
const modelMap = {}
options.add && options.remove ? __ecma.Array.factory() : false
l = models.length
attrs = models[i]
attrs instanceof ModelBase
id = model = attrs
id = attrs[targetModel.prototype.idAttribute]
const existing = this.get(id)
existing && (options.merge || options.remove)
options.remove
modelMap[existing.cid] = true
options.merge
attrs = attrs === model ? model.attributes : attrs
attrs = existing.parse(attrs, options)
existing.set(attrs, options)
options.add
!(model = this._prepareModel(attrs, options))
toAdd.push(model)
this._byId[this.idKey(model.cid)] = model
this._byId[this.idKey(model.id)] = model
order && !(existing && order.indexOf(existing) > -1)
