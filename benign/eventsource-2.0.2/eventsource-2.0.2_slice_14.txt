ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal...
var self = this
self._destroyed
var opts = self._opts
var headersObj = self._headers
var body = null
opts.method !== 'GET' && opts.method !== 'HEAD'
capability.arraybuffer
body = toArrayBuffer(Buffer.concat(self._body))
capability.blobConstructor
body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
_tmp_376.type = (headersObj['content-type'] || {}).value || ''
(_tmp_378 = Buffer.concat(self._body)).toString
__ecma.Array.factory()
Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})
self._mode === 'fetch'
var xhr = self._xhr = new global.XMLHttpRequest()
xhr.open(self._opts.method, self._opts.url, true)
'responseType' in xhr
xhr.responseType = self._mode.split(':')[0]
'withCredentials' in xhr
xhr.withCredentials = !!opts.withCredentials
self._mode === 'text' && 'overrideMimeType' in xhr
xhr.overrideMimeType('text/plain; charset=x-user-defined')
'requestTimeout' in opts
xhr.timeout = opts.requestTimeout
xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})
self._response = null
xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
self._mode === 'moz-chunked-arraybuffer'
xhr.onprogress = function () {
				self._onXHRProgress()
			}
xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}
xhr.send(body)
