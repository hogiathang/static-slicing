function nmfetch = function nmfetch(url, options) {
    options = options || {};

    options.fetchRes = options.fetchRes || new PassThrough();
    options.cookies = options.cookies || new Cookies();
    options.redirects = options.redirects || 0;
    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;

    if (options.cookie) {
        [].concat(options.cookie || []).forEach(cookie => {
            options.cookies.set(cookie, url);
        });
        options.cookie = false;
    }

    let fetchRes = options.fetchRes;
    let parsed = urllib.parse(url);
    let method = (options.method || '').toString().trim().toUpperCase() || 'GET';
    let finished = false;
    let cookies;
    let body;

    let handler = parsed.protocol === 'https:' ? https : http;

    let headers = {
        'accept-encoding': 'gzip,deflate',
        'user-agent': 'nodemailer/' + packageData.version
    };

    Object.keys(options.headers || {}).forEach(key => {
        headers[key.toLower...
options = options || {}
options.fetchRes = options.fetchRes || new PassThrough()
options.cookies = options.cookies || new Cookies()
options.redirects = options.redirects || 0
options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects
options.cookie
[].concat(options.cookie || []).forEach(cookie => {
            options.cookies.set(cookie, url);
        })
options.cookie = false
let fetchRes = options.fetchRes
let parsed = urllib.parse(url)
let method = (options.method || '').toString().trim().toUpperCase() || 'GET'
let finished = false
let handler = parsed.protocol === 'https:' ? https : http
let headers = {
        'accept-encoding': 'gzip,deflate',
        'user-agent': 'nodemailer/' + packageData.version
    }
_tmp_9.accept-encoding = "gzip,deflate"
_tmp_9.user-agent = 'nodemailer/' + packageData.version
Object.keys(options.headers || {}).forEach(key => {
        headers[key.toLowerCase().trim()] = options.headers[key];
    })
options.userAgent
headers['user-agent'] = options.userAgent
parsed.auth
headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64')
cookies = options.cookies.get(url)
headers.cookie = cookies
options.body
options.contentType !== false
headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded'
typeof options.body.pipe === 'function'
headers['Transfer-Encoding'] = 'chunked'
body = options.body
body.on('error', err => {
                if (finished) {
                    return;
                }
                finished = true;
                err.type = 'FETCH';
                err.sourceUrl = url;
                fetchRes.emit('error', err);
            })
options.body instanceof Buffer
body = options.body
typeof options.body === 'object'
body = Buffer.from(
                        Object.keys(options.body)
                            .map(key => {
                                let value = options.body[key].toString().trim();
                                return encodeURIComponent(key) + '=' + encodeURIComponent(value);
                            })
                            .join('&')
                    )
Object.keys(options.body)
                            .map(key => {
                                let value = options.body[key].toString().trim();
                                return encodeURIComponent(key) + '=' + encodeURIComponent(value);
                            })
                            .join('&')
<lambda>3
join
body = Buffer.from(options.body.toString().trim())
headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded'
headers['Content-Length'] = body.length
method = (options.method || '').toString().trim().toUpperCase() || 'POST'
let reqOptions = {
        method,
        host: parsed.hostname,
        path: parsed.path,
        port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,
        headers,
        rejectUnauthorized: false,
        agent: false
    }
_tmp_24.method = method
_tmp_24.host = parsed.hostname
_tmp_24.path = parsed.path
_tmp_24.port = parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80
_tmp_24.headers = headers
_tmp_24.rejectUnauthorized = false
_tmp_24.agent = false
options.tls
Object.keys(options.tls).forEach(key => {
            reqOptions[key] = options.tls[key];
        })
parsed.protocol === 'https:' && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername
reqOptions.servername = parsed.hostname
req = handler.request(reqOptions)
options.timeout
req.setTimeout(options.timeout, () => {
            if (finished) {
                return;
            }
            finished = true;
            req.abort();
            let err = new Error('Request Timeout');
            err.type = 'FETCH';
            err.sourceUrl = url;
            fetchRes.emit('error', err);
        })
