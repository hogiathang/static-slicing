function TabNavList = function TabNavList(props, ref) {
  var _classNames;
  var _React$useContext = React.useContext(TabContext),
    prefixCls = _React$useContext.prefixCls,
    tabs = _React$useContext.tabs;
  var className = props.className,
    style = props.style,
    id = props.id,
    animated = props.animated,
    activeKey = props.activeKey,
    rtl = props.rtl,
    extra = props.extra,
    editable = props.editable,
    locale = props.locale,
    tabPosition = props.tabPosition,
    tabBarGutter = props.tabBarGutter,
    children = props.children,
    onTabClick = props.onTabClick,
    onTabScroll = props.onTabScroll,
    indicatorSize = props.indicatorSize;
  var containerRef = useRef();
  var extraLeftRef = useRef();
  var extraRightRef = useRef();
  var tabsWrapperRef = useRef();
  var tabListRef = useRef();
  var operationsRef = useRef();
  var innerAddButtonRef = useRef();
  // const [getBtnRef, removeBtnRef] = useRefs<HTMLDivElement>();

  var tabPositionTopOrBottom = tabPosition === 'to...
var _React$useContext = React.useContext(TabContext)
var prefixCls = _React$useContext.prefixCls
var tabs = _React$useContext.tabs
var className = props.className
var style = props.style
var id = props.id
var animated = props.animated
var activeKey = props.activeKey
var rtl = props.rtl
var extra = props.extra
var editable = props.editable
var locale = props.locale
var tabPosition = props.tabPosition
var tabBarGutter = props.tabBarGutter
var children = props.children
var onTabClick = props.onTabClick
var onTabScroll = props.onTabScroll
var indicatorSize = props.indicatorSize
var containerRef = useRef()
var extraLeftRef = useRef()
var extraRightRef = useRef()
var tabsWrapperRef = useRef()
var tabListRef = useRef()
var operationsRef = useRef()
var innerAddButtonRef = useRef()
var tabPositionTopOrBottom = tabPosition === 'top' || tabPosition === 'bottom'
var _useSyncState = useSyncState(0, function (next, prev) {
      if (tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next > prev ? 'left' : 'right'
        });
      }
    })
var _useSyncState2 = _slicedToArray(_useSyncState, 2)
var transformLeft = _useSyncState2[0]
var setTransformLeft = _useSyncState2[1]
var _useSyncState3 = useSyncState(0, function (next, prev) {
      if (!tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next > prev ? 'top' : 'bottom'
        });
      }
    })
var _useSyncState4 = _slicedToArray(_useSyncState3, 2)
var transformTop = _useSyncState4[0]
var setTransformTop = _useSyncState4[1]
var _useState = useState([0, 0])
var _useState2 = _slicedToArray(_useState, 2)
var containerExcludeExtraSize = _useState2[0]
var setContainerExcludeExtraSize = _useState2[1]
var _useState3 = useState([0, 0])
var _useState4 = _slicedToArray(_useState3, 2)
var tabContentSize = _useState4[0]
var setTabContentSize = _useState4[1]
var _useState5 = useState([0, 0])
var _useState6 = _slicedToArray(_useState5, 2)
var addSize = _useState6[0]
var setAddSize = _useState6[1]
var _useState7 = useState([0, 0])
var _useState8 = _slicedToArray(_useState7, 2)
var operationSize = _useState8[0]
var setOperationSize = _useState8[1]
var _useUpdateState = useUpdateState(new Map())
var _useUpdateState2 = _slicedToArray(_useUpdateState, 2)
var tabSizes = _useUpdateState2[0]
var setTabSizes = _useUpdateState2[1]
var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0])
var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom)
var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom)
var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom)
var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom)
var needScroll = containerExcludeExtraSizeValue < tabContentSizeValue + addSizeValue
var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue
var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden")
var transformMin = 0
var transformMax = 0
!tabPositionTopOrBottom
transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue)
transformMax = 0
transformMin = 0
transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue)
transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue)
transformMax = 0
function alignInRange = function alignInRange(value) {
    if (value < transformMin) {
      return transformMin;
    }
    if (value > transformMax) {
      return transformMax;
    }
    return value;
  }
var touchMovingRef = useRef()
var _useState9 = useState()
var _useState10 = _slicedToArray(_useState9, 2)
var lockAnimation = _useState10[0]
var setLockAnimation = _useState10[1]
function doLockAnimation = function doLockAnimation() {
    setLockAnimation(Date.now());
  }
function clearTouchMoving = function clearTouchMoving() {
    window.clearTimeout(touchMovingRef.current);
  }
useTouchMove(tabsWrapperRef, function (offsetX, offsetY) {
    function doMove(setState, offset) {
      setState(function (value) {
        var newValue = alignInRange(value + offset);
        return newValue;
      });
    }

    // Skip scroll if place is enough
    if (!needScroll) {
      return false;
    }
    if (tabPositionTopOrBottom) {
      doMove(setTransformLeft, offsetX);
    } else {
      doMove(setTransformTop, offsetY);
    }
    clearTouchMoving();
    doLockAnimation();
    return true;
  })
useEffect(function () {
    clearTouchMoving();
    if (lockAnimation) {
      touchMovingRef.current = window.setTimeout(function () {
        setLockAnimation(0);
      }, 100);
    }
    return clearTouchMoving;
  }, [lockAnimation])
_tmp_8 = __ecma.Array.factory()
var _useVisibleRange = useVisibleRange(tabOffsets,
    // Container
    visibleTabContentValue,
    // Transform
    tabPositionTopOrBottom ? transformLeft : transformTop,
    // Tabs
    tabContentSizeValue,
    // Add
    addSizeValue,
    // Operation
    operationSizeValue, _objectSpread(_objectSpread({}, props), {}, {
      tabs: tabs
    }))
tabPositionTopOrBottom ? transformLeft : transformTop
_objectSpread(_objectSpread({}, props), {}, {
      tabs: tabs
    })
_tmp_11.tabs = tabs
var _useVisibleRange2 = _slicedToArray(_useVisibleRange, 2)
var visibleStart = _useVisibleRange2[0]
var visibleEnd = _useVisibleRange2[1]
var scrollToTab = useEvent(function () {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : activeKey;
    var tabOffset = tabOffsets.get(key) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (tabPositionTopOrBottom) {
      // ============ Align with top & bottom ============
      var newTransform = transformLeft;

      // RTL
      if (rtl) {
        if (tabOffset.right < transformLeft) {
          newTransform = tabOffset.right;
        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
        }
      }
      // LTR
      else if (tabOffset.left < -transformLeft) {
        newTransform = -tabOffset.left;
      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
  ...
var tabNodeStyle = {}
tabPosition === 'top' || tabPosition === 'bottom'
tabNodeStyle[rtl ? 'marginRight' : 'marginLeft'] = tabBarGutter
tabNodeStyle.marginTop = tabBarGutter
var tabNodes = tabs.map(function (tab, i) {
    var key = tab.key;
    return /*#__PURE__*/React.createElement(TabNode, {
      id: id,
      prefixCls: prefixCls,
      key: key,
      tab: tab
      /* first node should not have margin left */,
      style: i === 0 ? undefined : tabNodeStyle,
      closable: tab.closable,
      editable: editable,
      active: key === activeKey,
      renderWrapper: children,
      removeAriaLabel: locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,
      onClick: function onClick(e) {
        onTabClick(key, e);
      },
      onFocus: function onFocus() {
        scrollToTab(key);
        doLockAnimation();
        if (!tabsWrapperRef.current) {
          return;
        }
        // Focus element will make scrollLeft change which we should reset back
        if (!rtl) {
          tabsWrapperRef.current.scrollLeft = 0;
        }
        tabsWrapperRef.current.scrollTop = 0;
      }
    });
  })
var updateTabSizes = function updateTabSizes() {
    return setTabSizes(function () {
      var newSizes = new Map();
      tabs.forEach(function (_ref2) {
        var _tabListRef$current;
        var key = _ref2.key;
        var btnNode = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.querySelector("[data-node-key=\"".concat(genDataNodeKey(key), "\"]"));
        if (btnNode) {
          newSizes.set(key, {
            width: btnNode.offsetWidth,
            height: btnNode.offsetHeight,
            left: btnNode.offsetLeft,
            top: btnNode.offsetTop
          });
        }
      });
      return newSizes;
    });
  }
useEffect(function () {
    updateTabSizes();
  }, [tabs.map(function (tab) {
    return tab.key;
  }).join('_')])
_tmp_18.push(tabs.map(function (tab) {
    return tab.key;
  }).join('_'))
join
var onListHolderResize = useUpdate(function () {
    // Update wrapper records
    var containerSize = getSize(containerRef);
    var extraLeftSize = getSize(extraLeftRef);
    var extraRightSize = getSize(extraRightRef);
    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
    var newAddSize = getSize(innerAddButtonRef);
    setAddSize(newAddSize);
    var newOperationSize = getSize(operationsRef);
    setOperationSize(newOperationSize);

    // Which includes add button size
    var tabContentFullSize = getSize(tabListRef);
    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);

    // Update buttons records
    updateTabSizes();
  })
var startHiddenTabs = tabs.slice(0, visibleStart)
var endHiddenTabs = tabs.slice(visibleEnd + 1)
var hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs))
var activeTabOffset = tabOffsets.get(activeKey)
var _useIndicator = useIndicator({
      activeTabOffset: activeTabOffset,
      horizontal: tabPositionTopOrBottom,
      rtl: rtl,
      indicatorSize: indicatorSize
    })
_tmp_23.activeTabOffset = activeTabOffset
_tmp_23.horizontal = tabPositionTopOrBottom
_tmp_23.rtl = rtl
_tmp_23.indicatorSize = indicatorSize
var indicatorStyle = _useIndicator.style
useEffect(function () {
    scrollToTab();
    // eslint-disable-next-line
  }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom])
_tmp_24.push(stringify(activeTabOffset))
