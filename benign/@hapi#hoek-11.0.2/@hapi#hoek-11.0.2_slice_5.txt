module.exports = function (obj, chain, options) {

    if (chain === false ||
        chain === null ||
        chain === undefined) {

        return obj;
    }

    options = options || {};
    if (typeof options === 'string') {
        options = { separator: options };
    }

    const isChainArray = Array.isArray(chain);

    Assert(!isChainArray || !options.separator, 'Separator option is not valid for array-based chain');

    const path = isChainArray ? chain : chain.split(options.separator || '.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);

        if (Array.isArray(ref) ||
            type === 'set') {

            const number = Number(key);
            if (Number.isInteger(number)) {
                key = number < 0 ? ref.length + number : number;
            }
        }

        if (!ref ||
            typeof ref === 'function' && options.functions === fals...
chain === false ||
        chain === null ||
        chain === undefined
chain === null
chain === undefined
options = options || {}
typeof options === 'string'
options = { separator: options }
const isChainArray = Array.isArray(chain)
Assert(!isChainArray || !options.separator, 'Separator option is not valid for array-based chain')
const path = isChainArray ? chain : chain.split(options.separator || '.')
let ref = obj
i < path.length
let key = path[i]
const type = options.iterables && internals.iterables(ref)
Array.isArray(ref) ||
            type === 'set'
type === 'set'
const number = Number(key)
Number.isInteger(number)
key = number < 0 ? ref.length + number : number
!ref ||
            typeof ref === 'function' && options.functions === false ||         // Defaults to true
            !type && ref[key] === undefined
typeof ref === 'function' && options.functions === false
!type && ref[key] === undefined
!type
ref = ref[key]
type === 'set'
_tmp_3 = __ecma.Array.factory()
ref = ref.get(key)
