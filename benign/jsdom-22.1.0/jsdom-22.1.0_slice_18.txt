send(body) {
    const { flag, properties, upload, _ownerDocument } = this;
    // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65
    if (!_ownerDocument) {
      throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
    }

    if (this.readyState !== READY_STATES.OPENED || properties.send) {
      throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
    }

    properties.beforeSend = true;

    try {
      if (flag.method === "GET" || flag.method === "HEAD") {
        body = null;
      }

      if (body !== null) {
        let encoding = null;
        let mimeType = null;

        if (Document.isImpl(body)) {
          encoding = "UTF-8";
          mimeType = (body._parsingMode === "html" ? "text/html" : "application/xml") + ";charset=UTF-8";
          flag.body = fragmentSerialization(body, { requireWellFormed: false });
        } else {
          if ...
_ownerDocument = _tmp_108._ownerDocument
!_ownerDocument
throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
this.readyState !== READY_STATES.OPENED || properties.send
throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
properties.beforeSend = true
flag.method === "GET" || flag.method === "HEAD"
body = null
body !== null
let encoding = null
let mimeType = null
Document.isImpl(body)
encoding = "UTF-8"
mimeType = (body._parsingMode === "html" ? "text/html" : "application/xml") + ";charset=UTF-8"
flag.body = fragmentSerialization(body, { requireWellFormed: false })
typeof body === "string"
encoding = "UTF-8"
contentType = _tmp_112.contentType
mimeType = contentType
flag.body = buffer || formData
flag.formData = Boolean(formData)
const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, "content-type")
mimeType !== null && existingContentType === null
flag.requestHeaders["Content-Type"] = mimeType
existingContentType !== null && encoding !== null
const parsed = MIMEType.parse(existingContentType)
const charset = parsed.parameters.get("charset")
charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null
parsed.parameters.set("charset", encoding)
xhrUtils.updateRequestHeader(flag.requestHeaders, "content-type", parsed.toString())
properties.beforeSend
properties.beforeSend = false
throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
Object.keys(upload._eventListeners).length > 0
properties.uploadListener = true
flag.body && flag.body.byteLength === 0
flag.body = null
flag.synchronous
const flagStr = JSON.stringify(flag, function (k, v) {
        if (this === flag && k === "requestManager") {
          return null;
        }
        if (this === flag && k === "pool" && v) {
          return { maxSockets: v.maxSockets };
        }
        return v;
      })
process.execPath
_tmp_117 = __ecma.Array.factory()
_tmp_118.maxBuffer = Infinity
