const handleAck: PacketHandler = (client, packet) => {
	/* eslint no-fallthrough: "off" */
	const { messageId } = packet
	const type = packet.cmd
	let response = null
	const cb = client.outgoing[messageId] ? client.outgoing[messageId].cb : null
	let err

	// Checking `!cb` happens to work, but it's not technically "correct".
	//
	// Why? client code assumes client "no callback" is the same as client "we're not
	// waiting for responses" (puback, pubrec, pubcomp, suback, or unsuback).
	//
	// It would be better to check `if (!client.outgoing[messageId])` here, but
	// there's no reason to change it and risk (another) regression.
	//
	// The only reason client code works is becaues code in MqttClient.publish,
	// MqttClinet.subscribe, and MqttClient.unsubscribe ensures client we will
	// have a callback even if the user doesn't pass one in.)
	if (!cb) {
		client.log('_handleAck :: Server sent an ack in error. Ignoring.')
		// Server sent an ack in error, ignore it.
		return
	}

	// Process
...
messageId = _tmp_1.messageId
const type = packet.cmd
let response = null
const cb = client.outgoing[messageId] ? client.outgoing[messageId].cb : null
!cb
client.log('_handleAck :: packet type', type)
default:
client.emit('error', new Error('unrecognized packet type'))
