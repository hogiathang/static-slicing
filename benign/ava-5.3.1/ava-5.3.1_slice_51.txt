const run = async options => {
	setOptions(options);
	setChalk(options.chalkOptions);

	if (options.chalkOptions.level > 0) {
		const {stdout, stderr} = process;
		global.console = Object.assign(global.console, new console.Console({stdout, stderr, colorMode: true}));
	}

	let checkSelectedByLineNumbers;
	try {
		checkSelectedByLineNumbers = lineNumberSelection({
			file: options.file,
			lineNumbers: options.lineNumbers,
		});
	} catch (error) {
		channel.send({type: 'line-number-selection-error', err: serializeError('Line number selection error', false, error, options.file)});
		checkSelectedByLineNumbers = () => false;
	}

	runner = new Runner({
		checkSelectedByLineNumbers,
		experiments: options.experiments,
		failFast: options.failFast,
		failWithoutAssertions: options.failWithoutAssertions,
		file: options.file,
		match: options.match,
		projectDir: options.projectDir,
		recordNewSnapshots: options.recordNewSnapshots,
		runOnlyExclusive: options.runOnlyExclusive,
		serial: options.s...
setOptions(options)
setChalk(options.chalkOptions)
options.chalkOptions.level > 0
stdout = _tmp_7.stdout
global.console = Object.assign(global.console, new console.Console({stdout, stderr, colorMode: true}))
checkSelectedByLineNumbers = lineNumberSelection({
			file: options.file,
			lineNumbers: options.lineNumbers,
		})
_tmp_10.file = options.file
_tmp_10.lineNumbers = options.lineNumbers
channel.send({type: 'line-number-selection-error', err: serializeError('Line number selection error', false, error, options.file)})
checkSelectedByLineNumbers = () => false
runner = new Runner({
		checkSelectedByLineNumbers,
		experiments: options.experiments,
		failFast: options.failFast,
		failWithoutAssertions: options.failWithoutAssertions,
		file: options.file,
		match: options.match,
		projectDir: options.projectDir,
		recordNewSnapshots: options.recordNewSnapshots,
		runOnlyExclusive: options.runOnlyExclusive,
		serial: options.serial,
		snapshotDir: options.snapshotDir,
		updateSnapshots: options.updateSnapshots,
	})
_tmp_13.checkSelectedByLineNumbers = checkSelectedByLineNumbers
_tmp_13.experiments = options.experiments
_tmp_13.failFast = options.failFast
_tmp_13.failWithoutAssertions = options.failWithoutAssertions
_tmp_13.file = options.file
_tmp_13.match = options.match
_tmp_13.projectDir = options.projectDir
_tmp_13.recordNewSnapshots = options.recordNewSnapshots
_tmp_13.runOnlyExclusive = options.runOnlyExclusive
_tmp_13.serial = options.serial
_tmp_13.snapshotDir = options.snapshotDir
_tmp_13.updateSnapshots = options.updateSnapshots
refs.runnerChain = runner.chain
channel.peerFailed.then(() => {
		runner.interrupt();
	})
runner.on('dependency', dependencyTracking.track)
runner.on('stateChange', state => channel.send(state))
runner.on('error', error => {
		channel.send({type: 'internal-error', err: serializeError('Internal runner error', false, error, runner.file)});
		exit(1);
	})
runner.on('finish', async () => {
		try {
			const {touchedFiles} = await runner.saveSnapshotState();
			if (touchedFiles) {
				channel.send({type: 'touched-files', files: touchedFiles});
			}
		} catch (error) {
			channel.send({type: 'internal-error', err: serializeError('Internal runner error', false, error, runner.file)});
			exit(1);
			return;
		}

		try {
			await Promise.all(sharedWorkerTeardowns.map(fn => fn()));
		} catch (error) {
			channel.send({type: 'uncaught-exception', err: serializeError('Shared worker teardown error', false, error, runner.file)});
			exit(1);
			return;
		}

		nowAndTimers.setImmediate(() => {
			for (const rejection of currentlyUnhandled()) {
				channel.send({type: 'unhandled-rejection', err: serializeError('Unhandled rejection', true, rejection.reason, runner.file)});
			}

			exit(0);
		});
	})
process.on('uncaughtException', error => {
		channel.send({type: 'uncaught-exception', err: serializeError('Uncaught exception', true, error, runner.file)});
		exit(1);
	})
const testPath = options.file
const extensionsToLoadAsModules = Object.entries(options.moduleTypes)
		.filter(([, type]) => type === 'module')
		.map(([extension]) => extension)
type = param1_0.type
extension = param1_1.extension
providerStates = _tmp_24.providerStates === void 0 ? __ecma.Array.factory() : _tmp_24.providerStates
__ecma.Array.factory()
await Promise.all(providerStates.map(async ({type, state}) => {
		if (type === 'typescript') {
			const provider = await providerManager.typescript(projectDir);
			providers.push(provider.worker({extensionsToLoadAsModules, state}));
		}
	}))
const require = createRequire(import.meta.url)
const load = async ref => {
		for (const provider of providers) {
			if (provider.canLoad(ref)) {
				return provider.load(ref, {requireFn: require});
			}
		}

		for (const extension of extensionsToLoadAsModules) {
			if (ref.endsWith(`.${extension}`)) {
				return import(pathToFileURL(ref));
			}
		}

		// We still support require() since it's more easily monkey-patched.
		return require(ref);
	}
_iterator_3 = <operator>.iterator(options.require || [])
await load(ref)
dependencyTracking.install(require.extensions, testPath)
options.debug && options.debug.port !== undefined && options.debug.host !== undefined
_tmp_27 = await import('node:inspector')
!options.debug.active || inspector.url() === undefined
inspector.open(options.debug.port, options.debug.host, true)
options.debug.break
await load(testPath)
flags.loadedMain
channel.send({type: 'missing-ava-import'})
