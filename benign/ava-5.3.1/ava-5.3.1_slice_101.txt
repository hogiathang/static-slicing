var createRequire = require("node:module").createRequire
var process = require("node:process")
var pathToFileURL = require("node:url").pathToFileURL
var workerData = require("node:worker_threads").workerData
var setUpCurrentlyUnhandled = require("currently-unhandled")
var setChalk = require("../chalk.js").set
var nowAndTimers = require("../now-and-timers.cjs")
var providerManager = require("../provider-manager.js")
var Runner = require("../runner.js")
var serializeError = require("../serialize-error.js")
var channel = require("./channel.cjs")
var dependencyTracking = require("./dependency-tracker.js")
var lineNumberSelection = require("./line-numbers.js")
var setOptions = require("./options.cjs").set
var sharedWorkerTeardowns = require("./state.cjs").sharedWorkerTeardowns
var isRunningInChildProcess = require("./utils.cjs").isRunningInChildProcess
const currentlyUnhandled = setUpCurrentlyUnhandled()
apply = _tmp_1.apply
const realExit = process.exit
function exit = async function exit(code, forceSync = false) {
	dependencyTracking.flush();
	const flushing = channel.flush();
	if (!forceSync) {
		await flushing;
	}

	apply(realExit, process, [code]);
}
const handleProcessExit = (fn, receiver, args) => {
	const error = new Error('Unexpected process.exit()');
	Error.captureStackTrace(error, handleProcessExit);
	const {stack} = serializeError('', true, error);
	channel.send({type: 'process-exit', stack});

	// Make sure to extract the code only from `args` rather than e.g. `Array.prototype`.
	// This level of paranoia is usually unwarranted, but we're dealing with test code
	// that has already colored outside the lines.
	const code = args.length > 0 ? args[0] : undefined;

	// Force a synchronous exit as guaranteed by the real process.exit().
	exit(code, true);
}
process.exit = new Proxy(realExit, {
	apply: handleProcessExit,
})
_tmp_6.apply = handleProcessExit
const run = async options => {
	setOptions(options);
	setChalk(options.chalkOptions);

	if (options.chalkOptions.level > 0) {
		const {stdout, stderr} = process;
		global.console = Object.assign(global.console, new console.Console({stdout, stderr, colorMode: true}));
	}

	let checkSelectedByLineNumbers;
	try {
		checkSelectedByLineNumbers = lineNumberSelection({
			file: options.file,
			lineNumbers: options.lineNumbers,
		});
	} catch (error) {
		channel.send({type: 'line-number-selection-error', err: serializeError('Line number selection error', false, error, options.file)});
		checkSelectedByLineNumbers = () => false;
	}

	runner = new Runner({
		checkSelectedByLineNumbers,
		experiments: options.experiments,
		failFast: options.failFast,
		failWithoutAssertions: options.failWithoutAssertions,
		file: options.file,
		match: options.match,
		projectDir: options.projectDir,
		recordNewSnapshots: options.recordNewSnapshots,
		runOnlyExclusive: options.runOnlyExclusive,
		serial: options.s...
const onError = error => {
	// There shouldn't be any errors, but if there are we may not have managed
	// to bootstrap enough code to serialize them. Re-throw and let the process
	// crash.
	setImmediate(() => {
		throw error;
	});
}
channel.send({type: 'starting'})
options = _tmp_31.options
delete workerData.options
channel.send({type: 'ready-for-options'})
options = await channel.options
