req.on('response', res => {
      clearTimeout(reqTimeout)

      const headers = createHeadersLenient(res.headers)

      // HTTP fetch step 5
      if (fetch.isRedirect(res.statusCode)) {
        // HTTP fetch step 5.2
        const location = headers.get('Location')

        // HTTP fetch step 5.3
        let locationURL = null
        try {
          locationURL = location === null ? null : new URL(location, request.url).toString()
        } catch {
          // error here can only be invalid URL in Location: header
          // do not throw when options.redirect == manual
          // let the user extract the errorneous redirect URL
          if (request.redirect !== 'manual') {
            /* eslint-disable-next-line max-len */
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'))
            finalize()
            return
          }
        }

        // HTTP fetch step 5.5
        if (request.redirect === '...
clearTimeout(reqTimeout)
const headers = createHeadersLenient(res.headers)
fetch.isRedirect(res.statusCode)
const location = headers.get('Location')
let locationURL = null
locationURL = location === null ? null : new URL(location, request.url).toString()
request.redirect !== 'manual'
request.redirect === 'error'
request.redirect === 'manual'
locationURL !== null
headers.set('Location', locationURL)
reject(err)
request.redirect === 'follow' && locationURL !== null
res.once('end', () =>
        signal && signal.removeEventListener('abort', abortAndFinalize))
const body = new Minipass()
body.on('error', finalize)
res.on('error', /* istanbul ignore next */ er => body.emit('error', er))
res.on('data', (chunk) => body.write(chunk))
res.on('end', () => body.end())
const responseOptions = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: headers,
        size: request.size,
        timeout: request.timeout,
        counter: request.counter,
        trailer: new Promise(resolveTrailer =>
          res.on('end', () => resolveTrailer(createHeadersLenient(res.trailers)))),
      }
_tmp_45.url = request.url
_tmp_45.status = res.statusCode
_tmp_45.statusText = res.statusMessage
_tmp_45.headers = headers
_tmp_45.size = request.size
_tmp_45.timeout = request.timeout
_tmp_45.counter = request.counter
_tmp_45.trailer = new Promise(resolveTrailer =>
          res.on('end', () => resolveTrailer(createHeadersLenient(res.trailers))))
const codings = headers.get('Content-Encoding')
