function staticPage = async function staticPage({
  pagePath,
  pageData,
  staticQueryContext,
  styles,
  scripts,
  reversedStyles,
  reversedScripts,
  inlinePageData = false,
  context = {},
  webpackCompilationHash,
  sliceData,
}) {
  const renderContext = Object.assign(DEFAULT_CONTEXT, context)

  // for this to work we need this function to be sync or at least ensure there is single execution of it at a time
  global.unsafeBuiltinUsage = []

  try {
    let bodyHtml = ``
    let headComponents = [
      <meta
        name="generator"
        content={`Gatsby ${gatsbyVersion}`}
        key={`generator-${gatsbyVersion}`}
      />,
    ]
    let htmlAttributes = {}
    let bodyAttributes = {}
    let preBodyComponents = []
    let postBodyComponents = []
    let bodyProps = {}

    function loadPageDataSync(_pagePath) {
      if (_pagePath === pagePath) {
        // no need to use fs if we are asking for pageData of current page
        return pageData
      }

      const pageDataPath = getPageDat...
pagePath = param1_0.pagePath
pageData = param1_0.pageData
staticQueryContext = param1_0.staticQueryContext
styles = param1_0.styles
scripts = param1_0.scripts
reversedStyles = param1_0.reversedStyles
reversedScripts = param1_0.reversedScripts
inlinePageData = param1_0.inlinePageData
context = param1_0.context
webpackCompilationHash = param1_0.webpackCompilationHash
sliceData = param1_0.sliceData
const renderContext = Object.assign(DEFAULT_CONTEXT, context)
global.unsafeBuiltinUsage = []
let bodyHtml = ``
let headComponents = [
      <meta
        name="generator"
        content={`Gatsby ${gatsbyVersion}`}
        key={`generator-${gatsbyVersion}`}
      />,
    ]
_tmp_23.push(<meta
        name="generator"
        content={`Gatsby ${gatsbyVersion}`}
        key={`generator-${gatsbyVersion}`}
      />)
"generator"
<operator>.formatString("Gatsby ", gatsbyVersion, "")
<operator>.formatString("generator-", gatsbyVersion, "")
let htmlAttributes = {}
let bodyAttributes = {}
let preBodyComponents = []
let postBodyComponents = []
let bodyProps = {}
function loadPageDataSync = function loadPageDataSync(_pagePath) {
      if (_pagePath === pagePath) {
        // no need to use fs if we are asking for pageData of current page
        return pageData
      }

      const pageDataPath = getPageDataPath(_pagePath)
      const pageDataFile = join(process.cwd(), `public`, pageDataPath)
      try {
        // deprecation notice
        const myErrorHolder = {
          name: `Usage of loadPageDataSync for page other than currently generated page disables incremental html generation in future builds`,
        }
        Error.captureStackTrace(myErrorHolder, loadPageDataSync)
        global.unsafeBuiltinUsage.push(myErrorHolder.stack)
        const pageDataJson = fs.readFileSync(pageDataFile)
        return JSON.parse(pageDataJson)
      } catch (error) {
        // not an error if file is not found. There's just no page data
        return null
      }
    }
const replaceBodyHTMLString = body => {
      bodyHtml = body
    }
const setHeadComponents = components => {
      headComponents = headComponents.concat(sanitizeComponents(components))
    }
const setHtmlAttributes = attributes => {
      // TODO - we should remove deep merges
      htmlAttributes = deepMerge(htmlAttributes, attributes)
    }
const setBodyAttributes = attributes => {
      // TODO - we should remove deep merges
      bodyAttributes = deepMerge(bodyAttributes, attributes)
    }
const setPreBodyComponents = components => {
      preBodyComponents = preBodyComponents.concat(
        sanitizeComponents(components)
      )
    }
const setPostBodyComponents = components => {
      postBodyComponents = postBodyComponents.concat(
        sanitizeComponents(components)
      )
    }
const setBodyProps = props => {
      // TODO - we should remove deep merges
      bodyProps = deepMerge({}, bodyProps, props)
    }
const getHeadComponents = () => headComponents
const replaceHeadComponents = components => {
      headComponents = sanitizeComponents(components)
    }
const getPreBodyComponents = () => preBodyComponents
const replacePreBodyComponents = components => {
      preBodyComponents = sanitizeComponents(components)
    }
const getPostBodyComponents = () => postBodyComponents
const replacePostBodyComponents = components => {
      postBodyComponents = sanitizeComponents(components)
    }
componentChunkName = _tmp_28.componentChunkName
const pageComponent = await asyncRequires.components[componentChunkName]()
RouteHandler = package\cache-dir\static-entry.js::program:staticPage:RouteHandler:<init>
const routerElement = (
      <ServerLocation url={`${__BASE_PATH__}${pagePath}`}>
        <Router id="gatsby-focus-wrapper" baseuri={__BASE_PATH__}>
          <RouteHandler path="/*" />
        </Router>
        <div {...RouteAnnouncerProps} />
      </ServerLocation>
    )
<operator>.formatString("", __BASE_PATH__, "", pagePath, "")
"gatsby-focus-wrapper"
const sliceProps = {}
let body = apiRunner(
      `wrapRootElement`,
      { element: routerElement, pathname: pagePath },
      routerElement,
      ({ result }) => {
        return { element: result, pathname: pagePath }
      }
    ).pop()
"wrapRootElement"
_tmp_38.element = routerElement
result = param1_2.result
pop
const slicesContext = {
      // if we're in build now, we know we're on the server
      // otherwise we're in an engine
      renderEnvironment: renderContext.isDuringBuild ? `server` : `engines`,
    }
_tmp_40.renderEnvironment = renderContext.isDuringBuild ? "server" : "engines"
process.env.GATSBY_SLICES
slicesContext.renderEnvironment === `engines`
const slicesDb = new Map()
_iterator_0 = <operator>.iterator(Object.values(slicesMap))
const slice = sliceData[sliceName]
_tmp_42 = await getPageChunk(slice)
const sliceObject = {
            component: SliceComponent,
            sliceContext: slice.result.sliceContext,
            data: slice.result.data,
          }
_tmp_43.component = SliceComponent
_tmp_43.sliceContext = slice.result.sliceContext
_tmp_43.data = slice.result.data
slicesDb.set(sliceName, sliceObject)
body = (
          <SlicesResultsContext.Provider value={slicesDb}>
            {body}
          </SlicesResultsContext.Provider>
        )
body = (
        <SlicesContext.Provider value={slicesContext}>
          <SlicesPropsContext.Provider value={sliceProps}>
            <SlicesMapContext.Provider value={slicesMap}>
              {body}
            </SlicesMapContext.Provider>
          </SlicesPropsContext.Provider>
        </SlicesContext.Provider>
      )
const bodyComponent = (
      <StaticQueryContext.Provider value={staticQueryContext}>
        {body}
      </StaticQueryContext.Provider>
    )
await apiRunnerAsync(`replaceRenderer`, {
      bodyComponent,
      replaceBodyHTMLString,
      setHeadComponents,
      setHtmlAttributes,
      setBodyAttributes,
      setPreBodyComponents,
      setPostBodyComponents,
      setBodyProps,
      pathname: pagePath,
      pathPrefix: __PATH_PREFIX__,
    })
_tmp_44.bodyComponent = bodyComponent
_tmp_44.replaceBodyHTMLString = replaceBodyHTMLString
_tmp_44.setHeadComponents = setHeadComponents
_tmp_44.setHtmlAttributes = setHtmlAttributes
_tmp_44.setBodyAttributes = setBodyAttributes
_tmp_44.setPreBodyComponents = setPreBodyComponents
_tmp_44.setPostBodyComponents = setPostBodyComponents
_tmp_44.setBodyProps = setBodyProps
_tmp_44.pathname = pagePath
_tmp_44.pathPrefix = __PATH_PREFIX__
!bodyHtml
const writableStream = new WritableAsPromise()
_tmp_47 = renderToPipeableStream(bodyComponent, {
          onAllReady() {
            pipe(writableStream)
          },
          onError(error) {
            writableStream.destroy(error)
          },
        })
_tmp_46.onAllReady = onAllReady
_tmp_46.onError = onError
bodyHtml = await writableStream
!isRedirect(e)
apiRunner(`onRenderBody`, {
      setHeadComponents,
      setHtmlAttributes,
      setBodyAttributes,
      setPreBodyComponents,
      setPostBodyComponents,
      setBodyProps,
      pathname: pagePath,
      loadPageDataSync,
      bodyHtml,
      scripts,
      styles,
      pathPrefix: __PATH_PREFIX__,
    })
_tmp_48.setHeadComponents = setHeadComponents
_tmp_48.setHtmlAttributes = setHtmlAttributes
_tmp_48.setBodyAttributes = setBodyAttributes
_tmp_48.setPreBodyComponents = setPreBodyComponents
_tmp_48.setPostBodyComponents = setPostBodyComponents
_tmp_48.setBodyProps = setBodyProps
_tmp_48.pathname = pagePath
_tmp_48.loadPageDataSync = loadPageDataSync
_tmp_48.bodyHtml = bodyHtml
_tmp_48.scripts = scripts
_tmp_48.styles = styles
_tmp_48.pathPrefix = __PATH_PREFIX__
headHandlerForSSR({
      pageComponent,
      setHeadComponents,
      setHtmlAttributes,
      setBodyAttributes,
      staticQueryContext,
      pageData,
      pagePath,
    })
_tmp_49.pageComponent = pageComponent
_tmp_49.setHeadComponents = setHeadComponents
_tmp_49.setHtmlAttributes = setHtmlAttributes
_tmp_49.setBodyAttributes = setBodyAttributes
_tmp_49.staticQueryContext = staticQueryContext
_tmp_49.pageData = pageData
_tmp_49.pagePath = pagePath
reversedScripts.forEach(script => {
      // Add preload/prefetch <link>s magic comments
      if (script.shouldGenerateLink) {
        headComponents.push(
          <link
            as="script"
            rel={script.rel}
            key={script.name}
            href={`${__PATH_PREFIX__}/${script.name}`}
          />
        )
      }
    })
reversedStyles.forEach(style => {
      // Add <link>s for styles that should be prefetched
      // otherwise, inline as a <style> tag

      if (style.rel === `prefetch`) {
        headComponents.push(
          <link
            as="style"
            rel={style.rel}
            key={style.name}
            href={`${__PATH_PREFIX__}/${style.name}`}
          />
        )
      } else {
        headComponents.unshift(
          <style
            data-href={`${__PATH_PREFIX__}/${style.name}`}
            data-identity={`gatsby-global-css`}
            dangerouslySetInnerHTML={{
              __html: style.content,
            }}
          />
        )
      }
    })
const windowPageData = `/*<![CDATA[*/window.pagePath=${JSON.stringify(
      pagePath
    )};${
      process.env.GATSBY_SLICES
        ? ``
        : `window.___webpackCompilationHash="${webpackCompilationHash}";`
    }${
      inlinePageData ? `window.pageData=${JSON.stringify(pageData)};` : ``
    }/*]]>*/`
process.env.GATSBY_SLICES ? "" : <operator>.formatString("window.___webpackCompilationHash="", webpackCompilationHash, "";")
<operator>.formatString("window.___webpackCompilationHash="", webpackCompilationHash, "";")
inlinePageData ? <operator>.formatString("window.pageData=", JSON.stringify(pageData), ";") : ""
postBodyComponents.push(
      <script
        key={`script-loader`}
        id={`gatsby-script-loader`}
        dangerouslySetInnerHTML={{
          __html: windowPageData,
        }}
      />
    )
"script-loader"
"gatsby-script-loader"
_tmp_51.__html = windowPageData
process.env.GATSBY_SLICES
const chunkMapping = require(`../public/chunk-map.json`)
<operator>.formatString("/*<![CDATA[*/window.___chunkMapping=", JSON.stringify(
        chunkMapping
      ), ";/*]]>*/")
