patches.forEach(patch => {
			const {path, op} = patch

			let base: any = draft
			for (let i = 0; i < path.length - 1; i++) {
				const parentType = getArchtype(base)
				let p = path[i]
				if (typeof p !== "string" && typeof p !== "number") {
					p = "" + p
				}

				// See #738, avoid prototype pollution
				if (
					(parentType === ArchType.Object || parentType === ArchType.Array) &&
					(p === "__proto__" || p === "constructor")
				)
					die(errorOffset + 3)
				if (typeof base === "function" && p === "prototype")
					die(errorOffset + 3)
				base = get(base, p)
				if (typeof base !== "object") die(errorOffset + 2, path.join("/"))
			}

			const type = getArchtype(base)
			const value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411
			const key = path[path.length - 1]
			switch (op) {
				case REPLACE:
					switch (type) {
						case ArchType.Map:
							return base.set(key, value)
						/* istanbul ignore n...
path = _tmp_29.path
let base: any = draft
i < path.length - 1
const parentType = getArchtype(base)
let p = path[i]
typeof p !== "string" && typeof p !== "number"
p = "" + p
(parentType === ArchType.Object || parentType === ArchType.Array) &&
					(p === "__proto__" || p === "constructor")
p === "__proto__" || p === "constructor"
die(errorOffset + 3)
typeof base === "function" && p === "prototype"
die(errorOffset + 3)
base = get(base, p)
die(errorOffset + 2, path.join("/"))
const type = getArchtype(base)
const value = deepClonePatchValue(patch.value)
const key = path[path.length - 1]
case REMOVE:
ArchType.Map
base.delete(key)
