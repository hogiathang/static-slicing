emitter.on('request', function (err, o) {
        if (err) {
            print.lf(colors.red('[errored]'));
            print.lf(colors.red('     %s'), err.message);

            return;
        }

        if (!(o.request && o.response)) {
            print.lf(colors.red('[errored]'));
            print.lf(colors.red('     %s'), 'Internal error! Could not read response data.');

            return;
        }

        // quickly print out basic non verbose response meta and exit
        if (!options.verbose) {
            print.lf(colors.gray('[%d %s, %s, %s]'), o.response.code, o.response.reason(),
                util.filesize(o.response.size().total), util.prettyms(o.response.responseTime));

            return;
        }

        // this point onwards the output is verbose. a tonne of variables are created here for
        // keeping the output clean and readable

        let req = o.request,
            res = o.response,

            // set values here with abundance of caution ...
!(o.request && o.response)
!options.verbose
let req = o.request
let res = o.response
let reqSize = util.filesize(req.size().total)
let resSize = util.filesize(res.size().total)
let code = res.code
let reason = res.reason()
let mime = res.contentInfo() || {}
let timings = _.last(_.get(o, 'history.execution.data'))
let reqHeadersLen = _.get(req, 'headers.members.length')
let resHeadersLen = _.get(res, 'headers.members.length')
let resTime = util.prettyms(res.responseTime || 0)
let reqText = (options.verbose && req.body) ? req.body.toString() : E
let reqTextLen = req.size().body || Buffer.byteLength(reqText)
let resText = options.verbose ? res.text() : E
let resTextLen = res.size().body || Buffer.byteLength(resText)
let reqBodyMode = _.get(req, 'body.mode', '')
let resSummary = [
                `${mime.contentType}`,
                `${mime.mimeType}`,
                `${mime.mimeFormat}`,
                `${mime.charset}`
            ].join(` ${colors.gray(symbols.star)} `)
_tmp_13.push(<operator>.formatString("", mime.contentType, ""))
_tmp_13.push(<operator>.formatString("", mime.mimeType, ""))
_tmp_13.push(<operator>.formatString("", mime.mimeFormat, ""))
_tmp_13.push(<operator>.formatString("", mime.charset, ""))
<operator>.formatString(" ", colors.gray(symbols.star), " ")
print.lf(SPC)
print.lf(SPC + SPC + [
            `${code} ${reason}`,
            `${resTime} ${colors.gray('time')}`,
            `${reqSize}${colors.gray(symbols.up)} ${resSize}${colors.gray(symbols.down)} ${colors.gray('size')}`,
            `${reqHeadersLen}${colors.gray(symbols.up)} ` +
                `${resHeadersLen}${colors.gray(symbols.down)} ${colors.gray('headers')}`,
            `${_.get(res, 'cookies.members.length')} ${colors.gray('cookies')}`
        ].join(` ${colors.gray(symbols.star)} `))
_tmp_15.push(<operator>.formatString("", code, " ", reason, ""))
_tmp_15.push(<operator>.formatString("", resTime, " ", colors.gray('time'), ""))
_tmp_15.push(<operator>.formatString("", reqSize, "", colors.gray(symbols.up), " ", resSize, "", colors.gray(symbols.down), " ", colors.gray('size'), ""))
_tmp_15.push(`${reqHeadersLen}${colors.gray(symbols.up)} ` +
                `${resHeadersLen}${colors.gray(symbols.down)} ${colors.gray('headers')}`)
<operator>.formatString("", resHeadersLen, "", colors.gray(symbols.down), " ", colors.gray('headers'), "")
_tmp_15.push(<operator>.formatString("", _.get(res, 'cookies.members.length'), " ", colors.gray('cookies'), ""))
