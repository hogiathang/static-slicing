AST_Scope.DEFMETHOD("hoist_declarations", function(compressor){
        var self = this;
        if (compressor.has_directive("use asm")) return self;
        var hoist_funs = compressor.option("hoist_funs");
        var hoist_vars = compressor.option("hoist_vars");
        if (hoist_funs || hoist_vars) {
            var dirs = [];
            var hoisted = [];
            var vars = new Dictionary(), vars_found = 0, var_decl = 0;
            // let's count var_decl first, we seem to waste a lot of
            // space if we hoist `var` when there's only one.
            self.walk(new TreeWalker(function(node){
                if (node instanceof AST_Scope && node !== self)
                    return true;
                if (node instanceof AST_Var) {
                    ++var_decl;
                    return true;
                }
            }));
            hoist_vars = hoist_vars && var_decl > 1;
            var tt = new TreeTransformer(
                function before(node) {...
var self = this
compressor.has_directive("use asm")
var hoist_funs = compressor.option("hoist_funs")
var hoist_vars = compressor.option("hoist_vars")
hoist_funs || hoist_vars
__ecma.Array.factory()
__ecma.Array.factory()
var vars = new Dictionary()
self.walk(new TreeWalker(function(node){
                if (node instanceof AST_Scope && node !== self)
                    return true;
                if (node instanceof AST_Var) {
                    ++var_decl;
                    return true;
                }
            }))
hoist_vars = hoist_vars && var_decl > 1
var tt = new TreeTransformer(
                function before(node) {
                    if (node !== self) {
                        if (node instanceof AST_Directive) {
                            dirs.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Defun && hoist_funs) {
                            hoisted.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Var && hoist_vars) {
                            node.definitions.forEach(function(def){
                                vars.set(def.name.name, def);
                                ++vars_found;
                            });
                            var seq = node.to_assignments(compressor);
                            var p = tt.parent();
                            if (p instanceof AST_ForIn && p.init === nod...
before
self = self.transform(tt)
vars_found > 0
__ecma.Array.factory()
vars.each(function(def, name){
                    if (self instanceof AST_Lambda
                        && find_if(function(x){ return x.name == def.name.name },
                                   self.argnames)) {
                        vars.del(name);
                    } else {
                        def = def.clone();
                        def.value = null;
                        defs.push(def);
                        vars.set(name, def);
                    }
                })
defs.length > 0
i < self.body.length
self.body[i] instanceof AST_SimpleStatement
var expr = self.body[i].body
expr instanceof AST_Assign
                                && expr.operator == "="
                                && (sym = expr.left) instanceof AST_Symbol
                                && vars.has(sym.name)
expr.operator == "="
(sym = expr.left) instanceof AST_Symbol
vars.has(sym.name)
var def = vars.get(sym.name)
def.value
def.value = expr.right
remove(defs, def)
defs.push(def)
(_tmp_1646 = self.body).splice
continue;
expr instanceof AST_Seq
                                && (assign = expr.car) instanceof AST_Assign
                                && assign.operator == "="
                                && (sym = assign.left) instanceof AST_Symbol
                                && vars.has(sym.name)
(assign = expr.car) instanceof AST_Assign
assign.operator == "="
(sym = assign.left) instanceof AST_Symbol
vars.has(sym.name)
var def = vars.get(sym.name)
def.value
def.value = assign.right
remove(defs, def)
defs.push(def)
self.body[i].body = expr.cdr
continue;
self.body[i] instanceof AST_EmptyStatement
(_tmp_1647 = self.body).splice
continue;
self.body[i] instanceof AST_BlockStatement
var tmp = [ i, 1 ].concat(self.body[i].body)
self.body.splice.apply(self.body, tmp)
continue;
