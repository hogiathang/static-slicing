_proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {
    var _this2 = this;
    var environment = this._environment;

    // NOTE: Running `check` will write missing data to the store using any
    // missing data handlers specified on the environment;
    // We run it here first to make the handlers get a chance to populate
    // missing data.
    var queryAvailability = environment.check(operation);
    var queryStatus = queryAvailability.status;
    var hasFullQuery = queryStatus === 'available';
    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';
    var shouldFetch;
    var shouldAllowRender;
    // Different definitions for Promise in our repos can cause this variable
    // to cause errors when synced elsewhere
    var resolveNetworkPromise = function resolveNetworkPromise() {};
    switch (fetchPolicy) {
      case 'store-only...
var _this2 = this
var environment = this._environment
var queryAvailability = environment.check(operation)
var queryStatus = queryAvailability.status
var hasFullQuery = queryStatus === 'available'
var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale'
var resolveNetworkPromise = function resolveNetworkPromise() {}
"store-only"
shouldFetch = false
shouldAllowRender = true
break;
"store-or-network"
shouldFetch = !hasFullQuery
shouldAllowRender = canPartialRender
break;
"store-and-network"
shouldFetch = true
shouldAllowRender = canPartialRender
break;
"network-only"
default:
shouldFetch = true
shouldAllowRender = false
break;
var queryResult = getQueryResult(operation, cacheIdentifier)
var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry)
this._cache.set(cacheIdentifier, _cacheEntry)
var _queryResult = getQueryResult(operation, cacheIdentifier)
fetchObservable.subscribe({
        start: function start(subscription) {
          networkSubscription = subscription;
          var cacheEntry = _this2._cache.get(cacheIdentifier);
          if (cacheEntry) {
            cacheEntry.setNetworkSubscription(networkSubscription);
          }
          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;
          if (observerStart) {
            var subscriptionWithConditionalCancelation = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, subscription), {}, {
              unsubscribe: function unsubscribe() {
                // Only live queries should have their network requests canceled.
                if (operationIsLiveQuery(operation)) {
                  subscription.unsubscribe();
                }
              }
            });
            observerStart(subscriptionWithConditionalCancelation);
          }
        },
        next: function next() {
          var cacheEntry =...
_tmp_25.start = start
_tmp_25.next = next
_tmp_25.error = error
_tmp_25.complete = complete
_tmp_25.unsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe
var _cacheEntry2 = this._cache.get(cacheIdentifier)
!_cacheEntry2
var networkPromise = new Promise(function (resolve) {
          resolveNetworkPromise = resolve;
        })
networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')'
_cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry)
this._cache.set(cacheIdentifier, _cacheEntry2)
var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete
observerComplete && observerComplete()
var cacheEntry = this._cache.get(cacheIdentifier)
