_proto._fetchPage = function _fetchPage(paginatingVariables, observer, options) {
      var _this3 = this;
      var _assertRelayContext = assertRelayContext(this.props.__relayContext),
        environment = _assertRelayContext.environment;
      var _this$props2 = this.props,
        _ = _this$props2.componentRef,
        __relayContext = _this$props2.__relayContext,
        __rootIsQueryRenderer = _this$props2.__rootIsQueryRenderer,
        restProps = (0, _objectWithoutPropertiesLoose2["default"])(_this$props2, _excluded2);
      var props = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, restProps), this.state.data);
      var fragmentVariables;
      var rootVariables = getRootVariablesForFragments(fragments, restProps);
      fragmentVariables = getVariablesFromObject(fragments, restProps);
      fragmentVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, rootVariables), fragmentVariables), this._refetc...
var _this3 = this
var _assertRelayContext = assertRelayContext(this.props.__relayContext)
var environment = _assertRelayContext.environment
var _this$props2 = this.props
var _ = _this$props2.componentRef
var __relayContext = _this$props2.__relayContext
var __rootIsQueryRenderer = _this$props2.__rootIsQueryRenderer
var restProps = (0, _objectWithoutPropertiesLoose2["default"])(_this$props2, _excluded2)
var props = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, restProps), this.state.data)
var rootVariables = getRootVariablesForFragments(fragments, restProps)
fragmentVariables = getVariablesFromObject(fragments, restProps)
fragmentVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, rootVariables), fragmentVariables), this._refetchVariables)
var fetchVariables = connectionConfig.getVariables(props, {
        count: paginatingVariables.count,
        cursor: paginatingVariables.cursor
      }, fragmentVariables)
_tmp_36.count = paginatingVariables.count
_tmp_36.cursor = paginatingVariables.cursor
!(typeof fetchVariables === 'object' && fetchVariables !== null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getVariables()` to ' + 'return an object, got `%s` in `%s`.', fetchVariables, componentName) : invariant(false) : void 0
fetchVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, fetchVariables), this._refetchVariables)
fragmentVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, fetchVariables), fragmentVariables)
var cacheConfig = options ? {
        force: !!options.force
      } : undefined
_tmp_39.force = !!options.force
cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null
cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata
var request = getRequest(connectionConfig.query)
var operation = createOperationDescriptor(request, fetchVariables, cacheConfig)
var refetchSubscription = null
this._refetchSubscription
(_tmp_40 = this._refetchSubscription).unsubscribe
this._hasFetched = true
var onNext = function onNext(payload, complete) {
        var prevData = _this3._resolver.resolve();
        _this3._resolver.setVariables(getFragmentVariables(fragmentVariables, paginatingVariables.totalCount), operation.request.node);
        var nextData = _this3._resolver.resolve();

        // Workaround slightly different handling for connection in different
        // core implementations:
        // - Classic core requires the count to be explicitly incremented
        // - Modern core automatically appends new items, updating the count
        //   isn't required to see new data.
        //
        // `setState` is only required if changing the variables would change the
        // resolved data.
        // TODO #14894725: remove PaginationContainer equal check
        if (!areEqual(prevData, nextData)) {
          _this3.setState({
            data: nextData,
            contextForChildren: {
              environment: _this3.props.__relayContext.environment
            }
    ...
var cleanup = function cleanup() {
        if (_this3._refetchSubscription === refetchSubscription) {
          _this3._refetchSubscription = null;
          _this3._isARequestInFlight = false;
        }
      }
this._isARequestInFlight = true
refetchSubscription = this._getQueryFetcher().execute({
        environment: environment,
        operation: operation,
        preservePreviousReferences: true
      }).mergeMap(function (payload) {
        return Observable.create(function (sink) {
          onNext(payload, function () {
            sink.next(); // pass void to public observer's `next`
            sink.complete();
          });
        });
      })
      // use do instead of finally so that observer's `complete` fires after cleanup
      ["do"]({
        error: cleanup,
        complete: cleanup,
        unsubscribe: cleanup
      }).subscribe(observer || {})
_tmp_50.environment = environment
_tmp_50.operation = operation
_tmp_50.preservePreviousReferences = true
