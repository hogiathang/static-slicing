function applyMemberDecs = function applyMemberDecs(Class, decInfos, instanceBrand) {
  var ret = [];
  var protoInitializers;
  var staticInitializers;
  var staticBrand;
  var existingProtoNonFields = new Map();
  var existingStaticNonFields = new Map();
  for (var i = 0; i < decInfos.length; i++) {
    var decInfo = decInfos[i];
    if (!Array.isArray(decInfo)) continue;
    var kind = decInfo[1];
    var name = decInfo[2];
    var isPrivate = decInfo.length > 3;
    var decoratorsHaveThis = kind & 16;
    var isStatic = !!(kind & 8);
    var base;
    var initializers;
    var hasPrivateBrand = instanceBrand;
    kind &= 7;
    if (isStatic) {
      base = Class;
      if (kind !== 0) {
        staticInitializers = staticInitializers || [];
        initializers = staticInitializers;
      }
      if (isPrivate && !staticBrand) {
        staticBrand = function (_) {
          return _checkInRHS(_) === Class;
        };
      }
      hasPrivateBrand = staticBrand;
    } else {
      base = Class.prototype;
...
__ecma.Array.factory()
var existingProtoNonFields = new Map()
var existingStaticNonFields = new Map()
i < decInfos.length
var decInfo = decInfos[i]
!Array.isArray(decInfo)
var kind = decInfo[1]
var name = decInfo[2]
var isPrivate = decInfo.length > 3
var decoratorsHaveThis = kind & 16
var isStatic = !!(kind & 8)
var hasPrivateBrand = instanceBrand
kind &= 7
base = Class
kind !== 0
staticInitializers = staticInitializers || []
initializers = staticInitializers
isPrivate && !staticBrand
staticBrand = function (_) {
          return _checkInRHS(_) === Class;
        }
hasPrivateBrand = staticBrand
base = Class.prototype
kind !== 0
protoInitializers = protoInitializers || []
initializers = protoInitializers
kind !== 0 && !isPrivate
var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields
var existingKind = existingNonFields.get(name) || 0
existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3
throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
existingNonFields.set(name, !existingKind && kind > 2 ? kind : true)
applyMemberDec(ret, base, decInfo, decoratorsHaveThis, name, kind, isStatic, isPrivate, initializers, hasPrivateBrand)
